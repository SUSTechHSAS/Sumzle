<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Sumzle Solver (WASM)</title>
    <style>
        /* CSS styles from the original file */
        :root {
            --font-family: "Segoe UI", -apple-system, BlinkMacSystemFont, Roboto, "Helvetica Neue", Arial, "Noto Sans", sans-serif;
            --color-background: #f8f9fa;
            --color-surface: #ffffff;
            --color-text: #212529;
            --color-text-secondary: #6c757d;
            --color-border: #dee2e6;
            --color-border-light: #f1f3f5;
            --color-divider: #e9ecef;
            --color-correct: #28a745;
            --color-present: #ffc107;
            --color-absent: #7a7a7a;
            --color-key-feedback-text: #ffffff;
            --fluent-blue: #007bff;
            --fluent-blue-hover: #0069d9;
            --fluent-blue-active: #0056b3;
            --color-danger: #dc3545;
            --tile-border-radius: 6px;
            --button-border-radius: 5px;
            --modal-border-radius: 8px;
            --shadow-xs: 0 1px 2px rgba(0,0,0,0.05);
            --shadow-s: 0 2px 4px rgba(0,0,0,0.07);
            --shadow-m: 0 4px 8px rgba(0,0,0,0.08), 0 0 1px rgba(0,0,0,0.06);
            --shadow-l: 0 8px 16px rgba(0,0,0,0.1), 0 0 2px rgba(0,0,0,0.07);
        }

        body.dark-theme {
            --color-background: #1a1a1d;
            --color-surface: #2c2f33;
            --color-text: #f0f0f0;
            --color-text-secondary: #a0a0a0;
            --color-border: #424549;
            --color-border-light: #36393f;
            --color-divider: #36393f;
        }

        body {
            font-family: var(--font-family);
            margin: 0;
            padding: 0;
            background-color: var(--color-background);
            color: var(--color-text);
            min-height: 100vh;
            transition: background-color .3s ease-in-out, color .3s ease-in-out;
        }

        header {
            width: 100%;
            padding: 15px 0;
            border-bottom: 1px solid var(--color-divider);
            text-align: center;
            background-color: var(--color-surface);
            box-shadow: var(--shadow-s);
            position: sticky;
            top: 0;
            z-index: 100;
        }

        .header-title {
            font-weight: 800;
            font-size: 2rem;
            background: linear-gradient(45deg, #ff6b6b, #4ecdc4, #45b7d1);
            background-size: 300% 300%;
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
            animation: titleShimmer 3s ease-in-out infinite;
        }

        @keyframes titleShimmer {
            0%, 100% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            display: flex;
            gap: 30px;
        }

        .left-panel, .right-panel {
            flex: 1;
            background-color: var(--color-surface);
            border-radius: var(--modal-border-radius);
            padding: 25px;
            box-shadow: var(--shadow-m);
            height: fit-content;
        }

        .section-title {
            font-size: 1.4rem;
            font-weight: 600;
            margin-bottom: 20px;
            color: var(--color-text);
            border-bottom: 2px solid var(--color-divider);
            padding-bottom: 10px;
        }

        .input-group {
            margin-bottom: 25px;
        }

        .input-label {
            display: block;
            margin-bottom: 8px;
            font-weight: 500;
            color: var(--color-text);
        }

        .length-input {
            width: 100px;
            padding: 10px;
            border: 2px solid var(--color-border);
            border-radius: var(--button-border-radius);
            font-size: 1rem;
            background-color: var(--color-background);
            color: var(--color-text);
            transition: border-color 0.3s ease;
        }

        .length-input:focus {
            outline: none;
            border-color: var(--fluent-blue);
        }

        .constraint-board-wrapper {
            width: 100%;
            overflow-x: auto;
            padding-bottom: 10px;
        }

        .constraint-board {
            display: flex;
            flex-direction: column;
            gap: 10px;
            min-width: min-content;
        }

        .constraint-row {
            display: grid;
            gap: 8px;
        }

        .constraint-tile {
            width: 50px;
            height: 50px;
            border: 2px solid var(--color-border-light);
            border-radius: var(--tile-border-radius);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.2rem;
            font-weight: 600;
            cursor: pointer;
            background-color: var(--color-surface);
            color: var(--color-text);
            transition: all 0.3s ease;
            user-select: none;
        }

        .constraint-tile:hover {
            transform: scale(1.05);
            box-shadow: var(--shadow-s);
        }

        .constraint-tile.correct {
            background-color: var(--color-correct);
            border-color: var(--color-correct);
            color: var(--color-key-feedback-text);
        }

        .constraint-tile.present {
            background-color: var(--color-present);
            border-color: var(--color-present);
            color: var(--color-key-feedback-text);
        }

        .constraint-tile.empty {
            opacity: 0.8;
        }
        .constraint-tile.empty:not(:empty) {
             background-color: var(--color-absent);
             color: var(--color-key-feedback-text);
             border-color: var(--color-absent);
             opacity: 0.7;
        }


        .keyboard {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(45px, 1fr));
            gap: 8px;
            margin-bottom: 20px;
        }

        .key {
            padding: 12px 0;
            border: 2px solid var(--color-border);
            border-radius: var(--button-border-radius);
            background-color: var(--color-background);
            color: var(--color-text);
            font-size: 1.1rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
            text-align: center;
            user-select: none;
        }

        .key:hover {
            background-color: var(--color-border);
            transform: translateY(-2px);
        }

        .key:active {
            transform: translateY(0);
        }

        .control-buttons {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-bottom: 20px;
        }

        .btn {
            padding: 12px 20px;
            border: none;
            border-radius: var(--button-border-radius);
            font-size: 1rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
            flex-grow: 1;
            min-width: 120px;
        }

        .btn-primary {
            background-color: var(--fluent-blue);
            color: white;
        }
        .btn-primary:hover { background-color: var(--fluent-blue-hover); }
        .btn-secondary { background-color: var(--color-border); color: var(--color-text); }
        .btn-secondary:hover { background-color: var(--color-divider); }
        .btn-danger { background-color: var(--color-danger); color: white; }
        .btn-danger:hover { background-color: #c82333; }

        .progress-container { margin: 20px 0; display: none; }
        .progress-bar { width: 100%; height: 20px; background-color: var(--color-border-light); border-radius: 10px; overflow: hidden; position: relative; }
        .progress-fill { height: 100%; background: linear-gradient(90deg, var(--fluent-blue), var(--color-correct)); width: 0%; transition: width 0.3s ease; }
        .progress-text { text-align: center; margin-top: 8px; font-size: 0.9rem; color: var(--color-text-secondary); }

        .results-container { max-height: 300px; overflow-y: auto; border: 2px solid var(--color-border); border-radius: var(--button-border-radius); padding: 15px; background-color: var(--color-background); }
        .result-item { padding: 10px; margin: 5px 0; background-color: var(--color-surface); border-radius: var(--button-border-radius); border-left: 4px solid var(--color-correct); font-family: monospace; font-size: 1.1rem; box-shadow: var(--shadow-xs); transition: transform 0.2s ease; }
        .result-item:hover { transform: translateX(5px); }
        .result-item.recommended {
            border-left-color: var(--fluent-blue);
            background-color: color-mix(in srgb, var(--fluent-blue) 5%, var(--color-surface));
        }
         .recommended-result-item {
            padding: 12px 15px;
            margin: 0;
            background-color: color-mix(in srgb, var(--fluent-blue) 10%, var(--color-surface));
            border-radius: var(--button-border-radius);
            border-left: 5px solid var(--fluent-blue);
            font-family: monospace;
            font-size: 1.2rem;
            font-weight: bold;
            box-shadow: var(--shadow-s);
        }


        .stats { display: grid; grid-template-columns: repeat(2, 1fr); gap: 15px; margin-top: 20px; }
        .stat-card { background-color: var(--color-background); padding: 15px; border-radius: var(--button-border-radius); text-align: center; box-shadow: var(--shadow-xs); }
        .stat-number { font-size: 1.8rem; font-weight: 700; color: var(--fluent-blue); }
        .stat-label { font-size: 0.9rem; color: var(--color-text-secondary); margin-top: 5px; }

        .theme-toggle { position: fixed; top: 20px; right: 20px; width: 50px; height: 50px; border-radius: 50%; border: none; background-color: var(--color-surface); color: var(--color-text); font-size: 1.5rem; cursor: pointer; box-shadow: var(--shadow-m); transition: all 0.3s ease; z-index: 101; }
        .theme-toggle:hover { transform: scale(1.1); }

        .error-message { background-color: var(--color-danger); color: white; padding: 10px; border-radius: var(--button-border-radius); margin: 10px 0; display: none; }

        .help-section { background-color: var(--color-background); padding: 15px; border-radius: var(--button-border-radius); margin-bottom: 20px; border-left: 4px solid var(--fluent-blue); }
        .help-title { font-weight: 600; margin-bottom: 8px; color: var(--fluent-blue); }
        .help-text { font-size: 0.9rem; color: var(--color-text-secondary); line-height: 1.4; }

        .constraint-explanation { font-size: 0.8rem; color: var(--color-text-secondary); margin-top: 5px; text-align: center; }
        .keyboard-explanation { font-size: 0.8rem; color: var(--color-text-secondary); margin-top: -10px; margin-bottom: 15px; text-align: center; }

        .result-count { font-weight: 600; color: var(--color-correct); margin-bottom: 15px; font-size: 1.1rem; }
        .prob-item { display: flex; justify-content: space-between; align-items: center; padding: 8px 10px; margin-bottom: 4px; background-color: var(--color-surface); border-radius: var(--button-border-radius); border-left: 3px solid var(--fluent-blue); font-size: 0.9rem; }
        .prob-char-display { font-weight: bold; font-family: monospace; font-size: 1.1em; min-width: 30px; text-align: center; padding: 2px 6px; border: 1px solid var(--color-border); border-radius: var(--tile-border-radius); background-color: var(--color-background); }
        .prob-bar-container { flex-grow: 1; height: 12px; background-color: var(--color-border-light); border-radius: 6px; margin: 0 10px; overflow: hidden; }
        .prob-bar { height: 100%; background-color: var(--fluent-blue); width: 0%; transition: width 0.5s ease-out; }
        .prob-value { color: var(--color-text-secondary); min-width: 45px; text-align: right; font-size: 0.9em; }

        .optimization-info { background-color: var(--color-background); padding: 12px; border-radius: var(--button-border-radius); margin-bottom: 15px; border-left: 3px solid var(--color-correct); font-size: 0.85rem; color: var(--color-text-secondary); }
        .loading { opacity: 0.6; pointer-events: none; }

        .tile-context-menu {
            background-color: var(--color-surface);
            border: 1px solid var(--color-border);
            border-radius: var(--button-border-radius);
            box-shadow: var(--shadow-m);
            padding: 8px;
            display: flex;
            gap: 6px;
            z-index: 1000;
            position: absolute;
            transform: scale(0.8) translateY(-10px);
            opacity: 0;
            pointer-events: none;
            transition: transform 0.2s cubic-bezier(0.175, 0.885, 0.32, 1.275), opacity 0.2s ease-out;
        }
        .tile-context-menu.visible {
            transform: scale(1) translateY(0);
            opacity: 1;
            pointer-events: auto;
        }


        .context-menu-btn {
            width: 38px;
            height: 38px;
            border-radius: 50%;
            border: 2px solid transparent;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.2rem;
            font-weight: bold;
            transition: all 0.2s ease;
            color: var(--color-key-feedback-text);
        }

        .context-menu-btn:hover:not(:disabled) {
            transform: scale(1.1);
            border-color: var(--fluent-blue);
        }

        .context-menu-btn.correct-btn { background-color: var(--color-correct); }
        .context-menu-btn.present-btn { background-color: var(--color-present); }
        .context-menu-btn.empty-btn { background-color: var(--color-absent); }
        .context-menu-btn.delete-btn {
            background-color: var(--color-border-light);
            color: var(--color-text-secondary);
            font-size: 1.3rem;
        }
        .context-menu-btn.delete-btn:hover:not(:disabled) {
            background-color: var(--color-danger);
            color: white;
            border-color: transparent;
        }

        .context-menu-btn:disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }
        .context-menu-btn.delete-btn:disabled {
             background-color: var(--color-border-light);
             color: var(--color-text-secondary);
             opacity: 0.5;
        }


        @media (max-width: 768px) {
            .container { flex-direction: column; padding: 10px; gap: 20px; }
            .constraint-tile { width: 40px; height: 40px; font-size: 1rem; }
            .keyboard { grid-template-columns: repeat(auto-fill, minmax(40px, 1fr)); }
            .theme-toggle { top: 10px; right: 10px; width: 40px; height: 40px; font-size: 1.2rem; }
             .tile-context-menu { gap: 4px; padding: 6px;}
            .context-menu-btn { width: 34px; height: 34px; font-size: 1rem; }
        }
         .input-group.import-group { margin-top: 20px; }
        .import-input {
            width: calc(100% - 24px);
            padding: 10px;
            border: 2px solid var(--color-border);
            border-radius: var(--button-border-radius);
            font-size: 0.9rem;
            background-color: var(--color-background);
            color: var(--color-text);
            transition: border-color 0.3s ease;
            margin-bottom: 10px;
        }
        .import-input:focus {
            outline: none;
            border-color: var(--fluent-blue);
        }
        .import-btn {
            width: 100%;
        }
    </style>
</head>
<body>
    <button class="theme-toggle" id="themeToggle">☀️</button>

    <header>
        <h1 class="header-title">Sumzle Solver (WASM)</h1>
    </header>

    <div class="container">
        <div class="left-panel">
            <div class="section-title">🎯 求解配置</div>

            <div class="help-section">
                <div class="help-title">使用说明</div>
                <div class="help-text">
                    1. 设置表达式长度。<br>
                    2. 点击格子选择位置，再点击下方字符输入。再次点击已选中的格子，会弹出菜单，可更改格子颜色标记或删除字符。<br>
                          • <span style="color:var(--color-correct); font-weight:bold;">绿色</span>: 字符和位置均正确。<br>
                          • <span style="color:var(--color-present); font-weight:bold;">黄色</span>: 字符存在，但位置错误。<br>
                          • <span style="color:var(--color-absent); font-weight:bold;">灰色</span>: (若格子有字符) 此字符不在此格。这有助于确定字符在解中的精确数量。若某字符所有实例均为灰色（且无绿色/黄色），则该字符不应在答案中。<br>
                    3. 可添加多行猜测作为约束。 <br>
                    4. 点击开始求解。<br>
                </div>
            </div>

             <div class="input-group import-group">
                <label class="input-label" for="importGameStateInput">导入游戏局面码 (Sumzle -> Solver):</label>
                <textarea id="importGameStateInput" class="import-input" rows="2" placeholder="粘贴从 Sumzle 游戏复制的局面码..."></textarea>
                <button class="btn btn-secondary import-btn" id="importGameStateBtn">📥 导入局面</button>
            </div>

            <div class="optimization-info">
                <strong>🚀 优化特性:</strong> 智能剪枝 • 等号左边操作数≤30 • 支持阶乘 • 优先级搜索 • 修复等号右边限制 • 多行约束 • 约束预处理 • `[]`内仅`a/b` • <span style="color:var(--fluent-blue); font-weight:bold;">WebAssembly 加速</span>
            </div>

            <div class="input-group">
                <label class="input-label" for="lengthInput">表达式长度：</label>
                <input type="number" id="lengthInput" class="length-input" min="3" max="15" value="6" />
            </div>

            <div class="input-group">
                <label class="input-label">约束条件（格子）：</label>
                <div class="constraint-board-wrapper">
                    <div class="constraint-board" id="constraintBoard"></div>
                </div>
                <div class="constraint-explanation">
                    单击格子选中。再次单击选中格子，弹出菜单修改颜色或删除。
                </div>
            </div>

            <div class="input-group">
                <label class="input-label">字符输入（键盘）：</label>
                <div class="keyboard" id="keyboard"></div>
                <div class="keyboard-explanation">
                    点击字符输入至上方选中格子。
                </div>
            </div>

            <div class="control-buttons">
                <button class="btn btn-primary" id="solveBtn">🚀 开始求解</button>
                <button class="btn btn-secondary" id="clearBtn">🧹 清空</button>
                <button class="btn btn-secondary" id="addGuessRowBtn">➕ 添加猜测行</button>
                <button class="btn btn-danger" id="stopBtn" style="display: none;">⏹️ 停止</button>
            </div>

            <div class="progress-container" id="progressContainer">
                <div class="progress-bar">
                    <div class="progress-fill" id="progressFill"></div>
                </div>
                <div class="progress-text" id="progressText">准备中...</div>
            </div>

            <div class="error-message" id="errorMessage"></div>
        </div>

        <div class="right-panel">
            <div class="section-title">📊 求解结果</div>

            <div class="stats" id="stats">
                <div class="stat-card">
                    <div class="stat-number" id="foundCount">0</div>
                    <div class="stat-label">找到解</div>
                </div>
                <div class="stat-card">
                    <div class="stat-number" id="searchedCount">0</div>
                    <div class="stat-label">已搜索</div>
                </div>
                <div class="stat-card">
                    <div class="stat-number" id="timeElapsed">0.0s</div>
                    <div class="stat-label">用时</div>
                </div>
                <div class="stat-card">
                    <div class="stat-number" id="searchSpeed">0</div>
                    <div class="stat-label">搜索速度/秒</div>
                </div>
            </div>

            <div class="section-title" style="margin-top: 30px;">🗝️ 字符概率</div>
            <div class="results-container" id="charProbContainer" style="max-height: 250px; margin-top: 10px;">
                <div style="text-align: center; color: var(--color-text-secondary); padding: 20px;">
                    求解后显示概率
                </div>
            </div>

            <div class="section-title" style="margin-top: 30px;">⭐ 推荐解</div>
            <div class="results-container" id="recommendedResultContainer" style="max-height: 100px; margin-bottom:20px; padding: 10px;">
                <div style="text-align: center; color: var(--color-text-secondary); padding: 20px;">
                    求解后显示推荐
                </div>
            </div>

            <div class="section-title" style="margin-top: 30px;">📜 结果列表</div>
            <div class="results-container" id="resultsContainer">
                <div style="text-align: center; color: var(--color-text-secondary); padding: 40px;">
                    等待求解开始...
                </div>
            </div>
        </div>
    </div>

    <div id="tileContextMenu" class="tile-context-menu" style="display: none;">
        <button data-state="correct" class="context-menu-btn correct-btn" title="Correct (Green)">✓</button>
        <button data-state="present" class="context-menu-btn present-btn" title="Present (Yellow)">●</button>
        <button data-state="empty" class="context-menu-btn empty-btn" title="Absent in this spot (Grey)">✕</button>
        <button data-action="delete" class="context-menu-btn delete-btn" title="Delete Character">🗑️</button>
    </div>

    <!-- Import the WebAssembly module -->
    <script type="module">
        import init, { SumzleSolver } from './dist/sumzle_solver.js';

        // Global variable to hold the initialized WebAssembly module
        let wasmModule = null;

        // Initialize the WebAssembly module
        async function initWasm() {
            await init();
            console.log("WebAssembly module initialized");

            // Store the SumzleSolver constructor in the global variable
            wasmModule = { SumzleSolver };

            // Start the application after WebAssembly is loaded
            const app = new OptimizedSumzleSolver();
        }

        // Call the initialization function
        initWasm().catch(e => console.error("Error initializing WebAssembly module:", e));

        class OptimizedSumzleSolver {
            constructor() {
                this.length = 6;
                this.guessRowsData = [];
                this.isRunning = false;
                this.shouldStop = false;
                this.results = [];
                this.searchedCount = 0;
                this.startTime = 0;
                this.selectedTile = null; 
                this.globalKnowledge = {};
                this.charProbabilitiesData = [];
                this.lastUIUpdate = 0;

                this.validChars = "0123456789+-*/%^=()![]>A";
                this.displayCharsMap = { '*': '×', '/': '÷' };
                this.actualCharsMap = { '×': '*', '÷': '/' };

                this.maxOperandValue = 30; 
                this.searchPruningEnabled = true; 

                // Initialize the WebAssembly solver
                if (wasmModule) {
                    this.wasmSolver = new wasmModule.SumzleSolver(this.length, this.maxOperandValue);
                } else {
                    console.error("WebAssembly module not initialized");
                }

                this.tileContextMenu = document.getElementById('tileContextMenu');
                this.activeContextMenuTile = null;

                this.initializeUI();
                this.updateConstraintBoard();
                this.autoAdvanceFocus = true;
            }

            // UI-related methods from the original file
            initializeUI() {
                // Same as in the original file
                const themeToggle = document.getElementById('themeToggle');
                themeToggle.addEventListener('click', () => this.toggleTheme());

                const lengthInput = document.getElementById('lengthInput');
                lengthInput.addEventListener('change', (e) => {
                    this.hideContextMenu();
                    const newLength = Math.max(3, Math.min(15, parseInt(e.target.value) || this.length));
                    e.target.value = newLength;

                    if (this.selectedTile) { 
                        if (this.selectedTile.colIndex >= newLength) {
                             if (this.selectedTile.element) this.selectedTile.element.style.outline = '';
                             this.selectedTile = null;
                        }
                    }

                    if (newLength === this.length) return;
                    this.length = newLength;

                    // Update the WebAssembly solver with the new length
                    if (wasmModule) {
                        this.wasmSolver = new wasmModule.SumzleSolver(this.length, this.maxOperandValue);
                    } else {
                        console.error("WebAssembly module not initialized");
                    }

                    this.guessRowsData.forEach((row, rowIndex) => {
                        const newRowArray = Array(this.length).fill(null).map((_, colIndex) => {
                            if (colIndex < row.length && row[colIndex]) {
                                return { ...row[colIndex] };
                            }
                            return { char: '', state: 'empty' };
                        });
                        this.guessRowsData[rowIndex] = newRowArray;
                    });

                    this.updateConstraintBoard(); 
                });

                document.getElementById('solveBtn').addEventListener('click', () => this.solve());
                document.getElementById('clearBtn').addEventListener('click', () => this.clear());
                document.getElementById('stopBtn').addEventListener('click', () => this.stop());
                document.getElementById('addGuessRowBtn').addEventListener('click', () => {
                    this.hideContextMenu();
                    this.addGuessRow();
                });
                 document.getElementById('importGameStateBtn').addEventListener('click', () => this.importGameState());


                this.createKeyboard();

                this.tileContextMenu.querySelectorAll('.context-menu-btn').forEach(btn => {
                    btn.addEventListener('click', (event) => {
                        event.stopPropagation();
                        const action = btn.dataset.action;
                        const state = btn.dataset.state;
                        this.handleContextMenuAction(action, state);
                    });
                });

                document.addEventListener('click', (event) => {
                    if (this.tileContextMenu.style.display === 'none' && !this.tileContextMenu.classList.contains('visible')) return;

                    const clickedOnSelectedTile = this.selectedTile && event.target.closest('.constraint-tile') === this.selectedTile.element;
                    const clickedOnMenu = event.target.closest('.tile-context-menu');

                    if (!clickedOnSelectedTile && !clickedOnMenu) {
                        this.hideContextMenu();
                    }
                }, true);

                document.addEventListener('keydown', (event) => {
                    if (event.key === 'Escape' && (this.tileContextMenu.style.display !== 'none' || this.tileContextMenu.classList.contains('visible'))) {
                        this.hideContextMenu();
                    }
                });
            }

            showContextMenu(tileElement, rowIndex, colIndex) {
                const tileData = this.guessRowsData[rowIndex][colIndex];
                const hasChar = !!tileData.char;

                this.tileContextMenu.querySelector('[data-state="correct"]').disabled = !hasChar;
                this.tileContextMenu.querySelector('[data-state="present"]').disabled = !hasChar;
                this.tileContextMenu.querySelector('[data-state="empty"]').disabled = !hasChar;
                this.tileContextMenu.querySelector('[data-action="delete"]').disabled = !hasChar;

                const tileRect = tileElement.getBoundingClientRect();
                const menuHeight = this.tileContextMenu.offsetHeight || 50;
                const menuWidth = this.tileContextMenu.offsetWidth || 180;

                let top = tileRect.bottom + window.scrollY + 8;
                let left = tileRect.left + window.scrollX + (tileRect.width / 2) - (menuWidth / 2);

                if (top + menuHeight > window.innerHeight + window.scrollY - 10) {
                    top = tileRect.top + window.scrollY - menuHeight - 8;
                }
                if (top < window.scrollY + 5) {
                    top = window.scrollY + 5;
                }
                if (left + menuWidth > window.innerWidth + window.scrollX - 5) {
                    left = window.innerWidth + window.scrollX - menuWidth - 5;
                }
                if (left < window.scrollX + 5) {
                    left = window.scrollX + 5;
                }

                this.tileContextMenu.style.top = `${top}px`;
                this.tileContextMenu.style.left = `${left}px`;
                this.tileContextMenu.style.display = 'flex';
                requestAnimationFrame(() => {
                    this.tileContextMenu.classList.add('visible');
                });
                this.activeContextMenuTile = { element: tileElement, rowIndex, colIndex };
            }

            hideContextMenu() {
                 this.tileContextMenu.classList.remove('visible');
                 setTimeout(() => {
                    if (!this.tileContextMenu.classList.contains('visible')) {
                         this.tileContextMenu.style.display = 'none';
                    }
                 }, 200);
                this.activeContextMenuTile = null;
            }

            handleContextMenuAction(action, stateValue) {
                if (!this.activeContextMenuTile) return;

                const { element, rowIndex, colIndex } = this.activeContextMenuTile;
                const tileData = this.guessRowsData[rowIndex][colIndex];

                if (action === 'delete') {
                    tileData.char = '';
                    tileData.state = 'empty';
                } else if (stateValue) {
                    tileData.state = stateValue;
                }

                this.updateTileAppearance(element, tileData);
                this.hideContextMenu();
            }


            addGuessRow() {
                this.hideContextMenu();
                if (this.guessRowsData.length >= 10) {
                    this.showError("最多只能添加10行猜测。");
                    return;
                }
                this.guessRowsData.push(this.createEmptyRow());
                this.updateConstraintBoard();
            }

            createEmptyRow() {
                return Array(this.length).fill().map(() => ({ char: '', state: 'empty' }));
            }

            createKeyboard() {
                const keyboard = document.getElementById('keyboard');
                keyboard.innerHTML = '';
                const chars = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '-', '×', '÷', '%', '^', '=', '>', '!', 'A', '(', ')', '[', ']', '⌫'];

                chars.forEach(char => {
                    const key = document.createElement('div');
                    key.className = 'key';
                    key.textContent = char;
                    const actualChar = this.actualCharsMap[char] || char;
                    key.dataset.char = actualChar;
                    key.addEventListener('click', () => this.handleKeyPress(char, actualChar));
                    keyboard.appendChild(key);
                });
            }

            handleKeyPress(displayChar, actualChar) {
                if (!this.selectedTile || !this.selectedTile.element) return;
                this.hideContextMenu();
                const { rowIndex, colIndex } = this.selectedTile;
                const tileData = this.guessRowsData[rowIndex][colIndex];
                const originalTileElement = this.selectedTile.element;

                if (displayChar === '⌫') {
                    const charExisted = !!tileData.char;
                    tileData.char = '';
                    if (charExisted) {
                        tileData.state = 'empty';
                    }
                } else {
                    tileData.char = actualChar;
                     if (this.autoAdvanceFocus && colIndex < this.length - 1) {
                        this.selectNextTile(rowIndex, colIndex);
                    }
                }
                this.updateTileAppearance(originalTileElement, tileData);
            }

            selectNextTile(currentRowIndex, currentColIndex) {
                const nextColIndex = currentColIndex + 1;
                if (nextColIndex < this.length) {
                    const boardElement = document.getElementById('constraintBoard');
                    const nextTileElement = boardElement.querySelector(`.constraint-tile[data-row-index="${currentRowIndex}"][data-col-index="${nextColIndex}"]`);
                    if (nextTileElement) {
                        if (this.selectedTile && this.selectedTile.element) {
                            this.selectedTile.element.style.outline = '';
                        }
                        this.selectedTile = { element: nextTileElement, rowIndex: currentRowIndex, colIndex: nextColIndex };
                        nextTileElement.style.outline = '3px solid var(--fluent-blue)';
                         if (this.tileContextMenu.style.display !== 'none' || this.tileContextMenu.classList.contains('visible')) {
                            this.hideContextMenu();
                        }
                    }
                }
            }

            updateTileAppearance(tileElement, tileData) {
                tileElement.textContent = tileData.char ? (this.displayCharsMap[tileData.char] || tileData.char) : '';
                tileElement.className = 'constraint-tile';
                if (tileData.state !== 'empty' && tileData.char) {
                    tileElement.classList.add(tileData.state);
                } else if (tileData.state === 'empty' && tileData.char) {
                     tileElement.classList.add('empty');
                } else {
                    tileElement.classList.add('empty');
                }
            }


            updateConstraintBoard() {
                const boardElement = document.getElementById('constraintBoard');
                boardElement.innerHTML = '';

                if (this.guessRowsData.length === 0) {
                    this.guessRowsData.push(this.createEmptyRow());
                }

                this.guessRowsData.forEach((rowData, rIndex) => {
                    const rowDiv = document.createElement('div');
                    rowDiv.className = 'constraint-row';
                    rowDiv.style.gridTemplateColumns = `repeat(${this.length}, 1fr)`;

                    rowData.forEach((tileData, cIndex) => {
                        const tileElement = document.createElement('div');
                        tileElement.dataset.rowIndex = rIndex;
                        tileElement.dataset.colIndex = cIndex;
                        this.updateTileAppearance(tileElement, tileData);

                        tileElement.addEventListener('click', (event) => {
                            event.stopPropagation();
                            const clickedRIndex = parseInt(tileElement.dataset.rowIndex);
                            const clickedCIndex = parseInt(tileElement.dataset.colIndex);

                            if (this.selectedTile &&
                                this.selectedTile.rowIndex === clickedRIndex &&
                                this.selectedTile.colIndex === clickedCIndex) {
                                if ((this.tileContextMenu.style.display !== 'none' || this.tileContextMenu.classList.contains('visible')) &&
                                    this.activeContextMenuTile &&
                                    this.activeContextMenuTile.element === tileElement) {
                                    this.hideContextMenu();
                                } else {
                                    this.showContextMenu(tileElement, clickedRIndex, clickedCIndex);
                                }
                            } else {
                                this.hideContextMenu();
                                if (this.selectedTile && this.selectedTile.element) {
                                    this.selectedTile.element.style.outline = '';
                                }
                                this.selectedTile = { element: tileElement, rowIndex: clickedRIndex, colIndex: clickedCIndex };
                                tileElement.style.outline = '3px solid var(--fluent-blue)';
                            }
                        });

                        rowDiv.appendChild(tileElement);
                    });
                    boardElement.appendChild(rowDiv);
                });

                if (this.selectedTile && this.selectedTile.element) {
                    const {rowIndex, colIndex} = this.selectedTile;
                    if(rowIndex < this.guessRowsData.length && colIndex < this.length) {
                         const currentSelectedElem = boardElement.children[rowIndex]?.children[colIndex];
                         if(currentSelectedElem) {
                            currentSelectedElem.style.outline = '3px solid var(--fluent-blue)';
                            this.selectedTile.element = currentSelectedElem;
                         } else {
                            this.selectedTile = null;
                         }
                    } else {
                        this.selectedTile = null;
                    }
                }
            }

            preprocessConstraints() {
                this.globalKnowledge = {
                    fixedChars: Array(this.length).fill(null),
                    cannotBeAt: Array(this.length).fill(null).map(() => new Set()),
                    mustAppearMinCount: new Map(),
                    mustAppearExactCount: new Map(),
                    globallyForbidden: new Set()
                };
                const gk = this.globalKnowledge;

                for (let r = 0; r < this.guessRowsData.length; r++) {
                    const row = this.guessRowsData[r];
                    for (let c = 0; c < this.length; c++) {
                        if (c >= row.length) continue;
                        const tile = row[c];
                        if (!tile.char) continue;
                                    if (tile.state === 'correct') {
                            if (gk.fixedChars[c] && gk.fixedChars[c] !== tile.char) {
                                this.showError(`冲突: 位置 ${c + 1} 同时固定为 ${gk.fixedChars[c]} 和 ${tile.char}.`); return false;
                            }
                            gk.fixedChars[c] = tile.char;
                            this.validChars.split('').forEach(vc => {
                                if (vc !== tile.char) gk.cannotBeAt[c].add(vc);
                            });
                        } else if (tile.state === 'present') {
                            gk.cannotBeAt[c].add(tile.char);
                        } else if (tile.state === 'empty' && tile.char) {
                            gk.cannotBeAt[c].add(tile.char);
                        }
                    }
                }

                const allCharsInGuesses = new Set();
                this.guessRowsData.forEach(row => row.forEach(tile => { if(tile.char) allCharsInGuesses.add(tile.char)}));

                for (const char of allCharsInGuesses) {
                    let minRequiredOverall = 0;
                    let derivedExactCount = undefined;

                    for (const row of this.guessRowsData) {
                        if (!row.some(tile => tile.char === char)) continue;

                        let greenInRow = 0;
                        let yellowInRow = 0;
                        row.forEach((tile) => {
                            if (tile.char === char) {
                                if (tile.state === 'correct') greenInRow++;
                                else if (tile.state === 'present') yellowInRow++;
                            }
                        });

                        const minRequiredThisRow = greenInRow + yellowInRow;
                        minRequiredOverall = Math.max(minRequiredOverall, minRequiredThisRow);

                        if (row.some(tile => tile.char === char && tile.state === 'empty')) {
                            const exactCountThisRow = greenInRow + yellowInRow;
                            if (derivedExactCount === undefined) {
                                derivedExactCount = exactCountThisRow;
                            } else if (derivedExactCount !== exactCountThisRow) {
                                this.showError(`冲突: 字符 '${char}' 在不同猜测行中推断出不同的精确数量 (${derivedExactCount} vs ${exactCountThisRow}).`);
                                return false;
                            }
                        }
                    }

                    gk.mustAppearMinCount.set(char, minRequiredOverall);

                    if (derivedExactCount !== undefined) {
                        if (derivedExactCount < minRequiredOverall) {
                            this.showError(`冲突: 字符 '${char}' 的精确数量 (${derivedExactCount}) 小于其最小需求数量 (${minRequiredOverall}).`);
                            return false;
                        }
                        gk.mustAppearExactCount.set(char, derivedExactCount);
                        if (derivedExactCount === 0 && minRequiredOverall === 0) {
                            gk.globallyForbidden.add(char);
                        }
                    }
                }

                for (let i = 0; i < this.length; i++) {
                    const fixed = gk.fixedChars[i];
                    if (fixed) {
                        if (gk.globallyForbidden.has(fixed)) {
                            this.showError(`冲突: 字符 '${fixed}' 在位置 ${i + 1} 固定但同时被全局禁用.`); return false;
                        }
                        if (gk.cannotBeAt[i].has(fixed)) {
                           this.showError(`冲突: 字符 '${fixed}' 在位置 ${i + 1} 固定但又标记为不能在该位置.`); return false;
                        }
                        gk.mustAppearMinCount.set(fixed, Math.max(gk.mustAppearMinCount.get(fixed) || 0, 1));
                        if (gk.mustAppearExactCount.has(fixed)) {
                             if (gk.mustAppearExactCount.get(fixed) < (gk.mustAppearMinCount.get(fixed) || 0) ) {
                                 this.showError(`冲突: 字符 '${fixed}' 的精确数量 ${gk.mustAppearExactCount.get(fixed)} 小于其最小固定要求.`); return false;
                             }
                        }
                    }
                }
                for(const [char, exact] of gk.mustAppearExactCount) {
                    const min = gk.mustAppearMinCount.get(char) || 0;
                    if (exact < min) {
                         this.showError(`冲突: 字符 '${char}' 的精确数量 (${exact}) 小于其最小需求 (${min}).`); return false;
                    }
                }
                for (const char of gk.globallyForbidden) {
                    if ((gk.mustAppearMinCount.get(char) || 0) > 0) {
                         this.showError(`冲突: 字符 '${char}' 被全局禁用但又要求至少出现.`); return false;
                    }
                    if (gk.mustAppearExactCount.has(char) && gk.mustAppearExactCount.get(char) > 0) {
                         this.showError(`冲突: 字符 '${char}' 被全局禁用但又要求精确出现.`); return false;
                    }
                }
                return true;
            }

            // Methods that use the WebAssembly module
            isValidSolution(expression) {
                return this.wasmSolver.is_valid_solution(expression);
            }

            evaluateExpression(expr) {
                const result = this.wasmSolver.evaluate_expression(expr);
                return result !== null ? result : null;
            }

            // The search algorithm will be implemented in WebAssembly
            async solve() {
                this.hideContextMenu();
                if (this.isRunning) return;

                if (!this.preprocessConstraints()) {
                    return;
                }

                this.isRunning = true;
                this.shouldStop = false;
                this.results = [];
                this.searchedCount = 0;
                this.startTime = Date.now();
                this.lastUIUpdate = Date.now();
                this.charProbabilitiesData = [];

                document.getElementById('solveBtn').classList.add('loading');
                document.getElementById('solveBtn').disabled = true;
                document.getElementById('clearBtn').classList.add('loading');
                document.getElementById('clearBtn').disabled = true;
                document.getElementById('addGuessRowBtn').classList.add('loading');
                document.getElementById('addGuessRowBtn').disabled = true;

                document.getElementById('solveBtn').style.display = 'none';
                document.getElementById('stopBtn').style.display = 'block';
                document.getElementById('progressContainer').style.display = 'block';
                document.getElementById('errorMessage').style.display = 'none';

                this.updateResults(); 
                this.updateCharProbabilitiesDisplay(); 
                document.getElementById('recommendedResultContainer').innerHTML = 
                    '<div style="text-align: center; color: var(--color-text-secondary); padding: 20px;">求解中...</div>';

                try {
                    // Call the WebAssembly search function
                    // For now, we'll use a placeholder implementation
                    const constraints = JSON.stringify({ rows: this.guessRowsData });
                    const results = this.wasmSolver.search(constraints);

                    // Process the results
                    this.results = results;
                    this.searchedCount = 1000; // Placeholder
                } catch (error) {
                    this.showError('求解过程中出现错误: ' + error.message);
                } finally {
                    this.isRunning = false;
                    document.getElementById('solveBtn').classList.remove('loading');
                    document.getElementById('solveBtn').disabled = false;
                    document.getElementById('clearBtn').classList.remove('loading');
                    document.getElementById('clearBtn').disabled = false;
                    document.getElementById('addGuessRowBtn').classList.remove('loading');
                    document.getElementById('addGuessRowBtn').disabled = false;

                    document.getElementById('solveBtn').style.display = 'block';
                    document.getElementById('stopBtn').style.display = 'none';

                    this.updateStats();
                    this.calculateAndDisplayProbabilities(); 
                    this.updateResultsWithRecommendation(); 
                    if (this.shouldStop) {
                        document.getElementById('progressText').textContent = `已停止 - 搜索: ${this.searchedCount.toLocaleString()} - 找到: ${this.results.length}`;
                    } else {
                        document.getElementById('progressText').textContent = `完成 - 搜索: ${this.searchedCount.toLocaleString()} - 找到: ${this.results.length}`;
                    }
                    if (this.results.length === 0 && !this.shouldStop) {
                        document.getElementById('progressContainer').style.display = 'none';
                    }
                }
            }

            isDigit(c) { return c && c >= '0' && c <= '9'; }
            isBinaryOperator(c) { return c && ['+', '-', '*', '/', '%', '^', 'A'].includes(c); }
            isUnaryPostOperator(c) { return c === '!'; }
            isOperator(c) { return this.isBinaryOperator(c) || this.isUnaryPostOperator(c); }
            isOpenBracket(c) { return c && (c === '(' || c === '['); }
            isCloseBracket(c) { return c && (c === ')' || c === ']'); }
            isMainOperator(c) { return c && (c === '=' || c === '>'); }
            getMatchingBracket(openBracket) { return openBracket === '(' ? ')' : (openBracket === '[' ? ']' : null); }

            canPlaceChar(char, index, currentExpressionArray, mainOpSoFar, currentExpressionCounts, floorContext) {
                const gk = this.globalKnowledge;

                if (gk.globallyForbidden.has(char)) return false;
                if (gk.fixedChars[index] && gk.fixedChars[index] !== char) return false;
                if (gk.cannotBeAt[index].has(char)) return false;

                const currentCountOfChar = currentExpressionCounts.get(char) || 0;
                const exactCountForChar = gk.mustAppearExactCount.get(char);
                if (exactCountForChar !== undefined && currentCountOfChar >= exactCountForChar) {
                    return false;
                }

                if (floorContext.inFloor) {
                    if (char === '[') return false;
                    if (this.isOperator(char) && char !== '/') return false;
                    if (this.isMainOperator(char)) return false;
                    if (char === '(') return false;
                    if (char === 'A' || char === '!') return false;

                    if (char === '/') {
                        if (floorContext.hasSlashInCurrentFloor) return false;
                        const prevActualChar = index > 0 ? currentExpressionArray[index-1] : null;
                        if (!this.isDigit(prevActualChar) || index === 0) return false;
                    } else if (char === ']') {
                        const prevActualChar = index > 0 ? currentExpressionArray[index-1] : null;
                        if (!this.isDigit(prevActualChar)) return false;
                        if (!floorContext.hasSlashInCurrentFloor) return false;
                    } else if (!this.isDigit(char)) {
                        return false;
                    }
                }

                if (char === '[' && floorContext.inFloor) return false;
                if (char === ']' && !floorContext.inFloor) return false;
                if (char === '[') {
                     if (index >= this.length - 3) return false;
                }


                if (this.isDigit(char) && mainOpSoFar !== '=') {
                    let tempNumStr = char;
                    let k = index - 1;
                    while (k >= 0 && this.isDigit(currentExpressionArray[k])) {
                        tempNumStr = currentExpressionArray[k] + tempNumStr;
                        k--;
                    }

                    if (tempNumStr.length > 1 && tempNumStr.startsWith('0')) {
                        return false;
                    }

                    const charBeforeNumberSequence = (k >= 0) ? currentExpressionArray[k] : null;
                    if (charBeforeNumberSequence === null ||
                        this.isOperator(charBeforeNumberSequence) ||
                        this.isOpenBracket(charBeforeNumberSequence) ||
                        this.isMainOperator(charBeforeNumberSequence)) {
                            if (parseInt(tempNumStr, 10) > this.maxOperandValue) {
                                return false;
                            }
                    }
                }

                const prevChar = index > 0 ? currentExpressionArray[index - 1] : null;

                if (index === 0) {
                    if (this.isBinaryOperator(char) || this.isCloseBracket(char) || this.isMainOperator(char) || this.isUnaryPostOperator(char)) return false;
                }

                if (prevChar) {
                    if (this.isDigit(prevChar)) {
                        if (this.isOpenBracket(char) && char !== '[') return false;
                        if (char === '[' && floorContext.inFloor) return false;
                    } else if (this.isOperator(prevChar)) {
                        if (this.isBinaryOperator(char) && !(prevChar === 'A' && (this.isOpenBracket(char) || this.isDigit(char))) && !this.isUnaryPostOperator(prevChar)) return false;
                        if (this.isCloseBracket(char)) return false;
                        if (this.isMainOperator(char) && !this.isUnaryPostOperator(prevChar)) return false;
                        if (this.isUnaryPostOperator(prevChar) && (this.isDigit(char) || this.isOpenBracket(char))) return false;
                    } else if (this.isOpenBracket(prevChar)) {
                        if (prevChar === '[' && char === '(') return false;
                        if (this.isBinaryOperator(char)) return false;
                        if (this.isCloseBracket(char) && char !== this.getMatchingBracket(prevChar)) return false;
                        if (this.isMainOperator(char)) return false;
                        if (this.isUnaryPostOperator(char)) return false;
                    } else if (this.isCloseBracket(prevChar)) {
                        if (this.isDigit(char)) return false;
                        if (this.isOpenBracket(char)) return false;
                    } else if (this.isMainOperator(prevChar)) {
                         if (prevChar === '=') {
                             if (!this.isDigit(char) && char !== '-') return false;
                         } else {
                             if (this.isMainOperator(char)) return false;
                             if (this.isCloseBracket(char)) return false;
                         }
                    }
                }

                if (mainOpSoFar === '=') {
                    if (!this.isDigit(char) && char !== '-') return false;
                    if (char === '-' && (prevChar !== '=' || index >= this.length -1 || !this.isDigit(currentExpressionArray[index+1]))) {
                        // Allow '-' only right after '=', and if not at the very end, and followed by a digit
                        // This is a simplification. True parsing of negative numbers is complex.
                        // For this check, if char is '-', it implies potential negative number.
                        // If prevChar is not '=', then '-' is an operator, not a sign.
                        if (prevChar !== '=') { /* do nothing, standard operator rules apply */ }
                        else if (index >= this.length -1) return false; // - at the very end like ...=-
                        // The char after '-' must be a digit for a negative number. This needs lookahead or different parsing.
                        // For now, this rule is a bit loose.
                    }
                }


                if (index === this.length - 1) {
                    if (this.isBinaryOperator(char) || this.isOpenBracket(char) || this.isMainOperator(char)) return false;
                }

                let tempExpressionForBracketCheck = currentExpressionArray.slice(0, index);
                tempExpressionForBracketCheck.push(char);
                let openParenDepth = 0;
                let openSquareDepth = 0;
                const openBracketsStack = [];

                for (let i = 0; i < tempExpressionForBracketCheck.length; i++) {
                    const c = tempExpressionForBracketCheck[i];
                    if (!c) continue;
                    if (c === '(') { openParenDepth++; openBracketsStack.push(c); }
                    else if (c === '[') { openSquareDepth++; openBracketsStack.push(c); }
                    else if (c === ')') {
                        openParenDepth--;
                        if (openParenDepth < 0 || openBracketsStack.pop() !== '(') return false;
                    } else if (c === ']') {
                        openSquareDepth--;
                         if (openSquareDepth < 0 || openBracketsStack.pop() !== '[') return false;
                    }
                }
                if (index === this.length - 1 && (openParenDepth !== 0 || openSquareDepth !== 0)) return false;

                if (this.isMainOperator(char)) {
                    if (mainOpSoFar && mainOpSoFar !== char && !(mainOpSoFar === '>' && char === '=')) return false;
                    if (mainOpSoFar === char && char === '=') return false;
                    if (index === 0 || index >= this.length - 1) return false;
                }

                if (char === 'A') {
                    if (!prevChar || (!this.isDigit(prevChar) && !this.isCloseBracket(prevChar))) return false;
                }
                if (prevChar === 'A') {
                    if (!this.isDigit(char) && !this.isOpenBracket(char)) return false;
                }

                if (char === '!') {
                    if (!prevChar) return false;
                    if (this.isDigit(prevChar)) {
                        if (prevChar === '0' && this.evaluateExpression("0!") === null) return false;
                    } else if (this.isCloseBracket(prevChar)) {
                        if (prevChar === ']') return false;
                    } else {
                        return false;
                    }
                }

                return true;
            }

            async _optimizedRecursiveSearch(index, currentExpression, mainOpSoFar, currentExpressionCounts, floorContext) {
                if (this.shouldStop) return;
                const gk = this.globalKnowledge;

                if (index === this.length) {
                    this.searchedCount++;
                    if (!mainOpSoFar) return;
                    if (!this.checkBrackets(currentExpression.join(''))) return;

                    for (const [char, exactCount] of gk.mustAppearExactCount) {
                        if ((currentExpressionCounts.get(char) || 0) !== exactCount) return;
                    }
                    for (const [char, minCount] of gk.mustAppearMinCount) {
                         if (!gk.mustAppearExactCount.has(char)) {
                            if ((currentExpressionCounts.get(char) || 0) < minCount) return;
                        }
                    }

                    if (this.isValidSolution(currentExpression.join(''))) {
                        this.results.push(currentExpression.join(''));
                        if (this.results.length <= 500) {
                             this.updateResultsWithRecommendation();
                        }
                    }
                    if (this.searchedCount % 20000 === 0 || (Date.now() - this.lastUIUpdate > 100)) {
                        this.updateStats();
                        this.updateProgressWithSearchedCount();
                        if (this.results.length > 500 && this.results.length % 100 === 0) {
                            this.updateResultsWithRecommendation();
                        }
                        this.lastUIUpdate = Date.now();
                        await new Promise(resolve => setTimeout(resolve, 0));
                    }
                    return;
                }

                const fixedCharForThisPosition = gk.fixedChars[index];

                if (fixedCharForThisPosition) {
                    let nextFloorContext = { ...floorContext };
                    if (fixedCharForThisPosition === '[') nextFloorContext = { inFloor: true, hasSlashInCurrentFloor: false };
                    else if (fixedCharForThisPosition === ']' && floorContext.inFloor) nextFloorContext = { inFloor: false, hasSlashInCurrentFloor: false };
                    else if (fixedCharForThisPosition === '/' && floorContext.inFloor) nextFloorContext = { ...floorContext, hasSlashInCurrentFloor: true };

                    if (this.canPlaceChar(fixedCharForThisPosition, index, currentExpression, mainOpSoFar, currentExpressionCounts, floorContext)) {
                        currentExpression[index] = fixedCharForThisPosition;
                        currentExpressionCounts.set(fixedCharForThisPosition, (currentExpressionCounts.get(fixedCharForThisPosition) || 0) + 1);
                        const newMainOp = this.isMainOperator(fixedCharForThisPosition) ? fixedCharForThisPosition : mainOpSoFar;

                        await this._optimizedRecursiveSearch(index + 1, currentExpression, newMainOp, currentExpressionCounts, nextFloorContext);

                        currentExpressionCounts.set(fixedCharForThisPosition, currentExpressionCounts.get(fixedCharForThisPosition) - 1);
                        if(currentExpressionCounts.get(fixedCharForThisPosition) === 0) currentExpressionCounts.delete(fixedCharForThisPosition);

                    }
                } else {
                    const optimizedCharOrder = this.getOptimizedCharOrder(index, currentExpression, mainOpSoFar, floorContext);
                    for (const charToTry of optimizedCharOrder) {
                        if (this.shouldStop) return;

                        let nextFloorContext = { ...floorContext };
                        if (charToTry === '[') nextFloorContext = { inFloor: true, hasSlashInCurrentFloor: false };
                        else if (charToTry === ']' && floorContext.inFloor) nextFloorContext = { inFloor: false, hasSlashInCurrentFloor: false };
                        else if (charToTry === '/' && floorContext.inFloor) nextFloorContext = { ...floorContext, hasSlashInCurrentFloor: true };

                        if (this.canPlaceChar(charToTry, index, currentExpression, mainOpSoFar, currentExpressionCounts, floorContext)) {
                            currentExpression[index] = charToTry;
                            currentExpressionCounts.set(charToTry, (currentExpressionCounts.get(charToTry) || 0) + 1);
                            const newMainOp = this.isMainOperator(charToTry) ? charToTry : mainOpSoFar;

                            await this._optimizedRecursiveSearch(index + 1, currentExpression, newMainOp, currentExpressionCounts, nextFloorContext);

                            currentExpressionCounts.set(charToTry, currentExpressionCounts.get(charToTry) - 1);
                            if(currentExpressionCounts.get(charToTry) === 0) currentExpressionCounts.delete(charToTry);
                        }
                    }
                }
                currentExpression[index] = '';
            }

            getOptimizedCharOrder(index, currentExpression, mainOpSoFar, floorContext) {
                const gk = this.globalKnowledge;
                if (gk.fixedChars[index]) {
                    return [gk.fixedChars[index]];
                }

                let orderedChars = [];
                const prevChar = index > 0 ? currentExpression[index - 1] : null;

                if (floorContext.inFloor) {
                    if (floorContext.hasSlashInCurrentFloor) {
                        orderedChars = ['0','1','2','3','4','5','6','7','8','9', ']'];
                    } else {
                        orderedChars = ['0','1','2','3','4','5','6','7','8','9', '/'];
                    }
                } else if (mainOpSoFar === '=') {
                     if (prevChar === '=') {
                        orderedChars = ['-', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9'];
                    } else {
                        orderedChars = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9'];
                    }
                } else if (index === 0) {
                    orderedChars = ['1', '2', '3', '4', '5', '6', '7', '8', '9', '(', '['];
                } else if (this.isDigit(prevChar)) {
                    orderedChars = ['0','1','2','3','4','5','6','7','8','9',
                                    '+', '-', '*', '/', '%', '^', 'A', '!',
                                    ')', ']', '[',
                                    '=', '>'];
                } else if (this.isBinaryOperator(prevChar) || prevChar === 'A' || (this.isMainOperator(prevChar) && prevChar !== '=')) {
                    orderedChars = ['1','2','3','4','5','6','7','8','9','0', '(', '['];
                } else if (this.isOpenBracket(prevChar)) {
                    orderedChars = ['1','2','3','4','5','6','7','8','9','0', '(', '['];
                } else if (this.isCloseBracket(prevChar) || this.isUnaryPostOperator(prevChar)) {
                    orderedChars = ['+', '-', '*', '/', '%', '^', 'A', '!',
                                    ')', ']', '[',
                                    '=', '>'];
                } else {
                    orderedChars = ['1','2','3','4','5','6','7','8','9','0',
                                    '+','-','*','/', '=',
                                    '(','[', ')',']',
                                    '%','^','!','A','>'];
                }

                if (index === this.length - 1 && !floorContext.inFloor) {
                    const endChars = ['0','1','2','3','4','5','6','7','8','9', ')', ']', '!'];
                    orderedChars = orderedChars.filter(c => endChars.includes(c));
                     if (orderedChars.length === 0 && prevChar) {
                         orderedChars = endChars;
                     } else if (orderedChars.length === 0 && index === 0 && this.length === 1) {
                         orderedChars = ['0','1','2','3','4','5','6','7','8','9'];
                     }
                }

                return [...new Set(orderedChars)].filter(c =>
                    !gk.globallyForbidden.has(c) &&
                    !gk.cannotBeAt[index].has(c)
                );
            }


            async optimizedBruteForceSearch() {
                this.lastUIUpdate = Date.now();
                const initialExpression = Array(this.length).fill('');
                const initialCounts = new Map();
                const initialFloorContext = { inFloor: false, hasSlashInCurrentFloor: false };
                await this._optimizedRecursiveSearch(0, initialExpression, null, initialCounts, initialFloorContext);
            }

            isValidSolution(expression) {
                return this.isValidEquation(expression);
            }
        isInteger(value) {
            return typeof value === 'number' && !isNaN(value) && isFinite(value) && Number.isInteger(value);
        }

        isValidEquation(expression) {
            try {
                if (!this.checkBrackets(expression)) return false;

                let mainOp = null;
                let mainOpIndex = -1;
                let depth = 0;
                let hasMinusOnRHSStart = false;

                for (let i = 0; i < expression.length; i++) {
                    const char = expression[i];
                    if (this.isOpenBracket(char)) depth++;
                    else if (this.isCloseBracket(char)) depth--;
                    else if (depth === 0 && this.isMainOperator(char)) {
                        if (mainOp !== null && mainOp !== char) {
                            if (!(mainOp === '>' && char === '=')) return false;
                        }
                        if (mainOp === null) {
                            mainOp = char;
                            mainOpIndex = i;
                        } else if (char === '=' && mainOp === '>') {
                             mainOp = '>=';
                        } else if (mainOp === '=' && char === '=') {
                            return false;
                        }
                    }
                }

                if (!mainOp || mainOpIndex === 0 || mainOpIndex === expression.length - 1) return false;

                let leftSideString = expression.substring(0, mainOpIndex - (mainOp === '>=' ? 1:0) );
                let rightSideString = expression.substring(mainOpIndex + 1);

                if (mainOp === '=' && rightSideString.startsWith('-')) {
                    hasMinusOnRHSStart = true;
                }


                 if (leftSideString.length === 0 || rightSideString.length === 0) return false;
                 if (hasMinusOnRHSStart && rightSideString.length === 1) return false; // Just "=" or "=-"

                const leftValue = this.evaluateExpression(leftSideString);
                const rightValue = this.evaluateExpression(rightSideString);

                if (leftValue === null || rightValue === null) return false;

                if (!this.isInteger(leftValue) || !this.isInteger(rightValue)) {
                    return false;
                }

                if (mainOp === '=' && !this.isSimpleNumberOrNegativeNumber(rightSideString)) {
                    return false;
                }

                if (mainOp === '=') return leftValue === rightValue;
                if (mainOp === '>' || mainOp === '>=') return leftValue > rightValue;

            } catch (error) { return false; }
            return false;
        }

            isSimpleNumberOrNegativeNumber(expr) {
                return /^-?\d+$/.test(expr.trim());
            }

            checkBrackets(expression) {
                const stack = [];
                for (const char of expression) {
                    if (this.isOpenBracket(char)) stack.push(char);
                    else if (this.isCloseBracket(char)) {
                        if (stack.length === 0) return false;
                        const lastOpen = stack.pop();
                        if (char !== this.getMatchingBracket(lastOpen)) return false;
                    }
                }
                return stack.length === 0;
            }

            evaluateExpression(expr) {
                try {
                    if (expr.length === 0) return null;
                    let processedExpr = expr;

                    let bracketIterations = 0;
                    const maxBracketIterations = 10;
                    while (/\[[^\[\]]+\]/.test(processedExpr) && bracketIterations < maxBracketIterations) {
                        processedExpr = processedExpr.replace(/\[([^\[\]]+)\]/g, (match, innerExpr) => {
                            if (!/^\d+\/\d+$/.test(innerExpr) && !/^\d+$/.test(innerExpr) ) {
                                if( /^\d+$/.test(innerExpr) ) {
                                   const val = this.evaluateExpression(innerExpr);
                                   return (val !== null && typeof val === 'number' && !isNaN(val)) ? Math.floor(val).toString() : 'NaN';
                                }
                                return 'NaN';
                            }
                            if (innerExpr.trim() === '') return 'NaN';
                            const val = this.evaluateExpression(innerExpr);
                            return (val !== null && typeof val === 'number' && !isNaN(val)) ? Math.floor(val).toString() : 'NaN';
                        });
                        bracketIterations++;
                    }
                    if (bracketIterations >= maxBracketIterations && /\[[^\[\]]+\]/.test(processedExpr)) return null;

                    if (processedExpr.includes('NaN')) return null;

                    processedExpr = processedExpr.replace(/(\d+)!/g, (match, numStr) => {
                        const n = parseInt(numStr);
                        if (n === 0) return '1';
                        if (n > 12 || n < 0) return 'NaN';
                        let factorial = 1;
                        for (let i = 2; i <= n; i++) factorial *= i;
                        return factorial.toString();
                    });
                    if (processedExpr.includes('NaN')) return null;

                    processedExpr = processedExpr.replace(/(\d+)A(\d+)/g, (match, mStr, nStr) => {
                        const mVal = parseInt(mStr);
                        const nVal = parseInt(nStr);
                        if (mVal > 10 || nVal > 10 || nVal > mVal || mVal < 0 || nVal < 0) return 'NaN';
                        let result = 1;
                        for (let i = 0; i < nVal; i++) result *= (mVal - i);
                        return result.toString();
                    });
                    if (processedExpr.includes('NaN')) return null;

                    processedExpr = processedExpr.replace(/\^/g, '**');

                    return this.evaluateSimpleExpression(processedExpr);
                } catch (error) {
                    return null;
                }
            }

            evaluateSimpleExpression(expr) {
                try {
                    if (expr.includes('NaN')) return null;
                    if (/\b0[0-9]+\b/.test(expr) && !expr.startsWith("0.")) return null;

                    const invalidPatterns = [
                        /[\+\-\*\/%]{2,}(?!\*)/,
                        /(^[\*\/%])|([\+\-\*\/%]$)(?<!\d-)/,
                        /\(\)/, /\[\]/,
                        /\(\s*\)/, /\[\s*\]/,
                        /\d+\s+\d+/,
                        /\)\(/,
                        /\d\(/,
                        /\)\d/,
                    ];
                    for (const pattern of invalidPatterns) {
                         if (pattern.test(expr.replace(/\*\*/g,"").replace(/(\d)-/g, '$1_minus_'))) return null;
                    }

                    const allowedCharsPattern = /^[0-9.+\-*/%()\s]+$/;
                    if (!allowedCharsPattern.test(expr.replace(/\*\*/g, ""))) return null;

                    const result = Function('"use strict"; return (' + expr + ')')();
                    if (typeof result === 'number' && !isNaN(result) && isFinite(result)) {
                        return result;
                    }
                    return null;
                } catch (error) { return null; }
            }

        updateProgress(percentage) {
            const fill = document.getElementById('progressFill');
            const text = document.getElementById('progressText');

            fill.style.width = `${Math.min(100, percentage)}%`;
            text.textContent = `进度: ${percentage.toFixed(1)}% - 已搜索: ${this.searchedCount.toLocaleString()} - 找到: ${this.results.length}`;
        }

        updateProgressWithSearchedCount() {
            const text = document.getElementById('progressText');
            text.textContent = `已搜索: ${this.searchedCount.toLocaleString()} - 找到: ${this.results.length}`;
            const fill = document.getElementById('progressFill');
            if(this.results.length > 0 && fill.style.width === "0%") {
                fill.style.width = "5%";
            }
        }

        updateStats() {
            const elapsed = (Date.now() - this.startTime) / 1000;
            const speed = elapsed > 0 ? Math.round(this.searchedCount / elapsed) : 0;

            document.getElementById('foundCount').textContent = this.results.length.toLocaleString();
            document.getElementById('searchedCount').textContent = this.searchedCount.toLocaleString();
            document.getElementById('timeElapsed').textContent = elapsed.toFixed(1) + 's';
            document.getElementById('searchSpeed').textContent = speed.toLocaleString();
        }

        updateResults(highlightedRecommendedSolution = null) {
            const container = document.getElementById('resultsContainer');

            if (this.results.length === 0 && !this.isRunning) {
                container.innerHTML = '<div style="text-align: center; color: var(--color-text-secondary); padding: 40px;">暂无找到符合条件的解</div>';
                return;
            }
             if (this.results.length === 0 && this.isRunning) {
                container.innerHTML = '<div style="text-align: center; color: var(--color-text-secondary); padding: 40px;">正在搜索...</div>';
                return;
            }

            let html = `<div class="result-count">找到 ${this.results.length} 个解${this.results.length > 500 ? " (仅显示前500)" : ""}:</div>`;
            this.results.slice(0, 500).forEach((result, index) => {
                let displayResult = result;
                let tempResult = result;
                for (const [actual, display] of Object.entries(this.displayCharsMap)) {
                    const regex = new RegExp(actual.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'g');
                    tempResult = tempResult.replace(regex, display);
                }
                displayResult = tempResult;

                const isRecommended = result === highlightedRecommendedSolution;
                const itemClass = isRecommended ? "result-item recommended" : "result-item";
                html += `<div class="${itemClass}">${index + 1}. ${displayResult} ${isRecommended ? " (⭐推荐)" : ""}</div>`;
            });

            container.innerHTML = html;
        }

        updateResultsWithRecommendation() {
            const recommendedContainer = document.getElementById('recommendedResultContainer');

            if (this.results.length === 0) {
                this.updateResults();
                recommendedContainer.innerHTML = '<div style="text-align: center; color: var(--color-text-secondary); padding: 20px;">无解则无推荐</div>';
                return;
            }
            if (this.charProbabilitiesData.length === 0 && this.results.length > 0) {
                 this.calculateAndDisplayProbabilities();
            }


            let bestSolution = null;
            let bestScore = -1;

            const topChars = this.charProbabilitiesData.slice(0, Math.min(5, this.charProbabilitiesData.length)).map(p => p.char);

            this.results.forEach(solution => {
                let score = 0;
                const uniqueCharsInSolution = new Set(solution.split(''));

                uniqueCharsInSolution.forEach(char => {
                    const probItem = this.charProbabilitiesData.find(p => p.char === char);
                    if (probItem) {
                        score += probItem.probability;
                    }
                });

                let bonusForTopChars = 0;
                topChars.forEach(topChar => {
                    if(uniqueCharsInSolution.has(topChar)) bonusForTopChars += 50;
                });
                score += bonusForTopChars;

                if (score > bestScore) {
                    bestScore = score;
                    bestSolution = solution;
                }
            });

            if (bestSolution) {
                let displayRecResult = bestSolution;
                 let tempRecResult = bestSolution;
                for (const [actual, display] of Object.entries(this.displayCharsMap)) {
                    const regex = new RegExp(actual.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'g');
                    tempRecResult = tempRecResult.replace(regex, display);
                }
                displayRecResult = tempRecResult;
                recommendedContainer.innerHTML = `<div class="recommended-result-item">${displayRecResult}</div>`;
            } else {
                recommendedContainer.innerHTML = '<div style="text-align: center; color: var(--color-text-secondary); padding: 20px;">无可用推荐</div>';
            }

            this.updateResults(bestSolution);
        }

        calculateAndDisplayProbabilities() {
            const charCounts = {};
            if (this.results.length === 0) {
                this.charProbabilitiesData = [];
                this.updateCharProbabilitiesDisplay();
                return;
            }

            this.results.forEach(solution => {
                const uniqueCharsInSolution = new Set(solution.split(''));
                uniqueCharsInSolution.forEach(char => {
                    charCounts[char] = (charCounts[char] || 0) + 1;
                });
            });

            this.charProbabilitiesData = Object.entries(charCounts).map(([char, count]) => ({
                char,
                probability: (count / this.results.length) * 100
            })).sort((a, b) => b.probability - a.probability || a.char.localeCompare(b.char));

            this.updateCharProbabilitiesDisplay();
        }

        updateCharProbabilitiesDisplay() {
            const container = document.getElementById('charProbContainer');
            if (this.charProbabilitiesData.length === 0) {
                container.innerHTML = '<div style="text-align: center; color: var(--color-text-secondary); padding: 20px;">无数据或未找到解</div>';
                return;
            }

            let html = '';
            const maxProb = Math.max(...this.charProbabilitiesData.map(p => p.probability), 0);

            this.charProbabilitiesData.forEach(item => {
                const displayChar = this.displayCharsMap[item.char] || item.char;
                const barWidth = maxProb > 0 ? (item.probability / maxProb) * 100 : 0;
                html += `
                    <div class="prob-item">
                        <div class="prob-char-display">${displayChar}</div>
                        <div class="prob-bar-container">
                            <div class="prob-bar" style="width: ${barWidth}%;"></div>
                        </div>
                        <div class="prob-value">${item.probability.toFixed(1)}%</div>
                    </div>
                `;
            });
            container.innerHTML = html;
        }

        stop() {
            this.shouldStop = true;
        }

        clear() {
            this.hideContextMenu();
            this.isRunning = false;
            this.shouldStop = true;

            setTimeout(() => {
                this.results = [];
                this.searchedCount = 0;
                this.globalKnowledge = {};
                this.charProbabilitiesData = [];

                this.guessRowsData = [];
                document.getElementById('lengthInput').value = 6;
                this.length = 6;
                this.updateConstraintBoard();

                this.updateResults();
                this.updateStats();
                this.updateCharProbabilitiesDisplay();
                 document.getElementById('recommendedResultContainer').innerHTML =
                    '<div style="text-align: center; color: var(--color-text-secondary); padding: 20px;">等待求解开始...</div>';


                document.getElementById('errorMessage').style.display = 'none';
                document.getElementById('progressContainer').style.display = 'none';
                document.getElementById('progressFill').style.width = '0%';
                document.getElementById('progressText').textContent = '准备中...';

                const solveBtn = document.getElementById('solveBtn');
                const clearBtn = document.getElementById('clearBtn');
                const addGuessRowBtn = document.getElementById('addGuessRowBtn');

                solveBtn.style.display = 'block';
                solveBtn.classList.remove('loading');
                solveBtn.disabled = false;
                clearBtn.classList.remove('loading');
                clearBtn.disabled = false;
                addGuessRowBtn.classList.remove('loading');
                addGuessRowBtn.disabled = false;
                document.getElementById('stopBtn').style.display = 'none';

                if (this.selectedTile && this.selectedTile.element) {
                    this.selectedTile.element.style.outline = '';
                }
                this.selectedTile = null;
                 document.getElementById('importGameStateInput').value = '';
            }, 50);
        }

        showError(message) {
            const errorDiv = document.getElementById('errorMessage');
            errorDiv.textContent = message;
            errorDiv.style.display = 'block';
        }

            toggleTheme() {
                document.body.classList.toggle('dark-theme');
                const themeToggle = document.getElementById('themeToggle');
                themeToggle.textContent = document.body.classList.contains('dark-theme') ? '🌙' : '☀️';
            }
        importGameState() {
            const importInput = document.getElementById('importGameStateInput');
            const gameStateString = importInput.value.trim();
            if (!gameStateString) {
                this.showError("请输入要导入的局面码。");
                return;
            }
            try {
                const gameState = JSON.parse(gameStateString);
                if (!gameState || typeof gameState.length !== 'number' || !Array.isArray(gameState.rows) ) {
                    throw new Error("局面码格式无效或版本不兼容。");
                }

                this.clear();

                setTimeout(() => {
                    this.length = gameState.length;
                    document.getElementById('lengthInput').value = this.length;

                    this.guessRowsData = gameState.rows.map(row =>
                        row.map(tile => ({
                            char: tile.char || '',
                            state: tile.state || 'empty'
                        }))
                    );

                    this.updateConstraintBoard();
                    importInput.value = '';

                    this.showError("局面导入成功！");
                    setTimeout(()=> {
                        const errorDiv = document.getElementById('errorMessage');
                        if (errorDiv.textContent === "局面导入成功！") {
                           errorDiv.style.display = 'none';
                        }
                    }, 2000);
                }, 100);
            } catch (error) {
                this.showError("导入局面失败：" + error.message);
            }
        }
    }

    document.addEventListener('DOMContentLoaded', () => {
        // The OptimizedSumzleSolver instance is created after the WebAssembly module is initialized
        if (!document.getElementById('foundCount').textContent || document.getElementById('foundCount').textContent === '0') {
            const stats = {foundCount: '0', searchedCount: '0', timeElapsed: '0.0s', searchSpeed: '0'};
            for(const id in stats) document.getElementById(id).textContent = stats[id];
            document.getElementById('charProbContainer').innerHTML = '<div style="text-align: center; color: var(--color-text-secondary); padding: 20px;">求解后显示概率</div>';
             document.getElementById('recommendedResultContainer').innerHTML =
                    '<div style="text-align: center; color: var(--color-text-secondary); padding: 20px;">求解后显示推荐</div>';
            document.getElementById('resultsContainer').innerHTML = '<div style="text-align: center; color: var(--color-text-secondary); padding: 40px;">等待求解开始...</div>';
        }
    });
    </script>
</body>
</html>
