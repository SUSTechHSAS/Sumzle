<!DOCTYPE html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Sumzle</title>
    <script src="https://cdn.staticfile.net/Chart.js/3.9.1/chart.js"></script>
    <script src="https://cdn.bootcdn.net/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <style>
        @property --current-title-color-1 {
            syntax: '<color>';
            inherits: false;
            initial-value: #4facfe;
        }

        @property --current-title-color-2 {
            syntax: '<color>';
            inherits: false;
            initial-value: #00f2fe;
        }

        @property --current-title-color-3 {
            syntax: '<color>';
            inherits: false;
            initial-value: #43e97b;
        }

        @property --current-animation-angle {
            syntax: '<angle>';
            inherits: false;
            initial-value: 120deg;
        }

        :root {
            --font-family: "Segoe UI", -apple-system, BlinkMacSystemFont, Roboto, "Helvetica Neue", Arial, "Noto Sans", sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji";
            --color-background: #f8f9fa;
            --color-surface: #ffffff;
            --color-text: #212529;
            --color-text-secondary: #6c757d;
            --color-border: #dee2e6;
            --color-border-light: #f1f3f5;
            --color-divider: #e9ecef;
            --color-correct: #28a745;
            --color-present: #ffc107;
            --color-absent: #7a7a7a;
            --color-key-feedback-text: #ffffff;
            --color-easy: #17a2b8;
            --color-medium: #fd7e14;
            --color-hard: #dc3545;
            --fluent-blue: #007bff;
            --fluent-blue-hover: #0069d9;
            --fluent-blue-active: #0056b3;
            --tile-border-radius: 6px;
            --key-border-radius: 6px;
            --modal-border-radius: 8px;
            --button-border-radius: 5px;
            --shadow-xs: 0 1px 2px rgba(0,0,0,0.05);
            --shadow-s: 0 2px 4px rgba(0,0,0,0.07);
            --shadow-m: 0 4px 8px rgba(0,0,0,0.08), 0 0 1px rgba(0,0,0,0.06);
            --shadow-l: 0 8px 16px rgba(0,0,0,0.1), 0 0 2px rgba(0,0,0,0.07);
            --shadow-xl: 0 12px 24px rgba(0,0,0,0.12), 0 0 3px rgba(0,0,0,0.08);
            --color-key-default-bg: #f1f3f5;
            --color-key-default-border: #ced4da;
            --color-key-default-text: var(--color-text);
            --color-key-default-hover-bg: #e9ecef;
            --color-key-default-active-bg: #dee2e6;
            --color-btn-secondary-bg: #e9ecef;
            --color-btn-secondary-text: var(--color-text);
            --color-btn-secondary-border: var(--color-border);
            --color-btn-secondary-hover-bg: #dee2e6;
            --color-btn-secondary-hover-border: #ced4da;
            --color-btn-secondary-active-bg: #ced4da;
            --color-input-bg: var(--color-background);
            --color-input-text: var(--color-text);
            --color-input-border: var(--color-border);
            --color-input-focus-border: var(--fluent-blue);
            --color-input-focus-shadow: rgba(0,123,255,0.25);
            --chart-grid-color: rgba(0,0,0,0.1);
            --chart-tick-color: #666;
            --chart-title-color: #333;
            --chart-legend-label-color: #333;
            --title-grad-win-1: #28a745;
            --title-grad-win-2: #84fab0;
            --title-grad-win-3: #ffc107;
            --title-grad-lose-1: #d32f2f;
            --title-grad-lose-2: #ff6b6b;
            --title-grad-lose-3: #757575;
            --title-grad-custom-1: #6a11cb;
            --title-grad-custom-2: #2575fc;
            --title-grad-custom-3: #00dbde;
            --title-grad-history-1: #ff9a9e;
            --title-grad-history-2: #fad0c4;
            --title-grad-history-3: #fbc2eb;
            --title-grad-debug-1: #ff00ff;
            --title-grad-debug-2: #00ffff;
            --title-grad-debug-3: #ffff00;
            --title-grad-quark-1: #8A2BE2;
            --title-grad-quark-2: #4B0082;
            --title-grad-quark-3: #DA70D6;
        }

        body.dark-theme {
            --color-background: #1a1a1d;
            --color-surface: #2c2f33;
            --color-text: #f0f0f0;
            --color-text-secondary: #a0a0a0;
            --color-border: #424549;
            --color-border-light: #36393f;
            --color-divider: #36393f;
            --color-key-default-bg: #4f545c;
            --color-key-default-border: #40444b;
            --color-key-default-text: #dcddde;
            --color-key-default-hover-bg: #5c6168;
            --color-key-default-active-bg: #696e75;
            --color-btn-secondary-bg: #4f545c;
            --color-btn-secondary-text: #e0e0e0;
            --color-btn-secondary-border: #40444b;
            --color-btn-secondary-hover-bg: #5c6168;
            --color-btn-secondary-hover-border: #4f545c;
            --color-btn-secondary-active-bg: #696e75;
            --color-input-bg: #36393f;
            --color-input-text: #e0e0e0;
            --color-input-border: #424549;
            --color-input-focus-border: var(--fluent-blue-hover);
            --color-input-focus-shadow: rgba(0,105,217,0.35);
            --chart-grid-color: rgba(255,255,255,0.1);
            --chart-tick-color: #e0e0e0;
            --chart-title-color: #f0f0f0;
            --chart-legend-label-color: #f0f0f0;
            --title-grad-win-1: #30c753;
            --title-grad-win-2: #a2facf;
            --title-grad-win-3: #ffd027;
            --title-grad-lose-1: #ef5350;
            --title-grad-lose-2: #ff8a80;
            --title-grad-lose-3: #bdbdbd;
            --title-grad-custom-1: #834d9b;
            --title-grad-custom-2: #3067c4;
            --title-grad-custom-3: #00c9cb;
            --title-grad-history-1: #f4a7a9;
            --title-grad-history-2: #fcd6ce;
            --title-grad-history-3: #fdd5ef;
            --title-grad-debug-1: #ff33ff;
            --title-grad-debug-2: #33ffff;
            --title-grad-debug-3: #ffff33;
            --title-grad-quark-1: #9F2B68;
            --title-grad-quark-2: #702963;
            --title-grad-quark-3: #C9A0DC;
        }

        body {
            font-family: var(--font-family);
            margin: 0;
            padding: 0;
            background-color: var(--color-background);
            color: var(--color-text);
            display: flex;
            flex-direction: column;
            align-items: center;
            height: 100vh;
            touch-action: manipulation;
            overflow-x: hidden;
            overflow-y: auto;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
            transition: background-color .3s ease-in-out,color .3s ease-in-out
        }

        #dynamicBackgroundCanvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: -1;
            display: block
        }

        header {
            width: 100%;
            padding: 10px 0;
            border-bottom: 1px solid var(--color-divider);
            text-align: center;
            font-weight: 600;
            font-size: 1.6rem;
            position: relative;
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: var(--color-surface);
            min-height: 60px;
            box-sizing: border-box;
            box-shadow: var(--shadow-s);
            z-index: 10;
            transition: background-color .3s ease-in-out,border-bottom-color .3s ease-in-out
        }

        .header-title {
            position: absolute;
            left: 50%;
            transform: translateX(-50%);
            font-weight: 800;
            font-size: 2.2rem;
            font-family: "Segoe UI Black","Arial Black",var(--font-family);
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
            background-image: linear-gradient(var(--current-animation-angle,120deg),var(--current-title-color-1),var(--current-title-color-2),var(--current-title-color-3),var(--current-title-color-2),var(--current-title-color-1));
            background-size: 400% 400%;
            animation: titleShimmer 8s cubic-bezier(.65,.05,.36,1) infinite alternate;
            transition: --current-title-color-1 .8s cubic-bezier(.25,.1,.25,1),--current-title-color-2 .8s cubic-bezier(.25,.1,.25,1),--current-title-color-3 .8s cubic-bezier(.25,.1,.25,1),--current-animation-angle .8s cubic-bezier(.25,.1,.25,1),filter .8s cubic-bezier(.25,.1,.25,1),animation-duration .8s cubic-bezier(.25,.1,.25,1), top .8s cubic-bezier(0.6, -0.28, 0.735, 0.045), opacity .5s ease-out;
            letter-spacing: 1px;
            will-change: background-position,filter,--current-title-color-1,--current-title-color-2,--current-title-color-3,--current-animation-angle,animation-duration, top, opacity;
            cursor: pointer;
        }

        .title-char {
            display: inline-block;
        }

        @keyframes titleShimmer {
            0% {
                background-position: 0% 50%
            }

            50% {
                background-position: 100% 50%
            }

            100% {
                background-position: 0% 50%
            }
        }

        .header-buttons-container {
            position: absolute;
            right: 15px;
            top: 50%;
            transform: translateY(-50%);
            z-index: 100
        }

        .header-buttons {
            display: flex;
            align-items: center;
            gap: 8px;
            transition: opacity .3s cubic-bezier(.215,.61,.355,1),transform .3s cubic-bezier(.215,.61,.355,1),visibility 0s .3s
        }

        #menuToggleBtn {
            display: none
        }

        @media (max-width: 450px) {
            header {
                min-height:56px;
                padding: 6px 0
            }

            .header-title {
                font-size: 1.9rem
            }

            .header-buttons {
                opacity: 0;
                visibility: hidden;
                transform: translateY(-15px) scaleY(.9);
                transform-origin: top right;
                position: absolute;
                top: calc(100% + 8px);
                right: 0;
                flex-direction: column;
                background-color: var(--color-surface);
                border: 1px solid var(--color-border);
                border-radius: var(--modal-border-radius);
                box-shadow: var(--shadow-m);
                padding: 10px;
                z-index: 999
            }

            .header-buttons.show-menu {
                display: flex;
                opacity: 1;
                visibility: visible;
                transform: translateY(0) scaleY(1);
                transition: opacity .3s cubic-bezier(.215,.61,.355,1),transform .3s cubic-bezier(.215,.61,.355,1),visibility 0s 0s
            }

            #menuToggleBtn {
                display: flex;
                background: 0 0;
                border: none;
                font-size: 1.7rem;
                cursor: pointer;
                color: var(--color-text-secondary);
                align-items: center;
                justify-content: center;
                width: 44px;
                height: 44px;
                transition: transform .25s cubic-bezier(.34,1.56,.64,1),background-color .2s ease-out,color .2s ease-out;
                border-radius: var(--button-border-radius)
            }

            #menuToggleBtn:hover {
                background-color: rgba(0,0,0,.04);
                color: var(--color-text)
            }

            #menuToggleBtn.active {
                transform: rotate(90deg);
                color: var(--fluent-blue)
            }

            .icon-btn {
                width: 100%;
                justify-content: flex-start;
                padding: 10px 15px;
                font-size: 1rem;
                height: auto
            }

            .icon-btn:not(:last-child) {
                margin-bottom: 5px
            }
        }

        .icon-btn {
            background: 0 0;
            border: none;
            font-size: 1.6rem;
            cursor: pointer;
            color: var(--color-text-secondary);
            display: flex;
            align-items: center;
            justify-content: center;
            width: 40px;
            height: 40px;
            transition: transform .15s cubic-bezier(.34,1.56,.64,1),color .2s ease-out,background-color .2s ease-out;
            border-radius: var(--button-border-radius)
        }

        .icon-btn:hover {
            color: var(--color-text);
            background-color: rgba(0,0,0,.04)
        }

        .icon-btn:active {
            transform: scale(.9)
        }

        .difficulty-indicator {
            position: absolute;
            left: 15px;
            top: 50%;
            transform: translateY(-50%);
            font-size: .75rem;
            padding: 6px 14px;
            color: #fff;
            border-radius: 18px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: .8px;
            box-shadow: var(--shadow-xs)
        }

        .difficulty-easy {
            background-color: var(--color-easy)
        }

        .difficulty-medium {
            background-color: var(--color-medium)
        }

        .difficulty-hard {
            background-color: var(--color-hard)
        }

        .game-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            flex-grow: 1;
            width: 100%;
            padding: 15px;
            box-sizing: border-box;
            overflow-x: hidden;
            z-index: 5
        }

        .board-wrapper {
            width: 100%;
            max-width: 100vw;
            overflow-x: auto;
            flex-shrink: 0;
            -webkit-overflow-scrolling: touch;
            padding-bottom: 5px
        }

        .board {
            display: grid;
            gap: 6px;
            min-width: 100%;
            width: max-content;
            padding: 2px
        }

        .row {
            display: grid;
            gap: 6px;
            min-width: max-content
        }

        .tile {
            aspect-ratio: 1;
            border: 2px solid var(--color-border-light);
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 1.8rem;
            font-weight: 600;
            border-radius: var(--tile-border-radius);
            transition: transform .3s cubic-bezier(.4,0,.2,1),background-color .3s ease,border-color .3s ease,box-shadow .3s ease,color .3s ease;
            box-sizing: border-box;
            overflow: hidden;
            text-overflow: clip;
            color: var(--color-text);
            background-color: var(--color-surface);
            min-height: 48px;
            height: auto;
            min-width: 48px;
            box-shadow: var(--shadow-xs);
            position: relative;
            z-index: 1
        }
        .tile.unknown-length {
            border-style: dashed !important;
            background-color: color-mix(in srgb, var(--color-surface) 80%, var(--color-text-secondary) 20%) !important;
        }
        .tile.unknown-length::before {
            content: '?';
            font-size: 1.5em;
            color: var(--color-text-secondary);
            opacity: 0.6;
            position: absolute;
        }
        .tile.unknown-length.filled::before {
            display: none;
        }
        .tile.hinted-briefly {
            animation: hintGlow .8s ease-out;
        }

        @keyframes hintGlow {
            0%, 100% { box-shadow: var(--shadow-xs); }
            50% { box-shadow: 0 0 12px 3px var(--color-present); }
        }


        @media (max-width: 500px) {
            .tile {
                min-height:42px;
                font-size: 1.6rem;
                min-width: 42px;
                border-width: 1px
            }
        }

        .tile.filled {
            border-color: #9e9e9e;
            box-shadow: var(--shadow-s)
        }

        body.dark-theme .tile.filled {
            border-color: #787878
        }

        .tile.pop {
            animation: popIn .2s cubic-bezier(.175,.885,.32,1.275);
        }

        @keyframes popIn {
            from {
                transform: scale(.85);
                opacity: 0;
            }
            to {
                transform: scale(1);
                opacity: 1;
            }
        }

        .tile.flip-reveal {
            animation: flip-reveal .7s cubic-bezier(.45,.05,.55,.95) forwards
        }

        @keyframes flip-reveal {
            0% {
                transform: rotateX(0deg)
            }

            50% {
                transform: rotateX(90deg);
                background-color: var(--color-border-light)
            }

            100% {
                transform: rotateX(0deg)
            }
        }

        .tile.win-dance {
            animation: dance .8s cubic-bezier(.34,1.56,.64,1) both
        }

        @keyframes dance {
            0%,100% {
                transform: translateY(0) scale(1)
            }

            20% {
                transform: translateY(-12px) scale(1.12) rotate(-4deg)
            }

            40% {
                transform: translateY(6px) scale(.93) rotate(4deg)
            }

            60% {
                transform: translateY(-7px) scale(1.06) rotate(-2.5deg)
            }

            80% {
                transform: translateY(3px) scale(.97) rotate(1.5deg)
            }
        }

        .correct {
            background-color: var(--color-correct)!important;
            color: var(--color-key-feedback-text)!important;
            border-color: var(--color-correct)!important;
            box-shadow: none!important
        }

        .present {
            background-color: var(--color-present)!important;
            color: var(--color-key-feedback-text)!important;
            border-color: var(--color-present)!important;
            box-shadow: none!important
        }

        .absent {
            background-color: var(--color-absent)!important;
            color: var(--color-key-feedback-text)!important;
            border-color: var(--color-absent)!important;
            box-shadow: none!important
        }

        #statusIndicatorWrapper {
            width: 100%;
            display: flex;
            justify-content: center;
            margin: 12px 0 18px;
            flex-shrink: 0;
            height: 40px
        }

        #statusIndicator {
            padding: 0 22px;
            background-color: var(--color-surface);
            color: var(--color-text-secondary);
            border-radius: 20px;
            font-size: .95rem;
            font-weight: 500;
            text-align: center;
            line-height: 40px;
            box-shadow: var(--shadow-m);
            transition-property: opacity, transform, min-width, padding, color, font-weight, background-color;
            transition-duration: .3s, .3s, .2s, .2s, .2s, .2s, .3s;
            transition-timing-function: cubic-bezier(.25,.1,.25,1), cubic-bezier(.25,.1,.25,1), ease-out, ease-out, ease-out, ease-out, ease-in-out;
            opacity: 0;
            transform: translateY(15px) scale(.9);
            white-space: nowrap;
            max-width: 85%;
            overflow: hidden;
            text-overflow: ellipsis
        }
         #statusIndicator.no-transition {
            transition-property: min-width, padding, color, font-weight, background-color !important;
            transition-duration: .2s, .2s, .2s, .2s, .3s !important;
            transition-timing-function: ease-out, ease-out, ease-out, ease-out, ease-in-out !important;
        }


        #statusIndicator.visible {
            opacity: 1;
            transform: translateY(0) scale(1)
        }

        #statusIndicator.timer-active {
            min-width: 130px;
            font-variant-numeric: tabular-nums;
            font-weight: 600
        }

        .keyboard {
            display: flex;
            flex-direction: column;
            width: 100%;
            max-width: 520px;
            gap: 6px;
            padding-bottom: 10px
        }

        .keyboard-row {
            display: flex;
            justify-content: center;
            gap: 5px;
            width: 100%
        }

        .key {
            height: 54px;
            border-radius: var(--key-border-radius);
            background-color: var(--color-key-default-bg);
            font-size: 1.15rem;
            font-weight: 500;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            -webkit-user-select: none;
            user-select: none;
            flex: 1;
            transition: background-color .15s ease-out,transform .1s cubic-bezier(.34,1.56,.64,1),box-shadow .15s ease-out,border-color .15s ease-out,color .15s ease-out;
            box-shadow: var(--shadow-xs);
            color: var(--color-key-default-text);
            border: 1px solid var(--color-key-default-border);
            position: relative;
            z-index: 1;
            overflow: hidden
        }

        .key.show-tooltip {
            overflow: visible
        }

        .key::before {
            content: "";
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 0;
            z-index: -1;
            transition: height .3s cubic-bezier(.645,.045,.355,1);
            border-radius: inherit
        }

        .key:not(.correct):not(.present):not(.absent):hover {
            background-color: var(--color-key-default-hover-bg)
        }

        .key:not(.correct):not(.present):not(.absent):active,.key.pressed:not(.correct):not(.present):not(.absent) {
            background-color: var(--color-key-default-active-bg);
            transform: scale(.95) translateY(1px);
            box-shadow: none
        }

        .key.wide {
            flex: 1.5;
            font-size: .95rem
        }

        .key.super-wide {
            flex: 1.5;
            background-color: var(--fluent-blue);
            color: #fff;
            border-color: var(--fluent-blue-hover);
            font-weight: 600
        }

        .key.super-wide:not(.correct):not(.present):not(.absent):hover {
            background-color: var(--fluent-blue-hover)
        }

        .key.super-wide:not(.correct):not(.present):not(.absent):active {
            background-color: var(--fluent-blue-active)
        }

        .key.correct,.key.present,.key.absent {
            background-color: transparent!important;
            color: var(--color-key-feedback-text)!important;
            font-weight: 600
        }

        .key.correct {
            border-color: var(--color-correct)!important;
            animation: keyGreenPulse .4s cubic-bezier(.175,.885,.32,1.275)
        }

        .key.present {
            border-color: var(--color-present)!important
        }

        .key.absent {
            border-color: var(--color-absent)!important;
            opacity: .9
        }

        .key.correct::before {
            background-color: var(--color-correct);
            height: 100%
        }

        .key.present::before {
            background-color: var(--color-present);
            height: 100%
        }

        .key.absent::before {
            background-color: var(--color-absent);
            height: 100%
        }

        @keyframes keyGreenPulse {
            0%,100% {
                transform: scale(1)
            }

            50% {
                transform: scale(1.08) translateY(-1px)
            }
        }

        .key.disabled-permanently {
            opacity: .45!important;
            pointer-events: none!important;
            background-color: #ced4da!important;
            color: #adb5bd!important;
            border-color: #adb5bd!important
        }

        body.dark-theme .key.disabled-permanently {
            background-color: #4a4e54!important;
            color: #72767d!important;
            border-color: #72767d!important
        }

        .key.disabled-permanently::before {
            display: none
        }

        .key.disabled-view-mode, .keyboard.disabled-input .key:not(.disabled-permanently) {
            opacity: .55!important;
            pointer-events: none!important
        }

        .keyboard.true-random-keys .key:not(.super-wide):not(.wide) {
            order: var(--random-order, 0);
        }


        .key-tooltip {
            position: absolute;
            bottom: calc(100% + 10px);
            left: 50%;
            transform: translateX(-50%) translateY(6px) scale(.9);
            background-color: var(--color-text);
            color: var(--color-surface);
            padding: 7px 12px;
            border-radius: var(--button-border-radius);
            font-size: .85rem;
            font-weight: 500;
            white-space: nowrap;
            z-index: 10;
            opacity: 0;
            visibility: hidden;
            transition: opacity .2s ease-out,transform .2s ease-out,visibility 0s .2s,background-color .3s ease-in-out,color .3s ease-in-out;
            box-shadow: var(--shadow-m);
            pointer-events: none
        }

        .key.operator-key.show-tooltip .key-tooltip,.key.operator-key:hover .key-tooltip {
            opacity: 1;
            visibility: visible;
            transform: translateX(-50%) translateY(0) scale(1);
            transition: opacity .2s ease-out,transform .2s cubic-bezier(.175,.885,.32,1.275),visibility 0s 0s,background-color .3s ease-in-out,color .3s ease-in-out
        }

        .message {
            position: fixed;
            top: 12%;
            left: 50%;
            transform: translateX(-50%) translateY(-30px) scale(.9);
            background-color: rgba(25,25,25,.95);
            -webkit-backdrop-filter: blur(4px);
            backdrop-filter: blur(4px);
            color: #fff;
            padding: 16px 28px;
            border-radius: var(--modal-border-radius);
            z-index: 1001;
            opacity: 0;
            font-weight: 500;
            box-shadow: var(--shadow-l);
            visibility: hidden;
            transition: opacity .3s cubic-bezier(.215,.61,.355,1),transform .3s cubic-bezier(.215,.61,.355,1),visibility 0s .3s;
            width: auto;
            max-width: 88vw;
            box-sizing: border-box;
            text-align: center;
            white-space: normal;
            word-break: break-word;
            font-size: 1.05rem
        }

        .message.show-message {
            opacity: 1;
            transform: translateX(-50%) translateY(0) scale(1);
            visibility: visible;
            transition: opacity .35s cubic-bezier(.175,.885,.32,1.275),transform .35s cubic-bezier(.175,.885,.32,1.275),visibility 0s 0s
        }

        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,.45);
            -webkit-backdrop-filter: blur(6px);
            backdrop-filter: blur(6px);
            z-index: 1000;
            justify-content: center;
            align-items: center;
            opacity: 0;
            transition: opacity .3s ease-in-out,-webkit-backdrop-filter .3s ease-in-out;
            transition: opacity .3s ease-in-out,backdrop-filter .3s ease-in-out;
            transition: opacity .3s ease-in-out,backdrop-filter .3s ease-in-out,-webkit-backdrop-filter .3s ease-in-out
        }

        .modal.show {
            display: flex;
            opacity: 1
        }

        .modal-content {
            background-color: var(--color-surface);
            padding: 30px;
            border-radius: var(--modal-border-radius);
            max-width: 90%;
            width: 520px;
            text-align: center;
            max-height: 90vh;
            overflow-y: auto;
            box-shadow: var(--shadow-xl);
            opacity: 0;
            transform: translateY(30px) scale(.95);
            transition: opacity .35s cubic-bezier(.175,.885,.32,1.275),transform .35s cubic-bezier(.175,.885,.32,1.275),background-color .3s ease-in-out
        }

        .modal.show .modal-content {
            opacity: 1;
            transform: translateY(0) scale(1)
        }

        .modal h2 {
            margin-top: 0;
            margin-bottom: 22px;
            color: var(--color-text);
            font-size: 1.8rem;
            font-weight: 600;
            transition: color .3s ease-in-out
        }

        .modal p {
            color: var(--color-text-secondary);
            font-size: 1.05rem;
            line-height: 1.65;
            margin-bottom: 28px;
            transition: color .3s ease-in-out
        }

        .modal button {
            color: #fff;
            border: none;
            padding: 13px 26px;
            border-radius: var(--button-border-radius);
            font-weight: 500;
            font-size: 1rem;
            cursor: pointer;
            margin-top: 15px;
            transition: background-color .2s ease-out,transform .15s cubic-bezier(.34,1.56,.64,1),box-shadow .2s ease-out,color .2s ease-out,border-color .2s ease-out;
            min-width: 125px;
            text-transform: uppercase;
            letter-spacing: .5px
        }

        .modal button.primary-btn {
            background-color: var(--fluent-blue)
        }

        .modal button.primary-btn:hover {
            background-color: var(--fluent-blue-hover);
            box-shadow: var(--shadow-s)
        }

        .modal button.primary-btn:active {
            background-color: var(--fluent-blue-active);
            transform: scale(.96)
        }

        .modal button.secondary-btn {
            background-color: var(--color-btn-secondary-bg);
            color: var(--color-btn-secondary-text);
            border: 1px solid var(--color-btn-secondary-border)
        }

        .modal button.secondary-btn:hover {
            background-color: var(--color-btn-secondary-hover-bg);
            border-color: var(--color-btn-secondary-hover-border);
            box-shadow: var(--shadow-s)
        }

        .modal button.secondary-btn:active {
            background-color: var(--color-btn-secondary-active-bg);
            transform: scale(.96)
        }

        .modal button.danger-btn {
            background-color: var(--color-hard)!important
        }

        .modal button.danger-btn:hover {
            background-color: #c82333!important;
            box-shadow: var(--shadow-s)
        }

        .modal button.danger-btn:active {
            background-color: #bd2130!important;
            transform: scale(.96)
        }

        #gameOverTitle {
            font-size: 2.2rem;
            font-weight: 700
        }

        #gameOverMessage {
            font-size: 1.15rem;
            margin-bottom: 28px;
            color: var(--color-text-secondary)
        }

        .stats-container {
            display: flex;
            justify-content: space-around;
            width: 100%;
            margin: 35px 0
        }

        .stat {
            display: flex;
            flex-direction: column;
            align-items: center
        }

        .stat-number {
            font-size: 2.4rem;
            font-weight: 700;
            color: var(--color-text);
            transition: color .3s ease-in-out
        }

        .stat-label {
            font-size: .85rem;
            text-transform: uppercase;
            color: var(--color-text-secondary);
            letter-spacing: .8px;
            margin-top: 5px;
            transition: color .3s ease-in-out
        }

        .difficulty-selector {
            display: flex;
            justify-content: space-between;
            margin: 28px 0;
            width: 100%;
            gap: 12px
        }

        .difficulty-btn {
            padding: 14px 10px;
            border-radius: var(--button-border-radius);
            cursor: pointer;
            flex: 1;
            text-align: center;
            font-weight: 600;
            color: #fff;
            font-size: .95rem;
            border: 2px solid transparent;
            opacity: .9;
            transition: transform .2s cubic-bezier(.34,1.56,.64,1),box-shadow .25s ease-out,opacity .25s ease-out,border-color .25s ease-out,background-color .25s ease-out;
            box-shadow: var(--shadow-xs);
            line-height: 1.4
        }

        .difficulty-btn:not(.selected):hover {
            opacity: 1;
            transform: translateY(-3px);
            box-shadow: var(--shadow-m)
        }

        .difficulty-btn.selected {
            opacity: 1;
            transform: scale(1.03) translateY(-4px);
            border-width: 2px;
            font-weight: 700
        }

        .difficulty-btn.easy {
            background-color: var(--color-easy)
        }

        .difficulty-btn.medium {
            background-color: var(--color-medium)
        }

        .difficulty-btn.hard {
            background-color: var(--color-hard)
        }

        .difficulty-btn.easy.selected {
            border-color: #138496;
            box-shadow: 0 4px 12px rgba(23,162,184,.4)
        }

        .difficulty-btn.medium.selected {
            border-color: #e06200;
            box-shadow: 0 4px 12px rgba(253,126,20,.4)
        }

        .difficulty-btn.hard.selected {
            border-color: #bd2130;
            box-shadow: 0 4px 12px rgba(220,53,69,.4)
        }

        .stats-chart-tabs {
            display: flex;
            justify-content: center;
            margin-bottom: 15px;
            border-radius: var(--button-border-radius);
            background-color: var(--color-background);
            padding: 4px;
            box-shadow: inset 0 1px 3px rgba(0,0,0,0.1);
        }

        .stats-chart-tabs .stats-tab-btn {
            flex: 1;
            padding: 10px 15px;
            font-size: 0.9rem;
            font-weight: 500;
            color: var(--color-text-secondary);
            background-color: transparent;
            border: none;
            border-radius: var(--button-border-radius);
            cursor: pointer;
            transition: background-color 0.25s ease-out, color 0.25s ease-out, box-shadow 0.25s ease-out;
            margin: 0 !important;
        }

        .stats-chart-tabs .stats-tab-btn.active {
            color: var(--color-key-feedback-text);
            background-color: var(--fluent-blue);
            box-shadow: var(--shadow-s);
            font-weight: 600;
        }

        #exportImageBtn {
            background-color: var(--color-present);
            color: var(--color-text)!important;
            margin-left: 10px
        }

        #exportImageBtn:hover {
            background-color: #e0a800!important
        }

        #shareLevelBtn {
            margin-left: 10px
        }

        .flying-char-effect {
            position: fixed;
            z-index: 9999;
            pointer-events: none;
            transition: transform .35s cubic-bezier(.34,0,.66,1.5),opacity .45s ease-out,width .35s ease-out,height .35s ease-out,background-color .3s ease-in-out,color .3s ease-in-out;
            opacity: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: var(--shadow-m)
        }

        #confettiOverlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            pointer-events: none;
            overflow: hidden;
            z-index: 10000
        }

        .confetti-piece {
            position: absolute;
            pointer-events: none;
            transition-property: transform,top,opacity;
            transition-timing-function: cubic-bezier(.1,.5,.3,1),cubic-bezier(.1,.25,.3,1),ease-in;
            will-change: transform,top,opacity
        }

        .invalid-shake {
            animation: shake .5s cubic-bezier(.36,.07,.19,.97) both
        }

        @keyframes shake {
            10%,90% {
                transform: translateX(-1.5px)
            }

            20%,80% {
                transform: translateX(3px)
            }

            30%,50%,70% {
                transform: translateX(-5px)
            }

            40%,60% {
                transform: translateX(5px)
            }
        }

        textarea#levelCodeInput {
            width: 95%;
            margin-bottom: 18px;
            padding: 14px;
            border-radius: var(--button-border-radius);
            border: 1px solid var(--color-input-border);
            font-size: 1rem;
            background-color: var(--color-input-bg);
            color: var(--color-input-text);
            line-height: 1.5;
            transition: background-color .3s ease-in-out,color .3s ease-in-out,border-color .3s ease-in-out
        }

        textarea#levelCodeInput:focus {
            border-color: var(--color-input-focus-border);
            box-shadow: 0 0 0 3px var(--color-input-focus-shadow);
            outline: none
        }

        .tile.tile-new-game-appear {
            opacity: 0;
            transform: scale(.5) translateY(15px);
            animation: tileNewGameAppearAnimation .4s cubic-bezier(.175,.885,.32,1.275) forwards
        }

        @keyframes tileNewGameAppearAnimation {
            to {
                opacity: 1;
                transform: scale(1) translateY(0)
            }
        }

        .tile.tile-cleared-animation {
            animation: tileClearQuick .15s ease-out forwards;
        }

        @keyframes tileClearQuick {
            0% { transform: scale(1); opacity: 1; }
            100% { transform: scale(0.5); opacity: 0; }
        }

        #historyListContainer {
            max-height: 60vh;
            overflow-y: auto;
            margin-bottom: 22px;
            padding-right: 12px;
            scrollbar-width: thin;
            scrollbar-color: var(--color-border) var(--color-background);
            transition: scrollbar-color .3s ease-in-out
        }

        #historyListContainer::-webkit-scrollbar {
            width: 8px
        }

        #historyListContainer::-webkit-scrollbar-track {
            background: var(--color-background);
            border-radius: 4px;
            transition: background-color .3s ease-in-out
        }

        #historyListContainer::-webkit-scrollbar-thumb {
            background-color: var(--color-border);
            border-radius: 4px;
            border: 2px solid var(--color-background);
            transition: background-color .3s ease-in-out,border-color .3s ease-in-out
        }

        .history-item {
            background-color: var(--color-background);
            border: 1px solid var(--color-border-light);
            border-radius: var(--button-border-radius);
            padding: 18px;
            margin-bottom: 14px;
            text-align: left;
            box-shadow: var(--shadow-s);
            transition: box-shadow .25s ease-out,transform .25s ease-out,background-color .3s ease-in-out,border-color .3s ease-in-out
        }

        .history-item:hover {
            box-shadow: var(--shadow-m);
            transform: translateY(-2px) scale(1.005)
        }

        .history-item-preview {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px
        }

        .history-equation {
            font-weight: 600;
            font-size: 1.15rem;
            color: var(--color-text);
            flex-grow: 1;
            margin-right: 12px;
            word-break: break-all;
            transition: color .3s ease-in-out
        }

        .history-status {
            font-size: .85rem;
            font-weight: 700;
            padding: 5px 10px;
            border-radius: var(--button-border-radius);
            color: #fff;
            text-transform: uppercase;
            letter-spacing: .5px
        }

        .history-status.won {
            background-color: var(--color-correct)
        }

        .history-status.lost,.history-status.surrendered, .history-status.abandoned, .history-status.lost_sudden_death {
            background-color: var(--color-hard)
        }


        .history-item-details {
            font-size: .9rem;
            color: var(--color-text-secondary);
            margin-bottom: 14px;
            display: flex;
            flex-wrap: wrap;
            gap: 6px 12px;
            transition: color .3s ease-in-out
        }

        .history-item-details span {
            white-space: nowrap
        }

        .history-item-actions {
            display: flex;
            gap: 10px;
            justify-content: flex-end
        }

        .history-item-actions button {
            padding: 9px 14px;
            font-size: .9rem;
            min-width: auto;
            margin-top: 0
        }

        #noHistoryMessage {
            color: var(--color-text-secondary);
            padding: 25px;
            font-size: 1.05rem;
            transition: color .3s ease-in-out
        }

        .debug-option-group {
            border: 1px solid var(--color-divider);
            border-radius: var(--button-border-radius);
            padding: 15px;
            margin-bottom: 20px;
            background-color: var(--color-background);
            box-shadow: var(--shadow-xs);
        }
        .debug-option-group h4 {
            margin-top: 0;
            margin-bottom: 12px;
            font-size: 1.1rem;
            color: var(--color-text);
            border-bottom: 1px solid var(--color-border-light);
            padding-bottom: 8px;
        }
        .debug-button-row {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            justify-content: space-between;
        }
        .debug-button-row button.small-btn {
            flex-grow: 1;
            flex-basis: calc(33.333% - 10px);
            min-width: 100px;
            padding: 10px 5px;
            font-size: 0.85rem;
        }
         .debug-button-row button.small-btn.two-per-row {
            flex-basis: calc(50% - 5px);
        }

        button.full-width-btn {
            width: 100%;
            margin-top: 8px;
        }
        .input-with-button {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .input-with-button input[type="number"], .input-with-button input[type="text"] {
            flex-grow: 1;
            width: auto;
        }
        .input-with-button button.small-btn {
            padding: 10px 15px;
            font-size: 0.85rem;
            margin-top: 0;
            flex-shrink: 0;
        }
        #debugModal .modal-content {
            max-height: 85vh;
        }


        .debug-option {
            margin-bottom: 18px;
            text-align: left;
        }
        .debug-option label {
            display: block;
            margin-bottom: 6px;
            font-weight: 500;
            font-size: 0.95rem;
        }
        .debug-option input[type="number"], .debug-option textarea, .debug-option input[type="text"] {
            width: 100%;
            padding: 10px;
            border-radius: var(--button-border-radius);
            border: 1px solid var(--color-input-border);
            font-size: 0.9rem;
            background-color: var(--color-input-bg);
            color: var(--color-input-text);
            line-height: 1.4;
            transition: background-color .3s ease-in-out,color .3s ease-in-out,border-color .3s ease-in-out;
            box-sizing: border-box;
        }
        .debug-option input[type="number"]:focus, .debug-option textarea:focus, .debug-option input[type="text"]:focus {
            border-color: var(--color-input-focus-border);
            box-shadow: 0 0 0 3px var(--color-input-focus-shadow);
            outline: none;
        }
        .debug-option input[type="checkbox"], .debug-option input[type="color"] {
            vertical-align: middle;
            margin-right: 8px;
            width: auto;
            height: auto;
            padding: 0;
        }
         .debug-option input[type="color"] {
            min-height: 30px;
         }
        .debug-option .checkbox-label {
            display: inline;
            font-weight: normal;
            margin-bottom: 0;
        }

        #debugModalTitle {
            font-size: 2rem;
            font-weight: 700;
            margin-bottom: 25px;
            padding-bottom: 10px;
            border-bottom: 2px solid var(--color-divider);
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
            background-image: linear-gradient(var(--current-animation-angle,120deg),var(--title-grad-debug-1),var(--title-grad-debug-2),var(--title-grad-debug-3),var(--title-grad-debug-2),var(--title-grad-debug-1));
            background-size: 300% 300%;
            animation: titleShimmer 6s cubic-bezier(.65,.05,.36,1) infinite alternate;
        }
        #debugModal .modal-button-container {
            margin-top: 25px;
            display: flex;
            justify-content: flex-end;
            gap: 10px;
            border-top: 1px solid var(--color-divider);
            padding-top: 20px;
        }
      #confirmNukeModal {
            z-index: 1002;
        }
      #hintConfirmationModal {
            z-index: 1001;
      }

    </style>
</head>
<body>
    <canvas id="dynamicBackgroundCanvas"></canvas>
    <header>
        <div id="difficultyDisplay" class="difficulty-indicator difficulty-medium">中等</div>
        <div class="header-title state-idle" id="mainHeaderTitle">SUMZLE</div>
        <div class="header-buttons-container">
            <button id="menuToggleBtn">☰</button>
            <div class="header-buttons" id="headerButtonsGroup">
                <button class="icon-btn" id="themeToggleBtn" title="切换主题">☀️</button>
                <button class="icon-btn" id="hintBtn" title="获取提示">💡</button>
                <button class="icon-btn" id="loadLevelBtn" title="载入关卡">🔗</button>
                <button class="icon-btn" id="historyBtn" title="游戏历史">📜</button>
                <button class="icon-btn" id="statsBtn" title="统计">📊</button>
                <button class="icon-btn" id="settingsBtn" title="设置">⚙️</button>
                <button class="icon-btn" id="restartBtn" title="重新开始/投降">🔄</button>
            </div>
        </div>
    </header>
    <div id="confettiOverlay"></div>
    <div class="game-container" id="gameContainer">
        <div class="board-wrapper">
            <div class="board" id="board"></div>
        </div>
        <div id="statusIndicatorWrapper">
            <div id="statusIndicator" class="status-indicator">准备开始</div>
        </div>
        <div class="keyboard" id="keyboard"></div>
    </div>
    <div class="message" id="message"></div>
    <div class="modal" id="gameOverModal">
        <div class="modal-content">
            <h2 id="gameOverTitle"></h2>
            <p id="gameOverMessage"></p>
            <div class="stats-container">
                <div class="stat">
                    <div class="stat-number" id="gamesPlayed">0</div>
                    <div class="stat-label">已玩</div>
                </div>
                <div class="stat">
                    <div class="stat-number" id="gamesWon">0</div>
                    <div class="stat-label">获胜</div>
                </div>
                <div class="stat">
                    <div class="stat-number" id="currentStreak">0</div>
                    <div class="stat-label">连胜</div>
                </div>
            </div>
            <button id="newGameBtn" class="primary-btn">开始新游戏</button>
            <button id="exportImageBtn" class="secondary-btn" style="display:none;">导出图片</button>
            <button id="shareLevelBtn" class="secondary-btn">分享关卡</button>
        </div>
    </div>
    <div class="modal" id="settingsModal">
        <div class="modal-content">
            <h2>设置</h2>
            <h3>难度选择</h3>
            <div class="difficulty-selector">
                <div class="difficulty-btn easy" data-difficulty="easy">
                    简单<br>(8次)
                </div>
                <div class="difficulty-btn medium selected" data-difficulty="medium">
                    中等<br>(6次)
                </div>
                <div class="difficulty-btn hard" data-difficulty="hard">
                    困难<br>(4次)
                </div>
            </div>
            <button id="closeSettingsBtn" class="primary-btn">确定</button>
        </div>
    </div>
    <div class="modal" id="statsModal">
        <div class="modal-content">
            <h2>游戏统计</h2>
            <div class="stats-chart-tabs">
                <button class="stats-tab-btn active" data-chart-target="statsChartDifficultyContainer">按难度</button>
                <button class="stats-tab-btn" data-chart-target="statsChartStarsContainer">按星级</button>
            </div>
            <div style="width: 100%; max-width: 450px; margin: 20px auto; height: 300px; position: relative;">
                <div id="statsChartDifficultyContainer" class="stats-chart-container" style="width:100%; height:100%;">
                    <canvas id="statsChartDifficulty"></canvas>
                </div>
                <div id="statsChartStarsContainer" class="stats-chart-container" style="width:100%; height:100%; display: none;">
                     <canvas id="statsChartStars"></canvas>
                </div>
            </div>
            <button id="clearStatsBtn" class="danger-btn">清空统计数据</button>
            <button id="closeStatsBtn" class="secondary-btn" style="margin-top: 10px;">关闭</button>
        </div>
    </div>
    <div class="modal" id="loadLevelModal">
        <div class="modal-content">
            <h2>载入分享关卡</h2>
            <textarea id="levelCodeInput" placeholder="在此处粘贴关卡代码..." rows="3"></textarea>
            <div style="display: flex; gap: 10px; margin-top: 10px; flex-wrap: wrap;">
                 <button id="submitLoadLevelBtn" class="primary-btn" style="flex-grow:1;">载入</button>
                 <button id="copyGameStateBtn" class="secondary-btn" style="flex-grow:1;">复制当前局面码</button>
            </div>
            <button id="closeLoadLevelModalBtn" class="secondary-btn" style="margin-top: 10px; width: 100%;">取消</button>
        </div>
    </div>
    <div class="modal" id="surrenderModal">
        <div class="modal-content">
            <h2>放弃挑战？</h2>
            <p>确定要放弃当前的游戏吗？这将会被记录为一次失败</p>
            <button id="confirmSurrenderBtn" class="danger-btn">确认放弃</button>
            <button id="cancelSurrenderBtn" class="secondary-btn" style="margin-left: 10px;">继续挑战</button>
        </div>
    </div>
    <div class="modal" id="confirmClearStatsModal">
        <div class="modal-content">
            <h2>确认操作</h2>
            <p>确定要清空所有统计数据吗？此操作无法撤销</p>
            <button id="executeClearStatsBtn" class="danger-btn">确认清空</button>
            <button id="cancelClearStatsBtn" class="secondary-btn" style="margin-left: 10px;">取消</button>
        </div>
    </div>
    <div class="modal" id="historyModal">
        <div class="modal-content">
            <h2>游戏历史</h2>
            <div id="historyListContainer"></div>
            <p id="noHistoryMessage" style="display:none;">暂无历史记录</p>
            <button id="clearHistoryBtn" class="danger-btn" style="margin-right:10px; display:none;">清空历史</button>
            <button id="closeHistoryModalBtn" class="secondary-btn">关闭</button>
        </div>
    </div>
    <div class="modal" id="confirmClearHistoryModal">
        <div class="modal-content">
            <h2>确认操作</h2>
            <p>确定要清空所有游戏历史记录吗？此操作无法撤销</p>
            <button id="executeClearHistoryBtn" class="danger-btn">确认清空</button>
            <button id="cancelClearHistoryBtn" class="secondary-btn" style="margin-left: 10px;">取消</button>
        </div>
    </div>
    <div class="modal" id="confirmNukeModal">
        <div class="modal-content">
            <h2 id="confirmNukeTitle">清除数据</h2>
            <p id="confirmNukeMessage" style="font-weight: bold;">确定要清除所有本地存储数据吗？包括统计、历史、设置等。此操作将重置游戏到初始状态且无法撤销！</p>
            <button id="executeNukeBtn" class="danger-btn">确认核爆本地数据</button>
            <button id="cancelNukeBtn" class="secondary-btn" style="margin-left: 10px;">取消</button>
        </div>
    </div>
    <div class="modal" id="hintConfirmationModal">
        <div class="modal-content">
            <h2>使用提示</h2>
            <p>使用提示将会使本局游戏不计入您的主要统计数据（如连胜、胜率）确定要使用提示吗？</p>
            <button id="confirmUseHintBtn" class="primary-btn">确认使用</button>
            <button id="cancelUseHintBtn" class="secondary-btn" style="margin-left: 10px;">取消</button>
        </div>
    </div>

    <div class="modal" id="debugModal">
        <div class="modal-content">
            <h2 id="debugModalTitle">QUARK 调试面板</h2>
            <div class="debug-option-group">
                <h4>表达式与生成控制</h4>
                <div class="debug-option">
                    <label for="debugCustomExpr">指定下次游戏表达式:</label>
                    <textarea id="debugCustomExpr" rows="2" placeholder="例如, 1+1=2"></textarea>
                </div>
                <div class="debug-option">
                    <label for="debugLockLength">固定表达式长度 (0=自动):</label>
                    <input type="number" id="debugLockLength" min="0" value="0">
                </div>
                <div class="debug-option">
                    <label for="debugMaxGenAttempts">表达式生成尝试次数上限 (0=自动):</label>
                    <input type="number" id="debugMaxGenAttempts" min="0" value="0">
                </div>
                <div class="debug-option">
                    <input type="checkbox" id="debugDisableMax">
                    <label for="debugDisableMax" class="checkbox-label">移除最大长度限制 (默认15)</label>
                </div>
                 <div class="debug-option debug-button-row">
                    <button id="debugGenerateExprBtn" class="secondary-btn small-btn">随机生成表达式</button>
                    <button id="debugLogTargetBtn" class="secondary-btn small-btn">记录目标至控制台</button>
                 </div>
                <textarea id="debugGeneratedExprDisplay" rows="2" readonly placeholder="生成的表达式会在此显示..."></textarea>
            </div>

             <div class="debug-option-group">
                <h4>实验性玩法调整</h4>
                 <div class="debug-option">
                    <input type="checkbox" id="debugUnknownLengthToggle">
                    <label for="debugUnknownLengthToggle" class="checkbox-label">目标长度未知模式</label>
                </div>
                 <div class="debug-option">
                    <input type="checkbox" id="debugOneTryModeToggle">
                    <label for="debugOneTryModeToggle" class="checkbox-label">极限挑战模式 (单行决胜)</label>
                </div>
                <div class="debug-option">
                    <input type="checkbox" id="debugMirrorInputToggle">
                    <label for="debugMirrorInputToggle" class="checkbox-label">镜像键盘输入模式</label>
                </div>
                <div class="debug-option">
                    <input type="checkbox" id="debugRandomKeyboardLayoutToggle">
                    <label for="debugRandomKeyboardLayoutToggle" class="checkbox-label">随机化键盘按键布局</label>
                </div>
                 <div class="debug-option">
                    <label for="debugMisleadingFeedbackRate">误导性反馈概率 (%):</label>
                    <input type="number" id="debugMisleadingFeedbackRate" min="0" max="100" value="0">
                </div>
                 <div class="debug-option">
                    <input type="checkbox" id="debugSuddenDeathTimerToggle">
                    <label for="debugSuddenDeathTimerToggle" class="checkbox-label">计时挑战模式 (30秒)</label>
                </div>
                <div class="debug-option">
                    <input type="checkbox" id="debugVanishingInkToggle">
                    <label for="debugVanishingInkToggle" class="checkbox-label">隐形墨水模式 (字符渐隐)</label>
                </div>
                <div class="debug-option">
                    <input type="checkbox" id="debugGrayKeysUnclickableToggle">
                    <label for="debugGrayKeysUnclickableToggle" class="checkbox-label">禁用已排除字符按键</label>
                </div>
            </div>

            <div class="debug-option-group">
                <h4>当前游戏状态控制</h4>
                <div class="debug-option">
                    <label for="debugCurrentTargetDisplay">当前游戏目标表达式:</label>
                    <textarea id="debugCurrentTargetDisplay" rows="1" readonly></textarea>
                </div>
                <div class="debug-option debug-button-row">
                    <button id="debugForceWinBtn" class="secondary-btn small-btn two-per-row">强制判定为胜利</button>
                    <button id="debugForceLoseBtn" class="secondary-btn small-btn two-per-row">强制判定为失败</button>
                </div>
                <div class="debug-option debug-button-row">
                    <button id="debugTriggerShakeBtn" class="secondary-btn small-btn two-per-row">测试无效输入抖动效果</button>
                    <button id="debugClearInputRowBtn" class="secondary-btn small-btn two-per-row">清除当前行已输入内容</button>
                </div>
            </div>

            <div class="debug-option-group">
                <h4>界面与效果工具</h4>
                 <div class="debug-option debug-button-row">
                    <button id="debugSoundKeypress" class="secondary-btn small-btn">测试按键音效</button>
                    <button id="debugSoundWin" class="secondary-btn small-btn">测试胜利音效</button>
                    <button id="debugSoundFail" class="secondary-btn small-btn">测试失败音效</button>
                </div>
                <div class="debug-option debug-button-row">
                    <button id="debugConfettiBtn" class="secondary-btn small-btn two-per-row">测试胜利纸屑效果</button>
                    <button id="debugThemeCycleBtn" class="secondary-btn small-btn two-per-row">循环切换界面主题</button>
                </div>
                 <div class="debug-option">
                    <label for="debugBgParticles">背景粒子效果数量 (0=自动):</label>
                    <div class="input-with-button">
                        <input type="number" id="debugBgParticles" min="0" value="0">
                        <button id="debugApplyBgParticlesBtn" class="secondary-btn small-btn">设置</button>
                    </div>
                </div>
                 <div class="debug-option">
                    <input type="checkbox" id="debugPsychedelicBgToggle">
                    <label for="debugPsychedelicBgToggle" class="checkbox-label">启用动态迷幻背景效果</label>
                </div>
            </div>

            <div class="debug-option-group">
                <h4>高级与危险操作区</h4>
                <div class="debug-option">
                    <label for="debugStressTestRuns">表达式生成器压力测试 (轮次):</label>
                    <div class="input-with-button">
                        <input type="number" id="debugStressTestRuns" min="1" value="100">
                        <button id="debugRunStressTestBtn" class="secondary-btn small-btn">执行测试</button>
                    </div>
                    <textarea id="debugStressTestResults" rows="3" readonly style="margin-top:8px;" placeholder="压力测试结果将在此显示..."></textarea>
                </div>
                <div class="debug-option">
                     <button id="debugNukeStorageBtn" class="danger-btn full-width-btn">☢️ 清除所有本地存储并重载</button>
                </div>
            </div>

            <p id="debugHint" style="font-size:0.85rem; color: var(--color-text-secondary); margin-top:15px; margin-bottom:20px;">部分设置调整将在开始新游戏或重玩当前关卡时应用。自定义表达式仅在下次游戏生效一次</p>

            <div class="modal-button-container">
                <button id="applyDebugSettingsBtn" class="primary-btn">应用设置并关闭</button>
                <button id="closeDebugModalBtn" class="secondary-btn">直接关闭</button>
            </div>
        </div>
    </div>
    <script>
        document.addEventListener('DOMContentLoaded', ()=>{
            const difficultySetting = {
                easy: {
                    attempts: 8,
                    name: "简单",
                    class: "difficulty-easy",
                    color: "rgba(23,162,184,1)"
                },
                medium: {
                    attempts: 6,
                    name: "中等",
                    class: "difficulty-medium",
                    color: "rgba(253,126,20,1)"
                },
                hard: {
                    attempts: 4,
                    name: "困难",
                    class: "difficulty-hard",
                    color: "rgba(220,53,69,1)"
                }
            };
            let currentDifficulty = "medium"
              , ROWS = difficultySetting[currentDifficulty].attempts;
            const DEFAULT_MAX_EQUATION_LENGTH = 15
              , MIN_EQUATION_LENGTH = 3;
            let gameActive = true
              , currentRow = 0
              , currentCol = 0
              , guessedEquation = []
              , targetEquation = ''
              , COLS = 0
              , currentEquationStars = ""
              , isCustomLevel = false;
            let stats = {
                total: {
                    gamesPlayed: 0,
                    gamesWon: 0,
                    currentStreak: 0,
                    bestStreak: 0
                },
                byDifficulty: {
                    easy: {
                        gamesPlayed: 0,
                        gamesWon: 0
                    },
                    medium: {
                        gamesPlayed: 0,
                        gamesWon: 0
                    },
                    hard: {
                        gamesPlayed: 0,
                        gamesWon: 0
                    }
                }
            };
            const initialStats = JSON.parse(JSON.stringify(stats));
            let statsChartDifficultyInstance = null;
            let statsChartStarsInstance = null;
            const XOR_KEY = "SUMZLECRYPTLVL"
              , SHARE_SEPARATOR = "::DIFEQ::";
            let activeTooltipKey = null
              , activeTooltipTimeout = null;
            const keyTooltips = {
                '+': '加法',
                '-': '减法',
                '*': '乘法',
                '/': '除法',
                '%': '取模',
                '^': '乘方',
                '>': '大于',
                '!': '阶乘',
                'A': '排列 (mAn)',
                '(': '左括号',
                ')': '右括号',
                '[': '取整数部分 ([n])',
                ']': '取整结束',
                '=': '等于'
            };
            const statusIndicator = document.getElementById('statusIndicator');
            const headerTitleElement = document.getElementById('mainHeaderTitle');
            let gameStartTime = 0
              , gameTimerInterval = null
              , elapsedSeconds = 0
              , guessedEquationsHistory = []
              , isViewingHistoryState = false
              , viewingHistoryItem = null;
            const restartBtn = document.getElementById('restartBtn');
            let bgCanvas, bgCtx, stars_bg = [], dayParticles = [], animationFrameId_bg, currentBgMode = 'dark', currentTheme = 'light';
            const STAR_COLORS_BG = ["#FFFFFF", "#FFFFAA", "#FFEEFF", "#DDEEFF"];
            
let sharedAudioContext = null;
let audioContextInitialized = false;
let sounds = {};

function initializeAudio() {
    if (!audioContextInitialized && (window.AudioContext || window.webkitAudioContext)) {
        const AudioContextClass = window.AudioContext || window.webkitAudioContext;
        try {
            sharedAudioContext = new AudioContextClass();
            
            sounds = {
                keyPress: createCartoonSound(1200, 0.03, 'triangle', 0.05, 0.01),
                success: createCartoonSound(1500, 0.2, 'sine', 0.1, 0.05, [{freq: 1800, time: 0.05}, {freq: 2200, time: 0.1}]),
                failure: createCartoonSound(300, 0.25, 'sawtooth', 0.08, 0.02, [{freq: 200, time: 0.1}]),
                hint: createCartoonSound(1000, 0.15, 'square', 0.06, 0.01, [{freq: 1300, time: 0.07}])
            };
            audioContextInitialized = true;
            
            if (sharedAudioContext.state === 'suspended') {
                 // Defer resume attempt to actual sound play
            }
        } catch (e) {
            audioContextInitialized = false;
        }
    } else if (!window.AudioContext && !window.webkitAudioContext) {
        audioContextInitialized = false;
    }
}

function createCartoonSound(baseFrequency, duration, waveType = 'sine', initialGain = 0.1, attackTime = 0.01, pitchBends = [], detuneAmount = 0) {
    return () => {
        if (!sharedAudioContext || !audioContextInitialized) {
            return;
        }

        if (sharedAudioContext.state === 'suspended') {
            sharedAudioContext.resume().catch(e => {});
        }

        if (sharedAudioContext.state !== 'running') {
            return;
        }

        try {
            const now = sharedAudioContext.currentTime;
            const oscillator = sharedAudioContext.createOscillator();
            const gainNode = sharedAudioContext.createGain();
            
            oscillator.connect(gainNode);
            gainNode.connect(sharedAudioContext.destination);
            
            oscillator.type = waveType;
            oscillator.frequency.setValueAtTime(baseFrequency, now);

            if (pitchBends && pitchBends.length > 0) {
                pitchBends.forEach(bend => {
                    oscillator.frequency.linearRampToValueAtTime(bend.freq, now + bend.time);
                });
            }
            
            if (detuneAmount !== 0) {
                oscillator.detune.setValueAtTime(detuneAmount, now);
            }

            gainNode.gain.setValueAtTime(0, now);
            gainNode.gain.linearRampToValueAtTime(initialGain, now + attackTime);
            gainNode.gain.setValueAtTime(initialGain, now + duration - (duration * 0.1)); // Hold gain for 90% of duration
            gainNode.gain.linearRampToValueAtTime(0, now + duration); // Quick fade out

            oscillator.start(now);
            oscillator.stop(now + duration);
        } catch (e) {
            // Silently fail for production
        }
    };
}

function playSound(soundName) {
    if (!audioContextInitialized) {
        initializeAudio();
        if (!audioContextInitialized) {
            return; 
        }
    }

    if (sounds[soundName] && typeof sounds[soundName] === 'function') {
        if (sharedAudioContext && sharedAudioContext.state === 'suspended') {
            sharedAudioContext.resume().then(() => {
                sounds[soundName]();
            }).catch(e => {});
        } else if (sharedAudioContext && sharedAudioContext.state === 'running') {
            sounds[soundName]();
        }
    }
}

            const idleGradients = [{
                c1: '#4facfe',
                c2: '#00f2fe',
                c3: '#43e97b'
            }, {
                c1: '#ff9a9e',
                c2: '#fecfef',
                c3: '#ffdde1'
            }, {
                c1: '#a18cd1',
                c2: '#fbc2eb',
                c3: '#8fd3f4'
            }, {
                c1: '#f6d365',
                c2: '#fda085',
                c3: '#ffc3a0'
            }, {
                c1: '#667eea',
                c2: '#764ba2',
                c3: '#6a11cb'
            }];
            let currentIdleGradientIndex = 0;
            let isClearingRowWithAnimation = false;

            let liveStatusUpdateInterval = null;
            const LIVE_STATUS_UPDATE_INTERVAL_MS = 100;
            let statusIndicatorAnimationTimeout = null;
            let isStatusIndicatorAnimating = false;
            const ABANDONED_STATUS = 'ABANDONED';

            let sumzleEasterEggActivated = false;
            let quarkModeActive = false;
            let sumzleTitleClickCount = 0;
            const SUMZLE_CLICK_THRESHOLD = 7;
            const ORIGINAL_TITLE_TEXT = "SUMZLE";
            const QUARK_TITLE_TEXT = "QUARK";
            let titleFallAnimation = {
                active: false,
                element: null,
                y: 0,
                vy: 0,
                initialVyForQuark: -20,
                gravity: 0.8,
                targetY: 0,
                type: '',
                onComplete: null,
                originalComputedTransition: null,
                originalComputedTop: '0px'
            };

            let debugSettings = {
                lockedLength: 0,
                disableMaxLength: false,
                customExpression: "",
                useCustomExpressionForNextGame: false,
                maxGenAttempts: 0,
                customBgParticleCount: 0,
                psychedelicBgActive: false,
                originalTitleColors: {c1: '', c2: '', c3: ''},
                unknownLengthMode: false,
                oneTryMode: false,
                mirrorInputMode: false,
                randomKeyboardLayout: false,
                misleadingFeedbackRate: 0,
                suddenDeathTimer: false,
                vanishingInkMode: false,
                suddenDeathIntervalId: null,
                grayKeysUnclickable: false,
            };
            let quarkDebugClickCount = 0;
            const QUARK_DEBUG_CLICK_THRESHOLD = 7;

            const mirrorMap = {
                '1':'0', '2':'9', '3':'8', '4':'7', '5':'6', '6':'5', '7':'4', '8':'3', '9':'2', '0':'1',
                '(' : ')', ')' : '(', '[' : ']', ']' : '[','+':'-','-':'+','*':'/','/':'*','×':'÷','÷':'×'
            };
            let hintsUsedThisGame = 0;
            let gameCountsForStats = true;


            function setupTitleSpans(text) {
                headerTitleElement.innerHTML = '';
                text.split('').forEach(char=>{
                    const span = document.createElement('span');
                    span.className = 'title-char';
                    span.textContent = char;
                    headerTitleElement.appendChild(span);
                }
                );
            }

            function setHeaderTitleState(state) {
                const stateClasses = ['state-idle', 'state-win', 'state-lose', 'state-custom', 'state-history', 'state-debug', 'state-quark'];
                stateClasses.forEach(cls=>{
                    if (cls === `state-${state}`) {
                        if (!headerTitleElement.classList.contains(cls))
                            headerTitleElement.classList.add(cls);
                    } else
                        headerTitleElement.classList.remove(cls);
                }
                );
                let c1, c2, c3, animationAngle = '120deg', newAnimationDuration = '10s', filterStyle = 'none';
                const rootStyle = getComputedStyle(document.documentElement);

                if (debugSettings.originalTitleColors.c1 === '') {
                    debugSettings.originalTitleColors.c1 = rootStyle.getPropertyValue('--current-title-color-1').trim();
                    debugSettings.originalTitleColors.c2 = rootStyle.getPropertyValue('--current-title-color-2').trim();
                    debugSettings.originalTitleColors.c3 = rootStyle.getPropertyValue('--current-title-color-3').trim();
                }


                switch (state) {
                case 'win':
                    c1 = rootStyle.getPropertyValue('--title-grad-win-1').trim();
                    c2 = rootStyle.getPropertyValue('--title-grad-win-2').trim();
                    c3 = rootStyle.getPropertyValue('--title-grad-win-3').trim();
                    animationAngle = '75deg';
                    newAnimationDuration = '4s';
                    filterStyle = `drop-shadow(0 0 8px ${c2})`;
                    break;
                case 'lose':
                    c1 = rootStyle.getPropertyValue('--title-grad-lose-1').trim();
                    c2 = rootStyle.getPropertyValue('--title-grad-lose-2').trim();
                    c3 = rootStyle.getPropertyValue('--title-grad-lose-3').trim();
                    animationAngle = '100deg';
                    newAnimationDuration = '12s';
                    filterStyle = `saturate(.6) brightness(.85) drop-shadow(0 0 5px rgba(0,0,0,.3))`;
                    break;
                case 'custom':
                    c1 = rootStyle.getPropertyValue('--title-grad-custom-1').trim();
                    c2 = rootStyle.getPropertyValue('--title-grad-custom-2').trim();
                    c3 = rootStyle.getPropertyValue('--title-grad-custom-3').trim();
                    animationAngle = '80deg';
                    newAnimationDuration = '7s';
                    filterStyle = `drop-shadow(0 0 6px ${c2})`;
                    break;
                case 'history':
                    c1 = rootStyle.getPropertyValue('--title-grad-history-1').trim();
                    c2 = rootStyle.getPropertyValue('--title-grad-history-2').trim();
                    c3 = rootStyle.getPropertyValue('--title-grad-history-3').trim();
                    animationAngle = '90deg';
                    newAnimationDuration = '9s';
                    filterStyle = `saturate(.8) drop-shadow(0 0 4px ${c2})`;
                    break;
                case 'debug':
                    c1 = rootStyle.getPropertyValue('--title-grad-debug-1').trim();
                    c2 = rootStyle.getPropertyValue('--title-grad-debug-2').trim();
                    c3 = rootStyle.getPropertyValue('--title-grad-debug-3').trim();
                    animationAngle = '60deg';
                    newAnimationDuration = '5s';
                    filterStyle = `drop-shadow(0 0 10px ${c2}) contrast(1.2)`;
                    document.getElementById('debugModalTitle').style.setProperty('--current-title-color-1', c1);
                    document.getElementById('debugModalTitle').style.setProperty('--current-title-color-2', c2);
                    document.getElementById('debugModalTitle').style.setProperty('--current-title-color-3', c3);
                    document.getElementById('debugModalTitle').style.setProperty('--current-animation-angle', animationAngle);
                    break;
                case 'quark':
                    c1 = rootStyle.getPropertyValue('--title-grad-quark-1').trim();
                    c2 = rootStyle.getPropertyValue('--title-grad-quark-2').trim();
                    c3 = rootStyle.getPropertyValue('--title-grad-quark-3').trim();
                    animationAngle = '45deg';
                    newAnimationDuration = '6s';
                    filterStyle = `drop-shadow(0 0 12px ${c3}) brightness(1.1)`;
                    break;
                default:
                    const grad = idleGradients[currentIdleGradientIndex];
                    c1 = grad.c1;
                    c2 = grad.c2;
                    c3 = grad.c3;
                    if (state === 'idle')
                        currentIdleGradientIndex = (currentIdleGradientIndex + 1) % idleGradients.length;
                    animationAngle = '120deg';
                    newAnimationDuration = '10s';
                    filterStyle = 'none';
                    break;
                }
                headerTitleElement.style.setProperty('--current-title-color-1', c1);
                headerTitleElement.style.setProperty('--current-title-color-2', c2);
                headerTitleElement.style.setProperty('--current-title-color-3', c3);
                headerTitleElement.style.setProperty('--current-animation-angle', animationAngle);
                headerTitleElement.style.animationDuration = newAnimationDuration;
                headerTitleElement.style.filter = filterStyle;
            }
            function isEffectivelyDarkMode() {
                return currentTheme === 'dark';
            }
            function applyTheme(theme) {
                currentTheme = theme;
                const themeToggleBtn = document.getElementById('themeToggleBtn');
                const activeStateClass = Array.from(headerTitleElement.classList).find(c=>c.startsWith('state-'));
                const currentTitleState = activeStateClass ? activeStateClass.replace('state-', '') : 'idle';
                if (theme === 'dark') {
                    document.body.classList.add('dark-theme');
                    document.body.style.backgroundColor = 'var(--color-background)';
                    if (themeToggleBtn)
                        themeToggleBtn.innerHTML = '🌙';
                } else {
                    document.body.classList.remove('dark-theme');
                    document.body.style.backgroundColor = 'var(--color-background)';
                    if (themeToggleBtn)
                        themeToggleBtn.innerHTML = '☀️';
                }
                setHeaderTitleState(currentTitleState);
                updateBackgroundStyle();
                if (document.getElementById('statsModal').classList.contains('show')) {
                     const activeTab = document.querySelector('.stats-chart-tabs .stats-tab-btn.active');
                     if (activeTab && activeTab.dataset.chartTarget === 'statsChartDifficultyContainer') {
                         updateStatsDisplay(true, false);
                     } else if (activeTab && activeTab.dataset.chartTarget === 'statsChartStarsContainer') {
                         updateStatsDisplay(false, true);
                     } else {
                         updateStatsDisplay(true, false);
                     }
                }
            }
            function toggleTheme() {
                const newTheme = currentTheme === 'light' ? 'dark' : 'light';
                localStorage.setItem('sumzleTheme', newTheme);
                applyTheme(newTheme);
            }
            const savedTheme = localStorage.getItem('sumzleTheme');
            if (savedTheme)
                applyTheme(savedTheme);
            else
                applyTheme('light');
            document.getElementById('themeToggleBtn').addEventListener('click', toggleTheme);

            function updateBackgroundStyle() {
                const darkMode = isEffectivelyDarkMode();
                if (darkMode) {
                    if (currentBgMode !== 'night' || stars_bg.length === 0 || debugSettings.customBgParticleCount > 0 || debugSettings.psychedelicBgActive) {
                        currentBgMode = 'night';
                        dayParticles = [];
                        populateStars();
                    }
                } else {
                    if (currentBgMode !== 'day' || dayParticles.length === 0 || debugSettings.customBgParticleCount > 0 || debugSettings.psychedelicBgActive) {
                        currentBgMode = 'day';
                        stars_bg = [];
                        populateDayParticles();
                    }
                }
                if (!animationFrameId_bg && (stars_bg.length > 0 || dayParticles.length > 0))
                    animateBackground();
                else if (stars_bg.length === 0 && dayParticles.length === 0 && animationFrameId_bg) {
                    cancelAnimationFrame(animationFrameId_bg);
                    animationFrameId_bg = null;
                    if (bgCtx && bgCanvas)
                        bgCtx.clearRect(0, 0, bgCanvas.width, bgCanvas.height);
                }
            }

            function initBackground() {
                bgCanvas = document.getElementById('dynamicBackgroundCanvas');
                if (!bgCanvas)
                    return;
                bgCtx = bgCanvas.getContext('2d');
                resizeBackgroundCanvas();
                window.addEventListener('resize', resizeBackgroundCanvas);
                updateBackgroundStyle();
            }
            function resizeBackgroundCanvas() {
                if (!bgCanvas || !bgCtx)
                    return;
                bgCanvas.width = window.innerWidth;
                bgCanvas.height = window.innerHeight;
                if(debugSettings.psychedelicBgActive || debugSettings.customBgParticleCount > 0) {
                    updateBackgroundStyle();
                }
            }
            function Particle(x, y, radius, color, dx, dy, opacity) {
                this.x = x;
                this.y = y;
                this.radius = radius;
                this.color = color;
                this.dx = dx;
                this.dy = dy;
                this.opacity = opacity;
            }
            Particle.prototype.draw = function() {
                if (!bgCtx)
                    return;
                bgCtx.beginPath();
                bgCtx.arc(this.x, this.y, this.radius, 0, Math.PI * 2, false);
                bgCtx.save();
                bgCtx.globalAlpha = this.opacity;
                bgCtx.fillStyle = this.color;
                bgCtx.fill();
                bgCtx.restore();
                bgCtx.closePath();
            }
            Particle.prototype.update = function(isStar=false) {
                if (!bgCanvas)
                    return;
                if (isStar) {
                    this.y += this.dy;
                    if (Math.random() < .015 && !debugSettings.psychedelicBgActive)
                        this.opacity = Math.random() * .6 + .2;
                    if (this.y - this.radius > bgCanvas.height) {
                        this.y = 0 - this.radius - Math.random() * 25;
                        this.x = Math.random() * bgCanvas.width;
                        this.opacity = debugSettings.psychedelicBgActive ? 1 : (Math.random() * .5 + .5);
                    }
                } else {
                    this.x += this.dx;
                    this.y += this.dy;
                    if (this.x - this.radius > bgCanvas.width || this.x + this.radius < 0 || this.y - this.radius > bgCanvas.height || this.y + this.radius < 0) {
                        this.y = bgCanvas.height + this.radius + Math.random() * 50;
                        this.x = Math.random() * bgCanvas.width;
                        this.dx = (Math.random() - .5) * (debugSettings.psychedelicBgActive ? 2 : .6);
                        this.dy = -(Math.random() * (debugSettings.psychedelicBgActive ? 1 : .3) + .1);
                        this.opacity = debugSettings.psychedelicBgActive ? (Math.random()*0.4 + 0.6) : (Math.random() * .3 + .2);
                    }
                }
                this.draw();
            }
            function populateStars() {
                if (!bgCanvas || !bgCtx)
                    return;
                stars_bg = [];
                let numStars, baseSpeed;
                const difficultyToUse = isViewingHistoryState && viewingHistoryItem ? viewingHistoryItem.difficulty : currentDifficulty;

                if (debugSettings.psychedelicBgActive) {
                    numStars = 150; baseSpeed = 1.5;
                } else {
                    switch (difficultyToUse) {
                        case 'easy': numStars = 80; baseSpeed = .15; break;
                        case 'medium': numStars = 120; baseSpeed = .3; break;
                        case 'hard': numStars = 160; baseSpeed = .45; break;
                        default: numStars = 120; baseSpeed = .3;
                    }
                }


                if (debugSettings.customBgParticleCount > 0 && !debugSettings.psychedelicBgActive) {
                    numStars = debugSettings.customBgParticleCount;
                } else if (!debugSettings.psychedelicBgActive) {
                    if (isCustomLevel && !isViewingHistoryState) numStars = Math.min(numStars, 100);
                    if (isViewingHistoryState) {
                        numStars = Math.max(50, Math.floor(numStars * .6));
                        baseSpeed *= .7;
                    }
                    if (!gameActive && !isViewingHistoryState && currentBgMode === 'night') {
                        numStars = Math.floor(numStars * .8);
                        baseSpeed *= .8;
                    }
                }

                for (let i = 0; i < numStars; i++) {
                    const radius = debugSettings.psychedelicBgActive ? (Math.random() * 3 + 1) : (Math.random() * 1.3 + .4);
                    const x = Math.random() * bgCanvas.width;
                    const y = Math.random() * bgCanvas.height;
                    const color = debugSettings.psychedelicBgActive ? `hsl(${Math.random() * 360}, 100%, 70%)` : STAR_COLORS_BG[Math.floor(Math.random() * STAR_COLORS_BG.length)];
                    const dy = (Math.random() * .5 + .1) * baseSpeed;
                    stars_bg.push(new Particle(x,y,radius,color,0,dy, debugSettings.psychedelicBgActive ? 1 : (Math.random() * .5 + .5)));
                }
            }
            function populateDayParticles() {
                if (!bgCanvas || !bgCtx)
                    return;
                dayParticles = [];
                let numParticles, baseColorRGB;
                const difficultyToUse = isViewingHistoryState && viewingHistoryItem ? viewingHistoryItem.difficulty : currentDifficulty;
                const getColorParts = colorStr=>{
                    const match = colorStr.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)(?:,\s*[\d\.]+)?\)/);
                    if (match) return { r: parseInt(match[1]), g: parseInt(match[2]), b: parseInt(match[3]) };
                    return { r: 253, g: 126, b: 20 };
                };

                if (debugSettings.psychedelicBgActive) {
                    numParticles = 50;
                } else {
                     switch (difficultyToUse) {
                        case 'easy': numParticles = 35; baseColorRGB = getColorParts(difficultySetting.easy.color); break;
                        case 'medium': numParticles = 25; baseColorRGB = getColorParts(difficultySetting.medium.color); break;
                        case 'hard': numParticles = 18; baseColorRGB = getColorParts(difficultySetting.hard.color); break;
                        default: numParticles = 25; baseColorRGB = getColorParts(difficultySetting.medium.color);
                    }
                }


                if (debugSettings.customBgParticleCount > 0 && !debugSettings.psychedelicBgActive) {
                    numParticles = debugSettings.customBgParticleCount;
                } else if (!debugSettings.psychedelicBgActive) {
                    if (isCustomLevel && !isViewingHistoryState) numParticles = Math.min(numParticles, 20);
                    if (isViewingHistoryState) numParticles = Math.max(10, Math.floor(numParticles * .7));
                    if (!gameActive && !isViewingHistoryState && currentBgMode === 'day') numParticles = Math.floor(numParticles * .8);
                }

                for (let i = 0; i < numParticles; i++) {
                    const radius = debugSettings.psychedelicBgActive ? (Math.random() * 40 + 15) : (Math.random() * 25 + 10);
                    const x = Math.random() * bgCanvas.width;
                    const y = Math.random() * bgCanvas.height + radius;
                    const particleOpacity = debugSettings.psychedelicBgActive ? (Math.random() * .3 + .1) : (Math.random() * .15 + .05);
                    const color = debugSettings.psychedelicBgActive ? `hsla(${Math.random() * 360}, 100%, 60%, ${particleOpacity})` : `rgba(${baseColorRGB.r},${baseColorRGB.g},${baseColorRGB.b},${particleOpacity})`;
                    const dx = (Math.random() - .5) * (debugSettings.psychedelicBgActive ? 1.2 : .4);
                    const dy = -(Math.random() * (debugSettings.psychedelicBgActive ? 0.6 : .15) + .03);
                    dayParticles.push(new Particle(x,y,radius,color,dx,dy,1));
                }
            }
            function animateBackground() {
                if (!bgCtx || !bgCanvas) return;
                animationFrameId_bg = requestAnimationFrame(animateBackground);

                bgCtx.clearRect(0, 0, bgCanvas.width, bgCanvas.height);


                if (currentBgMode === 'night') stars_bg.forEach(star=>star.update(true));
                else dayParticles.forEach(particle=>particle.update(false));
            }
            initBackground();
            function displayChar(char) {
                if (char === '*')
                    return '×';
                if (char === '/')
                    return '÷';
                return char;
            }
            function encodeLevel(eq, difficulty) {
                const combined = `${difficulty}${SHARE_SEPARATOR}${eq}`;
                let xored = "";
                for (let i = 0; i < combined.length; i++)
                    xored += String.fromCharCode(combined.charCodeAt(i) ^ XOR_KEY.charCodeAt(i % XOR_KEY.length));
                try {
                    return btoa(xored);
                } catch (e) {
                    return null;
                }
            }
            function decodeLevel(encodedLevel) {
                try {
                    let xored = atob(encodedLevel)
                      , original = "";
                    for (let i = 0; i < xored.length; i++)
                        original += String.fromCharCode(xored.charCodeAt(i) ^ XOR_KEY.charCodeAt(i % XOR_KEY.length));
                    const parts = original.split(SHARE_SEPARATOR);
                    if (parts.length === 2 && difficultySetting[parts[0]])
                        return {
                            difficulty: parts[0],
                            equation: parts[1]
                        };
                    return null;
                } catch (e) {
                    return null;
                }
            }
            if (localStorage.getItem('sumzleStats')) {
                const savedStats = JSON.parse(localStorage.getItem('sumzleStats'));
                if (savedStats.byDifficulty)
                    stats = savedStats;
                else {
                    stats.total.gamesPlayed = savedStats.gamesPlayed || 0;
                    stats.total.gamesWon = savedStats.gamesWon || 0;
                    stats.total.currentStreak = savedStats.currentStreak || 0;
                    stats.total.bestStreak = savedStats.bestStreak || 0;
                }
            }
            if (localStorage.getItem('sumzleDifficulty')) {
                const savedDiff = localStorage.getItem('sumzleDifficulty');
                if (difficultySetting[savedDiff])
                    currentDifficulty = savedDiff;
                ROWS = difficultySetting[currentDifficulty].attempts;
            }
            const validChars = "0123456789+-*/%^=()![]>A";
            window.factorial = function(n) {
                n = Number(n);
                if (isNaN(n) || n < 0 || n !== Math.floor(n))
                    throw new Error("Factorial non-neg int");
                if (n > 20)
                    throw new Error("Factorial max 20");
                if (n === 0 || n === 1)
                    return 1;
                let result = 1;
                for (let i = 2; i <= n; i++)
                    result *= i;
                return result;
            }
            ;
            window.permutation = function(m, n) {
                m = Number(m);
                n = Number(n);
                if (isNaN(m) || isNaN(n) || m < 0 || n < 0 || m !== Math.floor(m) || n !== Math.floor(n))
                    throw new Error("Permutation args must be non-negative integers");
                if (n > m)
                    throw new Error("In mAn, n cannot be greater than m");
                if (n === 0)
                    return 1;
                if (m > 10 || n > 10)
                    throw new Error("Permutation arguments too large (max 10 for m, n)");
                let result = 1;
                for (let i = 0; i < n; i++)
                    result *= m - i;
                return result;
            }
            ;
            function updateDifficultyDisplay() {
                const difficultyElement = document.getElementById('difficultyDisplay');
                difficultyElement.className = 'difficulty-indicator';
                difficultyElement.classList.add(difficultySetting[currentDifficulty].class);
                difficultyElement.textContent = difficultySetting[currentDifficulty].name;
                document.querySelectorAll('.difficulty-btn').forEach(btn=>btn.classList.toggle('selected', btn.dataset.difficulty === currentDifficulty));
                updateBackgroundStyle();
            }
            function getRandomInt(min, max) {
                return Math.floor(Math.random() * (max - min + 1)) + min;
            }
            function generateNumberSegment() {
                return String(getRandomInt(1, 20));
            }
            function generateParenthesizedBinaryOpSegment() {
                const a = getRandomInt(1, 10);
                let b = getRandomInt(1, 10);
                const ops = ['+', '-', '*', '^', '^', '^', '^', '%']
                  , op = ops[Math.floor(Math.random() * ops.length)];
                if (op === '^') {
                    const typeOfPower = Math.random();
                    if (typeOfPower < .6) {
                        b = getRandomInt(2, 3);
                        return `(${a}^${b})`;
                    } else {
                        const baseForSqrt = getRandomInt(2, 5);
                        return `(${baseForSqrt * baseForSqrt}^(1/2))`;
                    }
                }
                if (op === '-' && a < b)
                    return `(${b}${op}${a})`;
                if (op === '%' && b === 0)
                    b = getRandomInt(1, 5);
                const needsParentheses = op === '^' || op === '%' || op === '*';
                return needsParentheses ? `(${a}${op}${b})` : `${a}${op}${b}`;
            }
            function generateFactorialSegment() {
                return `${getRandomInt(1, 5)}!`;
            }
            function generateFloorDivSegment() {
                return `[${getRandomInt(1, 10)}/${getRandomInt(2, 5)}]`;
            }
            function generatePermutationSegment() {
                let m = getRandomInt(2, 7)
                  , n = getRandomInt(1, m);
                return `${m}A ${n}`;
            }
            const segmentGenerators = [generateNumberSegment, generateParenthesizedBinaryOpSegment, generateFactorialSegment, generateFloorDivSegment, generatePermutationSegment];
            function isSimpleSegment(expr) {
                return /^\d+$|^(\d+)!$|^\d+A\d+$/.test(expr);
            }
            function isRedundantParentheses(segment) {
                if (segment.startsWith("(") && segment.endsWith(")")) {
                    const inner = segment.substring(1, segment.length - 1);
                    if (isSimpleSegment(inner))
                        return true;
                    if (inner.startsWith("(") && inner.endsWith(")") && checkBrackets(inner)) {
                        try {
                            const outerVal = safeEval(segment)
                              , innerVal = safeEval(inner);
                            if (Math.abs(outerVal - innerVal) < .0001)
                                return true;
                        } catch (e) {}
                    }
                }
                return false;
            }
            function generateSingleExpressionSegment() {
                let segment = ""
                  , attempts = 0;
                do {
                    const generator = segmentGenerators[Math.floor(Math.random() * segmentGenerators.length)];
                    segment = generator();
                    attempts++;
                    if (attempts > 20)
                        return String(getRandomInt(1, 10));
                    if (isRedundantParentheses(segment))
                        segment = segment.substring(1, segment.length - 1);
                } while (segment === "" || isRedundantParentheses(segment));
                return segment;
            }

            function generateFallbackEquation() {
                const a = getRandomInt(1, 9);
                return `${a}+${a}=${a + a}`;
            }
            function generateComplexLHS() {
                let expr = generateSingleExpressionSegment();
                const removeOuterParentheses = str=>{
                    if (str.startsWith("(") && str.endsWith(")") && checkBrackets(str.slice(1, -1)))
                        return str.slice(1, -1);
                    return str;
                };
                expr = removeOuterParentheses(expr);

                const currentMaxEqLength = debugSettings.disableMaxLength ? 9999 : DEFAULT_MAX_EQUATION_LENGTH;
                let EqMargin = 5;

                while (expr.length < currentMaxEqLength - EqMargin && Math.random() < 0.75) {
                    const nextSegment = generateSingleExpressionSegment();
                    if (expr.length + nextSegment.length + 1 > currentMaxEqLength - EqMargin) {
                        break;
                    }

                    const ops = ['+', '-', '*', '%'];
                    const op = ops[Math.floor(Math.random() * ops.length)];

                    const shouldWrap = (segmentStr, operatorToApply) => {
                        if (isSimpleSegment(segmentStr)) return false;
                        if ((segmentStr.startsWith('(') && segmentStr.endsWith(')') && checkBrackets(segmentStr.substring(1, segmentStr.length - 1))) ||
                            (segmentStr.startsWith('[') && segmentStr.endsWith(']') && checkBrackets(segmentStr.substring(1, segmentStr.length - 1)))) {
                            return false;
                        }
                        if (operatorToApply === '*' || operatorToApply === '/' || operatorToApply === '%' || operatorToApply === '^') {
                            return true;
                        }
                        return false;
                    };

                    const exprNeedsParens = shouldWrap(expr, op);
                    const nextNeedsParens = shouldWrap(nextSegment, op);

                    let tempNewExpr;
                    if (Math.random() < 0.5) {
                        tempNewExpr = `${exprNeedsParens ? '(' + expr + ')' : expr}${op}${nextNeedsParens ? '(' + nextSegment + ')' : nextSegment}`;
                    } else {
                        tempNewExpr = `${nextNeedsParens ? '(' + nextSegment + ')' : nextSegment}${op}${exprNeedsParens ? '(' + expr + ')' : expr}`;
                    }
                    try {
                        safeEval(tempNewExpr.substring(0, Math.min(tempNewExpr.length, 10)));
                        expr = tempNewExpr;
                    } catch (e) {
                        break;
                    }

                    if (expr.length > 30) EqMargin = 7;
                    if (expr.length > 50) EqMargin = 9;
                }


                try {
                    const val = safeEval(expr);
                    if (!Number.isInteger(val) || expr.includes('.')) {
                        return String(getRandomInt(1, 30));
                    }
                } catch (e) {
                    return String(getRandomInt(1, 30));
                }
                return expr;
            }

            function generateRandomEquation() {
                let equation = '';
                let generationAttempts = 0;
                let internalDefaultMaxAttempts = (debugSettings.lockedLength > 0 || debugSettings.disableMaxLength) ? 300 : 80;
                const maxTotalAttempts = (debugSettings.maxGenAttempts > 0 && debugSettings.maxGenAttempts >= 10) ? debugSettings.maxGenAttempts : internalDefaultMaxAttempts;

                while (generationAttempts < maxTotalAttempts) {
                    const opChance = Math.random();
                    let mainOperator;
                    if (currentDifficulty === "hard" && !isCustomLevel)
                        mainOperator = '=';
                    else {
                        if (opChance < .85)
                            mainOperator = '=';
                        else
                            mainOperator = '>';
                    }
                    let expr1_str, expr2_str;
                    if (mainOperator === '=') {
                        expr1_str = generateComplexLHS();
                        try {
                            const val1 = safeEval(expr1_str);
                            if (!Number.isInteger(val1) || expr1_str.includes('.')) {
                                generationAttempts++;
                                continue;
                            }
                            expr2_str = String(val1);
                        } catch (e) {
                            generationAttempts++;
                            continue;
                        }
                    } else {
                        expr1_str = generateComplexLHS();
                        expr2_str = generateComplexLHS();
                        try {
                            let val1 = safeEval(expr1_str);
                            let val2 = safeEval(expr2_str);
                            if (!(val1 > val2)) {
                                if (val2 > val1 && (expr2_str + mainOperator + expr1_str).length <= (debugSettings.disableMaxLength ? 9999 : DEFAULT_MAX_EQUATION_LENGTH)) {
                                    [expr1_str, expr2_str] = [expr2_str, expr1_str];
                                } else {
                                    let adjustment = getRandomInt(1, 5);
                                    if (Math.random() < 0.5 && (String(val1 + adjustment) + mainOperator + expr2_str).length <= (debugSettings.disableMaxLength ? 9999 : DEFAULT_MAX_EQUATION_LENGTH)) {
                                        expr1_str = String(val1 + adjustment);
                                    } else if ((expr1_str + mainOperator + String(val2 - adjustment)).length <= (debugSettings.disableMaxLength ? 9999 : DEFAULT_MAX_EQUATION_LENGTH) && val2 - adjustment >= 0) {
                                         expr2_str = String(val2 - adjustment);
                                         if (safeEval(expr1_str) <= safeEval(expr2_str)) {
                                            generationAttempts++;
                                            continue;
                                         }
                                    } else {
                                        generationAttempts++;
                                        continue;
                                    }
                                }
                            }
                        } catch (e) {
                            generationAttempts++;
                            continue;
                        }
                    }

                    if (expr1_str.includes('.') || expr2_str.includes('.')) {
                        generationAttempts++;
                        continue;
                    }
                    equation = `${expr1_str}${mainOperator}${expr2_str}`;

                    const currentMinLen = MIN_EQUATION_LENGTH;
                    const currentMaxLen = debugSettings.disableMaxLength ? 9999 : DEFAULT_MAX_EQUATION_LENGTH;
                    let lengthOk = true;

                    if (debugSettings.lockedLength > 0) {
                        if (equation.length !== debugSettings.lockedLength) lengthOk = false;
                    } else {
                        if (equation.length < currentMinLen || equation.length > currentMaxLen) lengthOk = false;
                    }

                    if (lengthOk && isValidEquation(equation.split(''), true)) {
                        break;
                    }
                    generationAttempts++;
                }

                if (generationAttempts >= maxTotalAttempts || !equation ||
                    (debugSettings.lockedLength > 0 && equation.length !== debugSettings.lockedLength) ||
                    (!debugSettings.lockedLength && (equation.length < MIN_EQUATION_LENGTH || (!debugSettings.disableMaxLength && equation.length > DEFAULT_MAX_EQUATION_LENGTH)))
                   ) {
                    equation = generateFallbackEquation();
                     if (debugSettings.lockedLength > 0 && equation.length !== debugSettings.lockedLength) {
                        showMessage(`调试: 无法生成长度为 ${debugSettings.lockedLength} 的表达式 使用备用表达式 (尝试次数: ${maxTotalAttempts})`, 3000);
                    } else if (generationAttempts >= maxTotalAttempts && (debugSettings.disableMaxLength || debugSettings.lockedLength > DEFAULT_MAX_EQUATION_LENGTH)) {
                        showMessage(`调试: 达到尝试上限 (${maxTotalAttempts}) 仍未生成所需长表达式 使用备用表达式`, 3000);
                    }
                }
                return equation;
            }

            function calculateEquationDifficultyStars(equation) {
                if (!equation || equation.length === 0) return "";
                let score = 0;
                const len = equation.length;
                if (len <= 4) score += 0.5;
                else if (len <= 7) score += 1.5;
                else if (len <= 10) score += 2.5;
                else if (len <= 13) score += 3.5;
                else score += 4.5;

                let operatorCount = 0;
                const operatorScores = { '+': 0.1, '-': 0.1, '*': 0.3, '/': 0.3, '%': 0.6, '^': 0.6, '!': 0.7, 'A': 0.8, '>': 0.2 };
                for (const char of equation) {
                    if (operatorScores[char]) {
                        score += operatorScores[char];
                        operatorCount++;
                    }
                }
                if (operatorCount > 2) score += (operatorCount - 2) * 0.3;

                let parenCount = 0;
                let maxDepth = 0;
                let currentDepth = 0;
                for (const char of equation) {
                    if (char === '(' || char === '[') {
                        parenCount++;
                        currentDepth++;
                        maxDepth = Math.max(maxDepth, currentDepth);
                    } else if (char === ')' || char === ']') {
                        currentDepth--;
                    }
                }
                score += parenCount * 0.3;
                if (maxDepth > 1) score += (maxDepth - 1) * 0.5;

                const uniqueOperatorsAndParens = new Set(equation.split('').filter(c => isNaN(parseInt(c)) && c !== '='));
                score += uniqueOperatorsAndParens.size * 0.2;

                const numbers = equation.match(/\d+/g);
                if (numbers) {
                    let largeNumberBonus = 0;
                    numbers.forEach(numStr => {
                        const num = parseInt(numStr);
                        if (num > 99) largeNumberBonus += 0.7;
                        else if (num > 20) largeNumberBonus += 0.3;
                    });
                    score += Math.min(largeNumberBonus, 1.5);
                }

                if (equation.includes('!') || equation.includes('A') || equation.includes('%') || equation.includes('^')) {
                    score += 0.5;
                }
                if ((equation.includes('!') || equation.includes('A')) && (equation.includes('%') || equation.includes('^'))){
                    score += 0.5;
                }

                let starsNum = 1;
                if (score > 8) starsNum = 5;
                else if (score > 6.5) starsNum = 4;
                else if (score > 4.5) starsNum = 3;
                else if (score > 2.5) starsNum = 2;

                if (len <= 5 && (equation.includes('!') || equation.includes('A') || equation.includes('^') || equation.includes('%')) && starsNum < 2) {
                    starsNum = Math.min(starsNum + 1, 5);
                }
                if (len > 12 && operatorCount <= 2 && parenCount === 0 && starsNum > 3) {
                    starsNum = Math.max(starsNum - 1, 1);
                }
                return '⭐'.repeat(starsNum);
            }

            function formatTime(totalSeconds) {
                const minutes = Math.floor(totalSeconds / 60)
                  , seconds = totalSeconds % 60;
                return `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
            }

            function updateStatusIndicatorText(text, isTimer = false) {
                const indicator = document.getElementById('statusIndicator');
                if (!indicator) return;

                const newFinalText = (isTimer && text.startsWith("进行中:")) ?
                    text
                    : text;

                if (isStatusIndicatorAnimating) {
                    if (isTimer && indicator.classList.contains('timer-active') && indicator.textContent.startsWith("进行中:")) {
                        if(indicator.textContent !== newFinalText) {
                            indicator.classList.add('no-transition');
                            indicator.textContent = newFinalText;
                             requestAnimationFrame(() => indicator.classList.remove('no-transition'));
                        }
                    }
                    return;
                }

                const oldText = indicator.textContent;
                const oldIsTimer = indicator.classList.contains('timer-active');
                const oldIsVisible = indicator.classList.contains('visible');

                const contentChanged = newFinalText !== oldText;
                const typeChanged = isTimer !== oldIsTimer;

                if (isTimer && oldIsTimer && oldIsVisible && contentChanged) {
                    indicator.classList.add('no-transition');
                    indicator.textContent = newFinalText;
                    requestAnimationFrame(() => indicator.classList.remove('no-transition'));
                    return;
                }

                if (contentChanged || typeChanged || (!oldIsVisible && newFinalText.trim() !== "")) {
                    if (oldIsVisible && (contentChanged || typeChanged)) {
                        isStatusIndicatorAnimating = true;
                        indicator.classList.remove('visible');
                        if (statusIndicatorAnimationTimeout) clearTimeout(statusIndicatorAnimationTimeout);
                        statusIndicatorAnimationTimeout = setTimeout(() => {
                            indicator.textContent = newFinalText;
                            indicator.classList.toggle('timer-active', isTimer);
                            requestAnimationFrame(() => {
                                indicator.classList.add('visible');
                                isStatusIndicatorAnimating = false;
                            });
                        }, 150);
                    } else {
                        indicator.textContent = newFinalText;
                        indicator.classList.toggle('timer-active', isTimer);
                        if (!oldIsVisible && newFinalText.trim() !== "") {
                           requestAnimationFrame(() => indicator.classList.add('visible'));
                        } else if (oldIsVisible && newFinalText.trim() === "" && !isTimer) {
                            indicator.classList.remove('visible');
                        }
                    }
                }
            }


            function updateGameTimerDisplay() {
                if (!gameActive || !gameStartTime || isViewingHistoryState) {
                    if (gameTimerInterval) {
                        clearInterval(gameTimerInterval);
                        gameTimerInterval = null;
                    }
                    return;
                }
                elapsedSeconds = Math.floor((Date.now() - gameStartTime) / 1000);
                if (statusIndicator.classList.contains('timer-active')) {
                    let timerText = `进行中: ${formatTime(elapsedSeconds)}`;
                    if (currentEquationStars && !isCustomLevel && !isViewingHistoryState) {
                        timerText += ` ${currentEquationStars}`;
                    }
                    updateStatusIndicatorText(timerText, true);
                }
                 if (debugSettings.suddenDeathTimer && elapsedSeconds >= 30) {
                    handleEndGame(false, 'LOST_SUDDEN_DEATH');
                    showMessage("时间到! 猝死模式失败!", 3000);
                }
            }

            function performLiveStatusUpdate() {
                if (!gameActive || isViewingHistoryState || currentRow >= ROWS) {
                    stopLiveStatusUpdates();
                    return;
                }

                if (debugSettings.vanishingInkMode) {
                    let vanishingText;
                    if (gameStartTime > 0) {
                        vanishingText = `进行中: ${formatTime(elapsedSeconds)}`;
                        if (currentEquationStars && !isCustomLevel && !isViewingHistoryState) vanishingText += ` ${currentEquationStars}`;
                        updateStatusIndicatorText(vanishingText, true);
                    } else {
                        vanishingText = `${difficultySetting[currentDifficulty].name}模式 - ${COLS > 0 ? COLS + '字符' : debugSettings.unknownLengthMode ? '?字符' : targetEquation.length + '字符'}`;
                        if (currentEquationStars && !isCustomLevel && !isViewingHistoryState) vanishingText += ` ${currentEquationStars}`;
                        updateStatusIndicatorText(vanishingText, false);
                    }
                    return;
                }


                const currentInput = guessedEquation.slice(0, currentCol).join('');

                let lhs = currentInput;
                let mainOpIndex = -1;
                let depth = 0;
                for (let i = 0; i < currentInput.length; i++) {
                    const char = currentInput[i];
                    if (char === '(' || char === '[') depth++;
                    else if (char === ')' || char === ']') depth--;
                    else if (depth === 0 && (char === '=' || char === '>')) {
                        mainOpIndex = i;
                        break;
                    }
                }

                if (mainOpIndex !== -1) {
                    lhs = currentInput.substring(0, mainOpIndex);
                }

                const lastCharOfLhs = lhs.trim().slice(-1);
                const requiresOperandAfter = ['+', '-', '*', '/', '%', '^', 'A'];

                if (currentCol === 0 || currentInput.length === 0 || (lhs.length === 0 && mainOpIndex === -1) ||
                    (requiresOperandAfter.includes(lastCharOfLhs)) ||
                    (lhs.length === 1 && (lhs === '(' || lhs === '[' || !/\d/.test(lhs[0])) && !(lhs === '!' || lhs === ')'))) {
                    let defaultText;
                     if (gameStartTime > 0) {
                        defaultText = `进行中: ${formatTime(elapsedSeconds)}`;
                        if (currentEquationStars && !isCustomLevel && !isViewingHistoryState) defaultText += ` ${currentEquationStars}`;
                        updateStatusIndicatorText(defaultText, true);
                    } else {
                        defaultText = `${difficultySetting[currentDifficulty].name}模式 - ${COLS > 0 ? COLS + '字符' : debugSettings.unknownLengthMode ? '?字符' : targetEquation.length + '字符'}`;
                        if (currentEquationStars && !isCustomLevel && !isViewingHistoryState) defaultText += ` ${currentEquationStars}`;
                        updateStatusIndicatorText(defaultText, false);
                    }
                    return;
                }

                try {
                    const result = safeEval(lhs);
                    if (typeof result === 'number' && !isNaN(result)) {
                        let formattedLHS = lhs.replace(/\*/g, '×').replace(/\//g, '÷');
                        let previewText = `${formattedLHS} = ${Number(result.toFixed(3)).toString()}`;
                        if (previewText.length > 35) {
                            previewText = previewText.substring(0, 32) + "...";
                        }
                        updateStatusIndicatorText(previewText, false);
                    } else {
                        let defaultText;
                        if (gameStartTime > 0) {
                            defaultText = `进行中: ${formatTime(elapsedSeconds)}`;
                            if (currentEquationStars && !isCustomLevel && !isViewingHistoryState) defaultText += ` ${currentEquationStars}`;
                            updateStatusIndicatorText(defaultText, true);
                        } else {
                            defaultText = `${difficultySetting[currentDifficulty].name}模式 - ${COLS > 0 ? COLS + '字符' : debugSettings.unknownLengthMode ? '?字符' : targetEquation.length + '字符'}`;
                             if (currentEquationStars && !isCustomLevel && !isViewingHistoryState) defaultText += ` ${currentEquationStars}`;
                            updateStatusIndicatorText(defaultText, false);
                        }
                    }
                } catch (e) {
                    let defaultText;
                    if (gameStartTime > 0) {
                        defaultText = `进行中: ${formatTime(elapsedSeconds)}`;
                        if (currentEquationStars && !isCustomLevel && !isViewingHistoryState) defaultText += ` ${currentEquationStars}`;
                        updateStatusIndicatorText(defaultText, true);
                    } else {
                       defaultText = `${difficultySetting[currentDifficulty].name}模式 - ${COLS > 0 ? COLS + '字符' : debugSettings.unknownLengthMode ? '?字符' : targetEquation.length + '字符'}`;
                        if (currentEquationStars && !isCustomLevel && !isViewingHistoryState) defaultText += ` ${currentEquationStars}`;
                       updateStatusIndicatorText(defaultText, false);
                    }
                }
            }

            function startLiveStatusUpdates() {
                if (!liveStatusUpdateInterval && gameActive && !isViewingHistoryState) {
                    if (gameStartTime > 0 && statusIndicator.classList.contains('timer-active')) {
                    } else {
                         performLiveStatusUpdate();
                    }
                    liveStatusUpdateInterval = setInterval(performLiveStatusUpdate, LIVE_STATUS_UPDATE_INTERVAL_MS);
                }
            }

            function stopLiveStatusUpdates() {
                if (liveStatusUpdateInterval) {
                    clearInterval(liveStatusUpdateInterval);
                    liveStatusUpdateInterval = null;
                }
            }

            
            function initBoard() {
                const board = document.getElementById('board');
                board.innerHTML = '';
                const displayCols = debugSettings.unknownLengthMode ? DEFAULT_MAX_EQUATION_LENGTH : COLS > 0 ? COLS : targetEquation.length;
                board.style.gridTemplateRows = `repeat(${ROWS},1fr)`;

                for (let i = 0; i < ROWS; i++) {
                    const rowDiv = document.createElement('div');
                    rowDiv.className = 'row';
                    rowDiv.style.gridTemplateColumns = `repeat(${displayCols},1fr)`;
                    for (let j = 0; j < displayCols; j++) {
                        const tileDiv = document.createElement('div');
                        tileDiv.className = 'tile tile-new-game-appear';
                        tileDiv.id = `tile-${i}-${j}`;
                        tileDiv.style.animationDelay = `${i * .05 + j * .02}s`;
                        if (debugSettings.unknownLengthMode && (COLS === 0 || j >= COLS) ) {
                             tileDiv.classList.add('unknown-length');
                        }
                        rowDiv.appendChild(tileDiv);
                    }
                    board.appendChild(rowDiv);
                }
                setTimeout(()=>{
                    document.querySelectorAll('.tile-new-game-appear').forEach(t=>t.classList.remove('tile-new-game-appear'));
                }
                , ROWS * .05 * 1e3 + displayCols * .02 * 1e3 + 500);
            }
            function isTouchDevice() {
                return 'ontouchstart'in window || navigator.maxTouchPoints > 0;
            }
            function initKeyboard() {
                const keyboardElement = document.getElementById('keyboard');
                keyboardElement.innerHTML = '';
                keyboardElement.classList.remove('disabled-input', 'true-random-keys');

                const keyLayout = [['1', '2', '3', '4', '5', '6', '7', '8', '9', '0'], ['+', '-', '×', '÷', '%', '^', '>', '!'], ['A', '(', ')', '[', ']', '='], ['AC', '删除', '提交']];

                if (debugSettings.randomKeyboardLayout) {
                    keyboardElement.classList.add('true-random-keys');
                    const allChars = [];
                    keyLayout.forEach(row => row.forEach(key => {
                        if (key !== 'AC' && key !== '删除' && key !== '提交') allChars.push(key);
                    }));
                    allChars.sort(() => Math.random() - 0.5);
                    let charIdx = 0;
                    keyLayout.forEach((row, rIdx) => {
                        keyLayout[rIdx] = row.map(key => {
                            if (key !== 'AC' && key !== '删除' && key !== '提交') {
                                return allChars[charIdx++];
                            }
                            return key;
                        });
                    });
                }


                keyLayout.forEach(rowKeys=>{
                    const rowDiv = document.createElement('div');
                    rowDiv.className = 'keyboard-row';
                    rowKeys.forEach(keyText=>{
                        const key = document.createElement('div');
                        key.className = 'key';
                        key.textContent = keyText;
                        let internalKeyValue = keyText;
                        if (keyText === '×')
                            internalKeyValue = '*';
                        if (keyText === '÷')
                            internalKeyValue = '/';
                        if (keyText === 'AC') {
                            key.classList.add('wide');
                            key.addEventListener('click', handleClearAllCurrentRow);
                        } else if (keyText === '删除') {
                            key.classList.add('wide');
                            key.addEventListener('click', handleDelete);
                        } else if (keyText === '提交') {
                            key.classList.add('super-wide');
                            key.addEventListener('click', handleSubmit);
                        } else {
                            key.dataset.char = internalKeyValue;
                            key.addEventListener('click', event=>handleKeyPress(internalKeyValue, event.currentTarget));
                            if (debugSettings.randomKeyboardLayout) {
                                key.style.setProperty('--random-order', Math.floor(Math.random() * 100));
                            }
                        }
                        addKeyAnimationListeners(key);
                        if (keyTooltips[internalKeyValue]) {
                            key.classList.add('operator-key');
                            const tooltipSpan = document.createElement('span');
                            tooltipSpan.className = 'key-tooltip';
                            tooltipSpan.textContent = keyTooltips[internalKeyValue];
                            key.appendChild(tooltipSpan);
                            key.addEventListener('mouseenter', ()=>{
                                if (!isTouchDevice())
                                    key.classList.add('show-tooltip');
                            }
                            );
                            key.addEventListener('mouseleave', ()=>{
                                if (!isTouchDevice())
                                    key.classList.remove('show-tooltip');
                            }
                            );
                            key.addEventListener('touchstart', e=>{
                                if (isTouchDevice()) {
                                    if (activeTooltipKey && activeTooltipKey !== key)
                                        activeTooltipKey.classList.remove('show-tooltip');
                                    clearTimeout(activeTooltipTimeout);
                                    key.classList.add('show-tooltip');
                                    activeTooltipKey = key;
                                    activeTooltipTimeout = setTimeout(()=>{
                                        if (activeTooltipKey === key) {
                                            key.classList.remove('show-tooltip');
                                            activeTooltipKey = null;
                                        }
                                    }
                                    , 2500);
                                }
                            }
                            , {
                                passive: true
                            });
                        }
                        rowDiv.appendChild(key);
                    }
                    );
                    keyboardElement.appendChild(rowDiv);
                }
                );
                 if (debugSettings.grayKeysUnclickable) {
                    document.querySelectorAll('.key.absent').forEach(k => k.classList.add('disabled-permanently'));
                }
            }
            function addKeyAnimationListeners(keyEl) {
                keyEl.addEventListener('mousedown', ()=>keyEl.classList.add('pressed'));
                keyEl.addEventListener('mouseup', ()=>keyEl.classList.remove('pressed'));
                keyEl.addEventListener('mouseleave', ()=>{
                    keyEl.classList.remove('pressed');
                    if (isTouchDevice() && activeTooltipKey === keyEl)
                        return;
                    keyEl.classList.remove('show-tooltip');
                }
                );
                keyEl.addEventListener('touchstart', e=>{
                    keyEl.classList.add('pressed');
                }
                , {
                    passive: true
                });
                keyEl.addEventListener('touchend', ()=>keyEl.classList.remove('pressed'));
            }
            function resetKeyboardColors() {
                document.querySelectorAll('.key').forEach(k=>k.classList.remove('correct', 'present', 'absent', 'disabled-permanently', 'disabled-view-mode'));
                document.getElementById('keyboard').classList.remove('disabled-input');
            }
            function startGame(newTargetEquation, newDifficultyKey) {
                gameActive = true;
                currentRow = 0;
                currentCol = 0;
                isViewingHistoryState = false;
                viewingHistoryItem = null;
                guessedEquationsHistory = [];
                gameStartTime = 0;
                elapsedSeconds = 0;
                if (gameTimerInterval) {
                    clearInterval(gameTimerInterval);
                    gameTimerInterval = null;
                }
                hintsUsedThisGame = 0;
                gameCountsForStats = true;
                const hintBtn = document.getElementById('hintBtn');
                if (hintBtn) {
                    hintBtn.classList.remove('disabled-permanently');
                    hintBtn.disabled = false;
                }

                stopLiveStatusUpdates();

                enableKeyboardForPlay();
                restartBtn.title = "重新开始/投降";
                restartBtn.innerHTML = '🔄';

                if (newTargetEquation && newDifficultyKey && difficultySetting[newDifficultyKey]) {
                    targetEquation = newTargetEquation;
                    currentDifficulty = newDifficultyKey;
                    isCustomLevel = true;
                    currentEquationStars = calculateEquationDifficultyStars(targetEquation);
                    setHeaderTitleState(quarkModeActive ? 'quark' : 'custom');
                } else if (debugSettings.useCustomExpressionForNextGame && debugSettings.customExpression) {
                    const customExprValid = isValidEquation(debugSettings.customExpression.split(''), true);
                    const exprLen = debugSettings.customExpression.length;
                    const currentMaxLen = debugSettings.disableMaxLength ? 9999 : DEFAULT_MAX_EQUATION_LENGTH;
                    const currentMinLen = MIN_EQUATION_LENGTH;
                    let lengthConstraintOk = true;
                    if (debugSettings.lockedLength > 0) {
                        if (exprLen !== debugSettings.lockedLength) lengthConstraintOk = false;
                    } else {
                        if (exprLen < currentMinLen || exprLen > currentMaxLen) lengthConstraintOk = false;
                    }

                    if (customExprValid && lengthConstraintOk) {
                        targetEquation = debugSettings.customExpression;
                        isCustomLevel = true;
                        currentEquationStars = calculateEquationDifficultyStars(targetEquation);
                        setHeaderTitleState(quarkModeActive ? 'quark' : 'debug');
                        showMessage("调试: 使用自定义表达式!", 1500);
                    } else {
                        if (!customExprValid) showMessage("调试: 自定义表达式无效 生成随机表达式", 2000);
                        else if (!lengthConstraintOk) showMessage("调试: 自定义表达式长度不符 生成随机表达式", 2000);
                        targetEquation = generateRandomEquation();
                        isCustomLevel = false;
                        currentEquationStars = calculateEquationDifficultyStars(targetEquation);
                         if (!quarkModeActive) setHeaderTitleState('idle');
                         else setHeaderTitleState(headerTitleElement.classList.contains('state-quark') ? 'quark' : 'idle');
                    }
                    debugSettings.useCustomExpressionForNextGame = false;
                    if (document.getElementById('debugModal').classList.contains('show')) {
                        document.getElementById('debugCustomExpr').value = "";
                    }
                } else {
                    isCustomLevel = false;
                    const savedDiff = localStorage.getItem('sumzleDifficulty');
                    if (difficultySetting[savedDiff])
                        currentDifficulty = savedDiff;
                    else
                        currentDifficulty = 'medium';
                    targetEquation = generateRandomEquation();
                    currentEquationStars = calculateEquationDifficultyStars(targetEquation);
                    if (!quarkModeActive) setHeaderTitleState('idle');
                    else setHeaderTitleState('quark');
                }

                ROWS = debugSettings.oneTryMode ? 1 : difficultySetting[currentDifficulty].attempts;
                COLS = debugSettings.unknownLengthMode ? 0 : targetEquation.length;

                if(debugSettings.suddenDeathTimer) {
                    gameStartTime = Date.now();
                    elapsedSeconds = 0;
                    gameTimerInterval = setInterval(updateGameTimerDisplay, 1000);
                }

                const displayColsForGuessedArray = debugSettings.unknownLengthMode ? DEFAULT_MAX_EQUATION_LENGTH : COLS > 0 ? COLS : targetEquation.length;
                guessedEquation = Array(displayColsForGuessedArray).fill('');

                initBoard();
                initKeyboard();
                resetKeyboardColors();
                updateDifficultyDisplay();

                let initialStatusText = `${difficultySetting[currentDifficulty].name}模式 - ${COLS > 0 ? COLS + '字符' : debugSettings.unknownLengthMode ? '?字符' : targetEquation.length + '字符'}`;
                if (currentEquationStars && !isCustomLevel && !isViewingHistoryState && !debugSettings.suddenDeathTimer) {
                    initialStatusText += ` ${currentEquationStars}`;
                }
                 updateStatusIndicatorText(initialStatusText, debugSettings.suddenDeathTimer);
                 if (!debugSettings.suddenDeathTimer) startLiveStatusUpdates();


                document.getElementById('exportImageBtn').style.display = 'none';
                document.getElementById('shareLevelBtn').style.display = isCustomLevel || !gameActive ? 'inline-block' : 'none';
                updateBackgroundStyle();
                 let firstNonLockedIndex = 0;
                if (currentRow < ROWS) {
                    for (let i = 0; i < displayColsForGuessedArray; i++) {
                        const tile = document.getElementById(`tile-${currentRow}-${i}`);
                        if (tile && tile.classList.contains('hint-locked')) {
                            firstNonLockedIndex = i + 1;
                        } else {
                            break;
                        }
                    }
                }
                currentCol = firstNonLockedIndex;
            }
            function resetGame() {
                isCustomLevel = false;
                const savedDiff = localStorage.getItem('sumzleDifficulty');
                if (difficultySetting[savedDiff])
                    currentDifficulty = savedDiff;
                else
                    currentDifficulty = 'medium';
                ROWS = difficultySetting[currentDifficulty].attempts;

                
                startGame(null, null);
            }

            function displayDifficultyStatsChart() {
                const bodyStyles = getComputedStyle(document.body);
                const gridColor = bodyStyles.getPropertyValue('--chart-grid-color').trim();
                const tickColor = bodyStyles.getPropertyValue('--chart-tick-color').trim();
                const titleColor = bodyStyles.getPropertyValue('--chart-title-color').trim();
                const legendLabelColor = bodyStyles.getPropertyValue('--chart-legend-label-color').trim();

                const lbls = ['简单', '中等', '困难', '总体'];
                const pD = [stats.byDifficulty.easy.gamesPlayed, stats.byDifficulty.medium.gamesPlayed, stats.byDifficulty.hard.gamesPlayed, stats.total.gamesPlayed];
                const wD = [stats.byDifficulty.easy.gamesWon, stats.byDifficulty.medium.gamesWon, stats.byDifficulty.hard.gamesWon, stats.total.gamesWon];

                const data = {
                    labels: lbls,
                    datasets: [{
                        label: '已玩',
                        data: pD,
                        backgroundColor: currentTheme === 'dark' ? 'rgba(100,130,200,.7)' : 'rgba(201,180,88,.6)',
                        borderColor: currentTheme === 'dark' ? 'rgba(100,130,200,1)' : 'rgba(201,180,88,1)',
                        borderWidth: 1
                    }, {
                        label: '获胜',
                        data: wD,
                        backgroundColor: currentTheme === 'dark' ? 'rgba(80,160,120,.7)' : 'rgba(106,170,100,.6)',
                        borderColor: currentTheme === 'dark' ? 'rgba(80,160,120,1)' : 'rgba(106,170,100,1)',
                        borderWidth: 1
                    }]
                };
                const cfg = {
                    type: 'bar',
                    data: data,
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        scales: {
                            y: { beginAtZero: true, grace: '5%', ticks: { color: tickColor, font: { size: 11 } }, grid: { color: gridColor, drawBorder: false } },
                            x: { ticks: { color: tickColor, font: { size: 12 } }, grid: { display: false, drawBorder: false } }
                        },
                        plugins: {
                            title: { display: true, text: `最佳连胜: ${stats.total.bestStreak} | 当前连胜: ${stats.total.currentStreak}`, font: { size: 14, weight: '500' }, color: titleColor, padding: { top: 5, bottom: 15 } },
                            legend: { labels: { color: legendLabelColor, font: { size: 12 } } },
                            tooltip: {
                                backgroundColor: currentTheme === 'dark' ? 'rgba(54, 57, 63, 0.95)' : 'rgba(248, 249, 250, 0.95)',
                                titleColor: currentTheme === 'dark' ? '#f0f0f0' : '#212529',
                                bodyColor: currentTheme === 'dark' ? '#e0e0e0' : '#495057',
                                borderColor: currentTheme === 'dark' ? bodyStyles.getPropertyValue('--fluent-blue-hover').trim() : bodyStyles.getPropertyValue('--fluent-blue').trim(),
                                borderWidth: 1,
                                padding: 10,
                                displayColors: false,
                                callbacks: {
                                    afterLabel: ctx => {
                                        if (ctx.datasetIndex === 1) {
                                            const pl = pD[ctx.dataIndex], wn = wD[ctx.dataIndex];
                                            return `胜率: ${pl > 0 ? Math.round(wn / pl * 100) : 0}%`;
                                        }
                                    }
                                }
                            }
                        }
                    }
                };
                const chartEl = document.getElementById('statsChartDifficulty');
                if (statsChartDifficultyInstance) statsChartDifficultyInstance.destroy();
                if (chartEl && typeof Chart !== 'undefined') statsChartDifficultyInstance = new Chart(chartEl, cfg);
            }

            function displayStarRatingStatsChart() {
                const gameHistory = JSON.parse(localStorage.getItem('sumzleGameHistory')) || [];
                const starStats = { '⭐': { p: 0, w: 0 }, '⭐⭐': { p: 0, w: 0 }, '⭐⭐⭐': { p: 0, w: 0 }, '⭐⭐⭐⭐': { p: 0, w: 0 }, '⭐⭐⭐⭐⭐': { p: 0, w: 0 } };

                gameHistory.forEach(item => {
                    if (item.countedInStats === false) return;
                    const starsKey = item.stars || calculateEquationDifficultyStars(item.targetEquation);
                    if (starStats[starsKey]) {
                        starStats[starsKey].p++;
                        if (item.status === 'WON') {
                            starStats[starsKey].w++;
                        }
                    }
                });

                const bodyStyles = getComputedStyle(document.body);
                const gridColor = bodyStyles.getPropertyValue('--chart-grid-color').trim();
                const tickColor = bodyStyles.getPropertyValue('--chart-tick-color').trim();
                const titleColor = bodyStyles.getPropertyValue('--chart-title-color').trim();
                const legendLabelColor = bodyStyles.getPropertyValue('--chart-legend-label-color').trim();

                const lbls = Object.keys(starStats);
                const pD = lbls.map(s => starStats[s].p);
                const wD = lbls.map(s => starStats[s].w);

                const data = {
                    labels: lbls,
                    datasets: [{
                        label: '已玩',
                        data: pD,
                        backgroundColor: currentTheme === 'dark' ? 'rgba(180,100,200,.7)' : 'rgba(200,100,180,.6)',
                        borderColor: currentTheme === 'dark' ? 'rgba(180,100,200,1)' : 'rgba(200,100,180,1)',
                        borderWidth: 1
                    }, {
                        label: '获胜',
                        data: wD,
                        backgroundColor: currentTheme === 'dark' ? 'rgba(100,180,120,.7)' : 'rgba(120,200,100,.6)',
                        borderColor: currentTheme === 'dark' ? 'rgba(100,180,120,1)' : 'rgba(120,200,100,1)',
                        borderWidth: 1
                    }]
                };
                 const cfg = {
                    type: 'bar',
                    data: data,
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        scales: {
                            y: { beginAtZero: true, grace: '5%', ticks: { color: tickColor, font: { size: 11 } }, grid: { color: gridColor, drawBorder: false } },
                            x: { ticks: { color: tickColor, font: { size: 12 } }, grid: { display: false, drawBorder: false } }
                        },
                        plugins: {
                            title: { display: true, text: '按关卡星级统计 (计入数据)', font: { size: 14, weight: '500' }, color: titleColor, padding: { top: 5, bottom: 15 } },
                            legend: { labels: { color: legendLabelColor, font: { size: 12 } } },
                            tooltip: {
                                backgroundColor: currentTheme === 'dark' ? 'rgba(54, 57, 63, 0.95)' : 'rgba(248, 249, 250, 0.95)',
                                titleColor: currentTheme === 'dark' ? '#f0f0f0' : '#212529',
                                bodyColor: currentTheme === 'dark' ? '#e0e0e0' : '#495057',
                                borderColor: currentTheme === 'dark' ? bodyStyles.getPropertyValue('--fluent-blue-hover').trim() : bodyStyles.getPropertyValue('--fluent-blue').trim(),
                                borderWidth: 1,
                                padding: 10,
                                displayColors: false,
                                callbacks: {
                                    afterLabel: ctx => {
                                        if (ctx.datasetIndex === 1) {
                                            const pl = pD[ctx.dataIndex], wn = wD[ctx.dataIndex];
                                            return `胜率: ${pl > 0 ? Math.round(wn / pl * 100) : 0}%`;
                                        }
                                    }
                                }
                            }
                        }
                    }
                };
                const chartEl = document.getElementById('statsChartStars');
                if (statsChartStarsInstance) statsChartStarsInstance.destroy();
                if (chartEl && typeof Chart !== 'undefined') statsChartStarsInstance = new Chart(chartEl, cfg);
                 else if (chartEl) {
                     chartEl.innerHTML = '<p style="text-align:center; padding:20px; color:var(--color-text-secondary);">图表库未加载或数据不足</p>';
                 }
            }

            function updateStatsDisplay(showDifficulty = true, showStars = false) {
                const difficultyChartContainer = document.getElementById('statsChartDifficultyContainer');
                const starsChartContainer = document.getElementById('statsChartStarsContainer');

                if (showDifficulty) {
                    difficultyChartContainer.style.display = 'block';
                    starsChartContainer.style.display = 'none';
                    displayDifficultyStatsChart();
                } else if (showStars) {
                    difficultyChartContainer.style.display = 'none';
                    starsChartContainer.style.display = 'block';
                    displayStarRatingStatsChart();
                }

                const gpEl = document.getElementById('gamesPlayed');
                if (gpEl) gpEl.textContent = stats.total.gamesPlayed;
                const gwEl = document.getElementById('gamesWon');
                if (gwEl) gwEl.textContent = stats.total.gamesWon;
                const csEl = document.getElementById('currentStreak');
                if (csEl) csEl.textContent = stats.total.currentStreak;
            }

            document.querySelectorAll('.stats-chart-tabs .stats-tab-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    document.querySelectorAll('.stats-chart-tabs .stats-tab-btn').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    const targetContainerId = btn.dataset.chartTarget;
                    document.querySelectorAll('.stats-chart-container').forEach(container => {
                        container.style.display = container.id === targetContainerId ? 'block' : 'none';
                    });
                    if (targetContainerId === 'statsChartDifficultyContainer') {
                        updateStatsDisplay(true, false);
                    } else if (targetContainerId === 'statsChartStarsContainer') {
                        updateStatsDisplay(false, true);
                    }
                });
            });

            function clearStatistics() {
                showModal('confirmClearStatsModal');
            }
            document.getElementById('executeClearStatsBtn').addEventListener('click', ()=>{
                stats = JSON.parse(JSON.stringify(initialStats));
                saveStats();
                const activeTab = document.querySelector('.stats-chart-tabs .stats-tab-btn.active');
                 if (activeTab && activeTab.dataset.chartTarget === 'statsChartDifficultyContainer') {
                     updateStatsDisplay(true, false);
                 } else if (activeTab && activeTab.dataset.chartTarget === 'statsChartStarsContainer') {
                     updateStatsDisplay(false, true);
                 } else {
                     updateStatsDisplay(true, false);
                 }
                hideModal('confirmClearStatsModal');
                showMessage("统计数据已清空");
            }
            );
            document.getElementById('cancelClearStatsBtn').addEventListener('click', ()=>{
                hideModal('confirmClearStatsModal');
            }
            );
            function handleKeyPress(char, keyElement = null) {
                const displayCols = debugSettings.unknownLengthMode ? DEFAULT_MAX_EQUATION_LENGTH : COLS > 0 ? COLS : targetEquation.length;

                let tempCurrentCol = currentCol;
                while (tempCurrentCol < displayCols) {
                    const tileToCheck = document.getElementById(`tile-${currentRow}-${tempCurrentCol}`);
                    if (tileToCheck && tileToCheck.classList.contains('hint-locked')) {
                        tempCurrentCol++;
                    } else {
                        break;
                    }
                }
                currentCol = tempCurrentCol;

                if (!gameActive || currentCol >= displayCols || isViewingHistoryState || isClearingRowWithAnimation || document.getElementById('keyboard').classList.contains('disabled-input'))
                    return;

                if (keyElement && keyElement.classList.contains('disabled-permanently'))
                    return;

                let charToDisplay = char;
                if (debugSettings.mirrorInputMode && mirrorMap[char]) {
                    charToDisplay = mirrorMap[char];
                }

                playSound('keyPress');
                const tile = document.getElementById(`tile-${currentRow}-${currentCol}`);
                if (!tile) return;

                if (tile.classList.contains('tile-cleared-animation')) {
                    tile.classList.remove('tile-cleared-animation');
                    tile.style.transform = '';
                    tile.style.opacity = '1';
                }

                guessedEquation[currentCol] = charToDisplay;
                tile.classList.add('filled');
                tile.classList.remove('unknown-length');

                const tileForVanishing = tile;
                const charOriginallyTyped = charToDisplay;

                tileForVanishing.textContent = displayChar(charOriginallyTyped);
                tileForVanishing.classList.add('pop');

                if (debugSettings.vanishingInkMode) {
                    tileForVanishing.style.transition = 'none';
                    tileForVanishing.style.opacity = '1';

                    setTimeout(() => {
                        if (tileForVanishing.textContent === displayChar(charOriginallyTyped)) {
                            tileForVanishing.style.transition = 'opacity 0.4s ease-out';
                            tileForVanishing.style.opacity = '0.05';
                        }
                    }, 600);

                    setTimeout(() => {
                        if (tileForVanishing.textContent === displayChar(charOriginallyTyped) ||
                            (tileForVanishing.style.opacity !== '' && parseFloat(tileForVanishing.style.opacity) < 1)) {
                            tileForVanishing.textContent = '';
                        }

                        if (!tileForVanishing.classList.contains('correct') &&
                            !tileForVanishing.classList.contains('present') &&
                            !tileForVanishing.classList.contains('absent')) {
                            tileForVanishing.style.opacity = '1';
                            tileForVanishing.style.transition = 'none';
                        }
                    }, 1000);
                } else {
                }
                setTimeout(() => tileForVanishing.classList.remove('pop'), 200);


                const keyRect = keyElement ? keyElement.getBoundingClientRect() : null;
                const tileRect = tile.getBoundingClientRect();
                if (keyElement && window.getComputedStyle(keyElement).display !== 'none' && keyRect) {
                    const flyingChar = document.createElement('div');
                    flyingChar.textContent = displayChar(charToDisplay);
                    flyingChar.classList.add('flying-char-effect');
                    const keyStyle = window.getComputedStyle(keyElement);
                    flyingChar.style.fontSize = keyStyle.fontSize;
                    flyingChar.style.fontWeight = keyStyle.fontWeight;
                    flyingChar.style.fontFamily = keyStyle.fontFamily;
                    flyingChar.style.padding = keyStyle.padding;
                    flyingChar.style.backgroundColor = keyStyle.backgroundColor;
                    flyingChar.style.color = isEffectivelyDarkMode() ? getComputedStyle(document.documentElement).getPropertyValue('--color-surface').trim() : getComputedStyle(document.documentElement).getPropertyValue('--color-text').trim();
                    flyingChar.style.borderRadius = keyStyle.borderRadius;
                    flyingChar.style.left = `${keyRect.left}px`;
                    flyingChar.style.top = `${keyRect.top}px`;
                    flyingChar.style.width = `${keyRect.width}px`;
                    flyingChar.style.height = `${keyRect.height}px`;
                    document.body.appendChild(flyingChar);
                    requestAnimationFrame(() => {
                        const targetLeft = tileRect.left + (tileRect.width - keyRect.width) / 2;
                        const targetTop = tileRect.top + (tileRect.height - keyRect.height) / 2;
                        const translateX = targetLeft - keyRect.left;
                        const translateY = targetTop - keyRect.top;
                        flyingChar.style.transform = `translate(${translateX}px, ${translateY}px) scale(.5)`;
                        flyingChar.style.opacity = '0';
                    });
                    flyingChar.addEventListener('transitionend', () => {
                        if (flyingChar.parentElement)
                            flyingChar.parentElement.removeChild(flyingChar);
                    }, {
                        once: true
                    });
                }
                currentCol++;
                startLiveStatusUpdates();
            }
            function handleClearAllCurrentRow() {
                if (!gameActive || currentCol === 0 || isViewingHistoryState || isClearingRowWithAnimation || document.getElementById('keyboard').classList.contains('disabled-input'))
                    return;

                stopLiveStatusUpdates();

                isClearingRowWithAnimation = true;
                document.getElementById('keyboard').classList.add('disabled-input');
                playSound('keyPress');

                let clearedCount = 0;
                for (let col = currentCol - 1; col >= 0; col--) {
                    const tile = document.getElementById(`tile-${currentRow}-${col}`);
                    if (tile && tile.classList.contains('filled') && !tile.classList.contains('hint-locked')) {
                        setTimeout(()=>{
                            tile.textContent = '';
                            tile.classList.remove('filled');
                            tile.style.opacity = '1';
                            tile.style.transform = '';
                            tile.style.transition = 'none';
                            if (debugSettings.unknownLengthMode && (COLS === 0 || col >= COLS)) tile.classList.add('unknown-length');
                            tile.classList.add('tile-cleared-animation');
                            setTimeout(()=>tile.classList.remove('tile-cleared-animation'), 150);
                        }
                        , clearedCount * 30);
                        guessedEquation[col] = '';
                        clearedCount++;
                    }
                }
                const totalAnimationTime = clearedCount > 0 ? (clearedCount - 1) * 30 + 150 : 0;

                let firstNonLockedIndex = 0;
                const displayCols = debugSettings.unknownLengthMode ? DEFAULT_MAX_EQUATION_LENGTH : COLS > 0 ? COLS : targetEquation.length;
                for (let i = 0; i < displayCols; i++) {
                    const tile = document.getElementById(`tile-${currentRow}-${i}`);
                    if (tile && tile.classList.contains('hint-locked')) {
                        firstNonLockedIndex = i + 1;
                    } else {
                        break;
                    }
                }
                currentCol = firstNonLockedIndex;


                setTimeout(()=>{
                    isClearingRowWithAnimation = false;
                    document.getElementById('keyboard').classList.remove('disabled-input');
                    performLiveStatusUpdate();
                }
                , totalAnimationTime);
            }
            function handleDelete() {
                if (!gameActive || isClearingRowWithAnimation || document.getElementById('keyboard').classList.contains('disabled-input') || isViewingHistoryState)
                    return;

                let targetCol = currentCol - 1;
                while (targetCol >= 0) {
                    const tileToCheck = document.getElementById(`tile-${currentRow}-${targetCol}`);
                    if (tileToCheck && tileToCheck.classList.contains('hint-locked')) {
                        targetCol--;
                    } else {
                        break;
                    }
                }

                if (targetCol < 0) return;
                currentCol = targetCol;

                playSound('keyPress');
                guessedEquation[currentCol] = '';
                const tile = document.getElementById(`tile-${currentRow}-${currentCol}`);
                if (tile.classList.contains('tile-cleared-animation')) {
                    tile.classList.remove('tile-cleared-animation');
                }
                tile.classList.add('tile-cleared-animation');
                setTimeout(() => {
                    tile.textContent = '';
                    tile.classList.remove('filled');
                    tile.classList.remove('tile-cleared-animation');
                    tile.style.opacity = '1';
                    tile.style.transform = '';
                    if (debugSettings.unknownLengthMode && (COLS === 0 || currentCol >= COLS) ) tile.classList.add('unknown-length');
                }, 150);


                if (currentCol === 0) {
                    let defaultText;
                    if (gameStartTime > 0) {
                        defaultText = `进行中: ${formatTime(elapsedSeconds)}`;
                        if (currentEquationStars && !isCustomLevel && !isViewingHistoryState) defaultText += ` ${currentEquationStars}`;
                        updateStatusIndicatorText(defaultText, true);
                    } else {
                        defaultText = `${difficultySetting[currentDifficulty].name}模式 - ${COLS > 0 ? COLS + '字符' : debugSettings.unknownLengthMode ? '?字符' : targetEquation.length + '字符'}`;
                        if (currentEquationStars && !isCustomLevel && !isViewingHistoryState) defaultText += ` ${currentEquationStars}`;
                        updateStatusIndicatorText(defaultText, false);
                    }
                } else {
                    performLiveStatusUpdate();
                }
            }
            function safeEval(expr) {
                let safeExpr = expr;
                for (let k = 0; k < 3; k++)
                    safeExpr = safeExpr.replace(/\[(.*?)\]/g, (match,innerExpr)=>`truncate((${innerExpr}))`);
                
                for (let i = 0; i < 3; i++) {
                    safeExpr = safeExpr.replace(/(\d+)A(\d+)/g, "permutation($1,$2)");
                    safeExpr = safeExpr.replace(/((\d+(\.\d+)?)|(\(.*\))|(truncate\(.*\))|(permutation\(.*\)))!/g, (match, term) => `factorial(${term})`);
                    
                    safeExpr = safeExpr.replace(/\((.+?)\)A(\d+)/g, (match,innerExpr,n)=>`permutation((${innerExpr}),${n})`);
                    safeExpr = safeExpr.replace(/(\d+)A\((.+?)\)/g, (match,m,innerExpr)=>`permutation(${m},(${innerExpr}))`);
                    safeExpr = safeExpr.replace(/\((.+?)\)A\((.+?)\)/g, (match,innerM,innerN)=>`permutation((${innerM}),(${innerN}))`);
                }
                safeExpr = safeExpr.replace(/\^/g, '**');
                const evalAllowedChars = /^[0-9+\-*/%()!^*.<>\sacefilmoprtun]+$/i;
                if (!evalAllowedChars.test(safeExpr.replace(/,/g, '')))
                    throw new Error("Invalid chars for eval");
                try {
                    return Function('factorial', 'permutation', 'truncate', 'return (' + safeExpr + ')')(window.factorial, window.permutation, Math.trunc);
                } catch (e) {
                    throw e;
                }
            }
            function checkBrackets(exprString) {
                const stack = []
                  , map = {
                    '(': ')',
                    '[': ']'
                };
                for (let char of exprString) {
                    if (char === '(' || char === '[')
                        stack.push(char);
                    else if (char === ')' || char === ']') {
                        if (stack.length === 0)
                            return false;
                        const lastOpen = stack.pop();
                        if (map[lastOpen] !== char)
                            return false;
                    }
                }
                return stack.length === 0;
            }
            function checkModuloOperation(exprString) {
                const parts = exprString.split('%');
                if (parts.length > 1) {
                    for (let i = 1; i < parts.length; i++) {
                        let divisorPart = ""
                          , depth = 0;
                        for (let j = 0; j < parts[i].length; j++) {
                            const char = parts[i][j];
                            if (char === '(' || char === '[')
                                depth++;
                            else if (char === ')' || char === ']')
                                depth--;
                            if (depth < 0)
                                break;
                            divisorPart += char;
                            if (depth === 0 && (j === parts[i].length - 1 || !'0123456789.()[]'.includes(parts[i][j + 1])))
                                break;
                        }
                        if (divisorPart) {
                            try {
                                const divVal = safeEval(divisorPart);
                                if (divVal === 0 || !Number.isInteger(divVal))
                                    return false;
                            } catch (e) {
                                return false;
                            }
                        } else
                            return false;
                    }
                }
                return true;
            }
            function isValidEquation(equationArray, isGenerationContext=false) {
                const cleanEquation = equationArray.join('');
                if (!isGenerationContext && cleanEquation.includes('.')) {
                    showMessage("输入不能包含小数点");
                    return false;
                }
                if (!isGenerationContext && /(?<![\.\d])0\d+/.test(cleanEquation)) {
                    showMessage("数字不能以0开头 (除非是0本身)");
                    return false;
                }
                if (!isGenerationContext && !checkModuloOperation(cleanEquation)) {
                    showMessage("取模运算中除数不能为0或小数");
                    return false;
                }
                let mainOp = null
                  , mainOpIndex = -1
                  , depth = 0;
                for (let i = 0; i < cleanEquation.length; i++) {
                    const char = cleanEquation[i];
                    if (char === '(' || char === '[')
                        depth++;
                    else if (char === ')' || char === ']')
                        depth--;
                    else if (depth === 0 && (char === '=' || char === '>')) {
                        if (mainOp !== null) {
                            if (!isGenerationContext)
                                showMessage("只能有一个主操作符");
                            return false;
                        }
                        mainOp = char;
                        mainOpIndex = i;
                    }
                }
                if (!mainOp) {
                    if (!isGenerationContext)
                        showMessage("必须包含 = 或 >");
                    return false;
                }
                const leftSide = cleanEquation.substring(0, mainOpIndex)
                  , rightSide = cleanEquation.substring(mainOpIndex + 1);
                if (leftSide.length === 0 || rightSide.length === 0) {
                    if (!isGenerationContext)
                        showMessage("操作符两边需有表达式");
                    return false;
                }
                if (!checkBrackets(leftSide) || !checkBrackets(rightSide)) {
                    if (!isGenerationContext)
                        showMessage("括号不匹配");
                    return false;
                }
                try {
                    const evalLeft = safeEval(leftSide)
                      , evalRight = safeEval(rightSide);
                    if (typeof evalLeft !== 'number' || typeof evalRight !== 'number' || isNaN(evalLeft) || isNaN(evalRight)) {
                        if (!isGenerationContext)
                            showMessage("表达式计算结果无效");
                        return false;
                    }
                    let statementTrue = false;
                    if (mainOp === '=')
                        statementTrue = Math.abs(evalLeft - evalRight) < .0001;
                    else if (mainOp === '>')
                        statementTrue = evalLeft > evalRight;
                    if (!statementTrue) {
                        if (!isGenerationContext)
                            showMessage("等式/不等式不成立");
                        return false;
                    }
                    if (!Number.isInteger(evalLeft) || !Number.isInteger(evalRight)) {
                        if (Math.abs(evalLeft - Math.round(evalLeft)) > .0001 || Math.abs(evalRight - Math.round(evalRight)) > .0001) {
                            if (!isGenerationContext)
                                showMessage("结果必须为整数");
                            return false;
                        }
                    }
                } catch (e) {
                    if (!isGenerationContext)
                        showMessage(`无效表达式: ${e.message}`);
                    return false;
                }
                return true;
            }
            function triggerConfetti() {
                const confettiContainer = document.getElementById('confettiOverlay');
                if (!confettiContainer)
                    return;
                for (let i = 0; i < 60; i++) {
                    const confettiPiece = document.createElement('div');
                    confettiPiece.classList.add('confetti-piece');
                    confettiPiece.style.width = `${getRandomInt(6, 12)}px`;
                    confettiPiece.style.height = confettiPiece.style.width;
                    confettiPiece.style.backgroundColor = `hsl(${Math.random() * 360},100%,70%)`;
                    confettiPiece.style.left = `${Math.random() * 100}%`;
                    confettiPiece.style.top = `${-20 - Math.random() * 30}%`;
                    confettiPiece.style.opacity = '0';
                    confettiPiece.style.transform = `rotate(${Math.random() * 360}deg)`;
                    const animationDuration = Math.random() * 2 + 4;
                    confettiPiece.style.transitionDuration = `${animationDuration}s,${animationDuration}s,${animationDuration * .4}s`;
                    confettiContainer.appendChild(confettiPiece);
                    setTimeout(()=>{
                        confettiPiece.style.opacity = '1';
                        confettiPiece.style.top = '110%';
                        confettiPiece.style.transform = `rotate(${Math.random() * 720 + 360}deg) translateX(${Math.random() * 150 - 75}px)`;
                    }
                    , 50 + Math.random() * 100);
                    setTimeout(()=>{
                        if (confettiPiece.parentElement)
                            confettiPiece.parentElement.removeChild(confettiPiece);
                    }
                    , animationDuration * 1e3 + 200);
                }
            }
            let messageTimeout;
            function handleEndGame(isWin, statusString) {
                gameActive = false;
                if (gameTimerInterval) {
                    clearInterval(gameTimerInterval);
                    gameTimerInterval = null;
                }
                if (debugSettings.suddenDeathIntervalId) {
                    clearInterval(debugSettings.suddenDeathIntervalId);
                    debugSettings.suddenDeathIntervalId = null;
                }

                stopLiveStatusUpdates();
                const hintBtn = document.getElementById('hintBtn');
                if (hintBtn) {
                    hintBtn.classList.add('disabled-permanently');
                    hintBtn.disabled = true;
                }

                let finalMessage = "";
                const displayTargetEquation = targetEquation.replace(/\*/g, '×').replace(/\//g, '÷');
                let finalStatusText;

                if (isWin) {
                    playSound('success');
                    if (quarkModeActive) {
                    setupTitleSpans(ORIGINAL_TITLE_TEXT);
                    if (titleFallAnimation.originalComputedTransition) {
                        headerTitleElement.style.transition = titleFallAnimation.originalComputedTransition;
                    } else {
                         headerTitleElement.style.transition = 'top .8s cubic-bezier(0.6, -0.28, 0.735, 0.045), opacity .5s ease-out';
                    }
                    quarkModeActive = false;
                    sumzleEasterEggActivated = false;
                    sumzleTitleClickCount = 0;
                    quarkDebugClickCount = 0;
                    headerTitleElement.style.top = titleFallAnimation.originalComputedTop;
                    headerTitleElement.style.transform = 'translateX(-50%)';
                    headerTitleElement.style.opacity = '1';
                    titleFallAnimation.active = false;
                    headerTitleElement.style.pointerEvents = 'auto';
                }
                    setHeaderTitleState(quarkModeActive ? 'quark' : 'win');
                    if (gameCountsForStats && (!isCustomLevel || isViewingHistoryState)) {
                        stats.total.gamesPlayed++;
                        stats.total.gamesWon++;
                        stats.total.currentStreak++;
                        stats.total.bestStreak = Math.max(stats.total.bestStreak, stats.total.currentStreak);
                        stats.byDifficulty[currentDifficulty].gamesPlayed++;
                        stats.byDifficulty[currentDifficulty].gamesWon++;
                        saveStats();
                    }
                    finalMessage = `恭喜你猜对了！ 🎉`;
                    finalStatusText = `胜利!`;
                    if (elapsedSeconds > 0) finalStatusText += ` 用时: ${formatTime(elapsedSeconds)}`;
                    if (currentEquationStars && !isCustomLevel && !isViewingHistoryState) {
                        finalStatusText += ` ${currentEquationStars}`;
                    }
                    updateStatusIndicatorText(finalStatusText);
                    triggerConfetti();
                    document.getElementById('exportImageBtn').style.display = 'inline-block';
                    document.getElementById('shareLevelBtn').style.display = 'inline-block';
                    if (sumzleEasterEggActivated && !quarkModeActive && !titleFallAnimation.active) {
                       if (!titleFallAnimation.originalComputedTop) {
                           titleFallAnimation.originalComputedTop = getComputedStyle(headerTitleElement).top;
                       }
                        startTitleFallAnimation(headerTitleElement, 'sumzle-fall', ()=>{
                            triggerQuarkModeAfterFall();
                        });
                    }
                } else {
                    playSound('failure');
                    setHeaderTitleState(quarkModeActive ? 'quark' : 'lose');
                     if (gameCountsForStats && (!isCustomLevel || isViewingHistoryState)) {
                        stats.total.gamesPlayed++;
                        stats.total.currentStreak = 0;
                        stats.byDifficulty[currentDifficulty].gamesPlayed++;
                        saveStats();
                    }
                    if (statusString === 'SURRENDERED')
                        finalMessage = `已放弃。答案: ${displayTargetEquation} 🙁`;
                     else if (statusString === 'LOST_SUDDEN_DEATH')
                        finalMessage = `时间到! 答案: ${displayTargetEquation} 💀`;
                    else
                        finalMessage = `游戏结束! 答案: ${displayTargetEquation} 🙁`;

                    finalStatusText = `失败`;
                    if (elapsedSeconds > 0) finalStatusText += ` 用时: ${formatTime(elapsedSeconds)}`;
                     if (currentEquationStars && !isCustomLevel && !isViewingHistoryState) {
                        finalStatusText += ` ${currentEquationStars}`;
                    }
                    updateStatusIndicatorText(finalStatusText);
                    document.getElementById('exportImageBtn').style.display = 'none';
                    document.getElementById('shareLevelBtn').style.display = 'inline-block';
                }
                showMessage(finalMessage, statusString === 'SURRENDERED' ? 3e3 : 4e3);
                updateStatsDisplay(true, false);
                updateBackgroundStyle();

                const historyRecordDelay = (COLS > 0 ? COLS * 100 : currentCol * 100) + 500;
                const modalDelay = historyRecordDelay + 100;

                setTimeout(() => {
                    recordGameInHistory(isWin, statusString);
                }, historyRecordDelay);

                setTimeout(() => showModal('gameOverModal', isWin), modalDelay);
            }
            function checkGuess(effectiveCols) {
                let guessChars = guessedEquation.slice(0, effectiveCols);
                let actualTargetEquationString = targetEquation;
                let targetCharsCopy = [...actualTargetEquationString];

                const resultStates = Array(effectiveCols).fill('absent');

                if (debugSettings.misleadingFeedbackRate > 0 && Math.random() * 100 < debugSettings.misleadingFeedbackRate) {
                    for (let i = 0; i < effectiveCols; i++) {
                        const rand = Math.random();
                        if (rand < 0.33) resultStates[i] = 'correct';
                        else if (rand < 0.66) resultStates[i] = 'present';
                        else resultStates[i] = 'absent';
                    }
                } else {
                    for (let i = 0; i < effectiveCols; i++) {
                         if (i >= targetCharsCopy.length) { resultStates[i] = 'absent'; continue; }
                        const tile = document.getElementById(`tile-${currentRow}-${i}`);
                        if (tile && tile.classList.contains('hint-locked') && tile.classList.contains('correct')) {
                             resultStates[i] = 'correct';
                             if (i < targetCharsCopy.length) targetCharsCopy[i] = null;
                             continue;
                        }
                        if (guessChars[i] === targetCharsCopy[i]) {
                            resultStates[i] = 'correct';
                            targetCharsCopy[i] = null;
                        }
                    }
                    for (let i = 0; i < effectiveCols; i++) {
                         if (i >= targetEquation.length && resultStates[i] === 'absent') continue; 
                        const tile = document.getElementById(`tile-${currentRow}-${i}`);
                         if (tile && tile.classList.contains('hint-locked') && tile.classList.contains('correct')) {
                             continue;
                         }
                        if (resultStates[i] !== 'correct') {
                            const indexInTarget = targetCharsCopy.indexOf(guessChars[i]);
                            if (indexInTarget !== -1) {
                                resultStates[i] = 'present';
                                targetCharsCopy[indexInTarget] = null;
                            }
                        }
                    }
                }


                const boardRow = document.querySelector(`.row:nth-child(${currentRow + 1})`);
                if (boardRow) {
                    const tiles = boardRow.children;
                    const displayColsForFlip = effectiveCols;

                    for (let i = 0; i < displayColsForFlip; i++) {
                        const tile = tiles[i];
                        if (tile) {
                            if (tile.classList.contains('hint-locked')) tile.classList.remove('hint-locked');
                             setTimeout(()=>{
                                tile.classList.add('flip-reveal');
                                setTimeout(()=>{
                                    tile.classList.remove('absent', 'present', 'correct', 'filled', 'unknown-length');
                                    if (i < resultStates.length) {
                                        tile.classList.add(resultStates[i]);
                                    } else {
                                        tile.classList.add('absent');
                                    }
                                    tile.style.borderColor = '';
                                } , 350);
                            } , i * 100);
                        }
                    }
                }
                updateKeyboardColors(guessChars, resultStates.slice(0, guessChars.length));
            }
            function updateKeyboardColors(chars, results) {
                if (debugSettings.blindMode) return;

                for (let i = 0; i < chars.length; i++) {
                    const char = chars[i]
                      , result = results[i];
                    if (!char)
                        continue;
                    document.querySelectorAll(`.key[data-char="${char}"]`).forEach(key=>{
                        const kcl = key.classList;
                        if (char === '>' && result === 'absent' && !kcl.contains('correct') && !kcl.contains('present')) {
                            kcl.add('disabled-permanently');
                            kcl.remove('present', 'correct', 'absent');
                            return;
                        }
                        if (kcl.contains('disabled-permanently'))
                            return;
                        if (result === 'correct') {
                            kcl.remove('present', 'absent');
                            kcl.add('correct');
                        } else if (result === 'present' && !kcl.contains('correct')) {
                            kcl.remove('absent');
                            kcl.add('present');
                        } else if (result === 'absent' && !kcl.contains('correct') && !kcl.contains('present')) {
                            kcl.add('absent');
                             if (debugSettings.grayKeysUnclickable) {
                                kcl.add('disabled-permanently');
                            }
                        }
                    }
                    );
                }
            }
            function showMessage(text, duration=2e3) {
                const msgEl = document.getElementById('message');
                clearTimeout(messageTimeout);
                msgEl.textContent = text;
                msgEl.classList.remove('show-message');
                void msgEl.offsetWidth;
                msgEl.classList.add('show-message');
                messageTimeout = setTimeout(()=>msgEl.classList.remove('show-message'), duration);
            }
            function showModal(modalId, isWinArgForGameOver) {
                const modal = document.getElementById(modalId);
                if (!modal)
                    return;
                if (modalId === 'gameOverModal') {
                    const title = document.getElementById('gameOverTitle')
                      , msg = document.getElementById('gameOverMessage')
                      , displayTargetEquation = targetEquation.replace(/\*/g, '×').replace(/\//g, '÷');
                    if (isWinArgForGameOver) {
                        title.innerHTML = '🏆 恭喜！🏆';
                        msg.textContent = `你用了 ${currentRow + 1} 次猜中: ${displayTargetEquation}`;
                    } else {
                        title.innerHTML = '💔 游戏结束 💔';
                        msg.textContent = `正确答案: ${displayTargetEquation}`;
                    }
                } else if (modalId === 'debugModal') {
                     setHeaderTitleState('debug');
                }
                modal.style.display = 'flex';
                void modal.offsetWidth;
                modal.classList.add('show');
            }
            function hideModal(modalId) {
                const modal = document.getElementById(modalId);
                if (!modal || !modal.classList.contains('show'))
                    return;
                modal.classList.remove('show');
                setTimeout(()=>modal.style.display = 'none', 350);
                if (modalId === 'debugModal') {
                    const currentHeaderStateClass = Array.from(headerTitleElement.classList).find(c=>c.startsWith('state-'));
                    const currentHeaderState = currentHeaderStateClass ? currentHeaderStateClass.replace('state-', '') : 'idle';

                    if(quarkModeActive){
                        if (currentHeaderState === 'win' || currentHeaderState === 'lose') {
                            setHeaderTitleState(currentHeaderState);
                        } else {
                            setHeaderTitleState('quark');
                        }
                    } else {
                         if (currentHeaderState === 'win' || currentHeaderState === 'lose') {
                            setHeaderTitleState(currentHeaderState);
                        } else {
                             setHeaderTitleState('idle');
                        }
                    }
                }
            }
            function saveStats() {
                localStorage.setItem('sumzleStats', JSON.stringify(stats));
            }
            function saveDifficulty() {
                localStorage.setItem('sumzleDifficulty', currentDifficulty);
            }
            document.getElementById('newGameBtn').addEventListener('click', ()=>{
                hideModal('gameOverModal');
                resetGame();
            }
            );
            restartBtn.addEventListener('click', handleRestartOrExitView);
            function handleRestartOrExitView() {
                if (isViewingHistoryState)
                    exitHistoryView();
                else {
                    if (gameActive && (currentRow > 0 || currentCol > 0 || isCustomLevel))
                        showModal('surrenderModal');
                    else
                        resetGame();
                }
            }
            document.getElementById('confirmSurrenderBtn').addEventListener('click', ()=>{
                hideModal('surrenderModal');
                handleEndGame(false, 'SURRENDERED');
            }
            );
            document.getElementById('cancelSurrenderBtn').addEventListener('click', ()=>hideModal('surrenderModal'));
            const menuToggleBtn = document.getElementById('menuToggleBtn')
              , headerButtonsGroup = document.getElementById('headerButtonsGroup');
            if (menuToggleBtn)
                menuToggleBtn.addEventListener('click', event=>{
                    event.stopPropagation();
                    headerButtonsGroup.classList.toggle('show-menu');
                    menuToggleBtn.classList.toggle('active');
                }
                );
            document.addEventListener('click', event=>{
                if (headerButtonsGroup && headerButtonsGroup.classList.contains('show-menu') && !headerButtonsGroup.contains(event.target) && event.target !== menuToggleBtn) {
                    headerButtonsGroup.classList.remove('show-menu');
                    if (menuToggleBtn)
                        menuToggleBtn.classList.remove('active');
                }
                if (activeTooltipKey && isTouchDevice() && event.target !== activeTooltipKey && !activeTooltipKey.contains(event.target)) {
                    clearTimeout(activeTooltipTimeout);
                    activeTooltipKey.classList.remove('show-tooltip');
                    activeTooltipKey = null;
                }
            }
            );
            document.getElementById('settingsBtn').addEventListener('click', ()=>{
                showModal('settingsModal');
            }
            );
            document.getElementById('closeSettingsBtn').addEventListener('click', ()=>hideModal('settingsModal'));
            document.getElementById('statsBtn').addEventListener('click', ()=>{
                const activeTab = document.querySelector('.stats-chart-tabs .stats-tab-btn.active');
                if (activeTab && activeTab.dataset.chartTarget === 'statsChartStarsContainer') {
                    updateStatsDisplay(false, true);
                } else {
                    updateStatsDisplay(true, false);
                }
                showModal('statsModal');
            }
            );
            document.getElementById('closeStatsBtn').addEventListener('click', ()=>hideModal('statsModal'));
            document.getElementById('clearStatsBtn').addEventListener('click', clearStatistics);
            document.querySelectorAll('.difficulty-btn').forEach(btn=>{
                btn.addEventListener('click', ()=>{
                    isCustomLevel = false;
                    currentDifficulty = btn.dataset.difficulty;
                    ROWS = difficultySetting[currentDifficulty].attempts;
                    saveDifficulty();
                    resetGame();
                    hideModal('settingsModal');
                }
                );
            }
            );
            document.addEventListener('keydown', e=>{
                let activeModalId = null;
                document.querySelectorAll('.modal.show').forEach(m=>activeModalId = m.id);
                if (e.key === 'Escape' && activeModalId) {
                    e.preventDefault();
                    if (activeModalId === 'debugModal' && document.activeElement.tagName === 'TEXTAREA' && document.activeElement.closest('.debug-option')) {

                    } else {
                        hideModal(activeModalId);
                    }
                    return;
                }
                const isTypingInModalInput = (activeModalId === 'loadLevelModal' && document.activeElement === document.getElementById('levelCodeInput')) ||
                                        (activeModalId === 'debugModal' && (document.activeElement.tagName === 'TEXTAREA' || document.activeElement.type === 'number' || document.activeElement.type === 'text' || document.activeElement.type === 'color'));

                if (activeModalId && !isTypingInModalInput && e.key !== 'Enter')
                    return;
                 if (activeModalId && isTypingInModalInput && e.key === 'Enter' && document.activeElement.tagName === 'TEXTAREA') {
                 } else if (validChars.includes(e.key) && !e.ctrlKey && !e.metaKey && !e.altKey && e.key.length === 1) {
                    if (!activeModalId || (activeModalId && !isTypingInModalInput)) {
                        e.preventDefault();
                        const keyElement = document.querySelector(`.key[data-char="${e.key}"]`);
                        handleKeyPress(e.key, keyElement);
                    }
                } else if (e.key === 'Backspace') {
                     if (!activeModalId || (activeModalId && !isTypingInModalInput)) {
                        e.preventDefault();
                        handleDelete();
                    }
                } else if (e.key === 'Enter') {
                    e.preventDefault();
                    if (activeModalId === 'gameOverModal')
                        document.getElementById('newGameBtn').click();
                    else if (activeModalId === 'settingsModal')
                        document.getElementById('closeSettingsBtn').click();
                    else if (activeModalId === 'statsModal')
                        document.getElementById('closeStatsBtn').click();
                    else if (activeModalId === 'loadLevelModal' && !isTypingInModalInput)
                        document.getElementById('submitLoadLevelBtn').click();
                    else if (activeModalId === 'surrenderModal')
                        document.getElementById('confirmSurrenderBtn').click();
                    else if (activeModalId === 'confirmClearStatsModal')
                        document.getElementById('executeClearStatsBtn').click();
                    else if (activeModalId === 'historyModal')
                        document.getElementById('closeHistoryModalBtn').click();
                    else if (activeModalId === 'confirmClearHistoryModal')
                        document.getElementById('executeClearHistoryBtn').click();
                    else if (activeModalId === 'confirmNukeModal')
                        document.getElementById('executeNukeBtn').click();
                    else if (activeModalId === 'hintConfirmationModal')
                        document.getElementById('confirmUseHintBtn').click();
                    else if (activeModalId === 'debugModal' && !isTypingInModalInput)
                        document.getElementById('applyDebugSettingsBtn').click();
                    else if (gameActive && !isViewingHistoryState)
                        handleSubmit();
                }
            }
            );
            function captureFinalBoardRender() {
                const render = [];
                let rowsToCapture = gameActive ? currentRow + 1 : ROWS;
                if (!gameActive) {
                     rowsToCapture = guessedEquationsHistory.length > 0 ? guessedEquationsHistory.length : ROWS;
                     if (currentRow === ROWS -1 && guessedEquationsHistory.length < ROWS) {
                         rowsToCapture = ROWS;
                     }
                }


                let finalColsToCapture;
                let gameWasUnknownLength = debugSettings.unknownLengthMode;

                if (gameWasUnknownLength) {
                    let maxLen = 0;
                    guessedEquationsHistory.forEach(rowStr => {
                        if (rowStr) maxLen = Math.max(maxLen, rowStr.length);
                    });

                    let currentEffectiveLength = 0;
                    const currentProcessingRow = (!gameActive && guessedEquationsHistory.length === currentRow + 1) ? currentRow : 
                                                 (gameActive ? currentRow : -1); 

                    if (currentProcessingRow !== -1) {
                        for (let i = (guessedEquation.length > 0 ? guessedEquation.length - 1 : DEFAULT_MAX_EQUATION_LENGTH - 1); i >= 0; i--) {
                            const tile = document.getElementById(`tile-${currentProcessingRow}-${i}`);
                            if ((i < guessedEquation.length && guessedEquation[i] && guessedEquation[i].trim() !== '') || (tile && tile.textContent.trim() !== '')) {
                                currentEffectiveLength = i + 1;
                                break;
                            }
                        }
                         maxLen = Math.max(maxLen, currentEffectiveLength);
                    }


                    if (!gameActive && targetEquation) {
                        maxLen = Math.max(maxLen, targetEquation.length);
                    }
                    if (maxLen === 0) {
                        const firstBoardRowDOM = document.getElementById('board')?.querySelector('.row');
                        maxLen = (firstBoardRowDOM && firstBoardRowDOM.children.length > 0) ? firstBoardRowDOM.children.length : DEFAULT_MAX_EQUATION_LENGTH;
                    }
                    finalColsToCapture = maxLen;
                } else {
                    finalColsToCapture = COLS > 0 ? COLS : targetEquation.length;
                }
                finalColsToCapture = Math.max(1, finalColsToCapture);

                for (let r = 0; r < rowsToCapture; r++) {
                    if (r >= ROWS) break;
                    const rowRender = [];
                    let actualLengthOfThisGuessedRow = 0;

                    if (r < guessedEquationsHistory.length) {
                        actualLengthOfThisGuessedRow = guessedEquationsHistory[r] ? guessedEquationsHistory[r].length : 0;
                    } else if (r === currentRow && (gameActive || (!gameActive && guessedEquationsHistory.length === r) ) ) {
                         for (let i = (guessedEquation.length > 0 ? guessedEquation.length -1 : DEFAULT_MAX_EQUATION_LENGTH -1); i >= 0; i--) {
                            const tile = document.getElementById(`tile-${currentRow}-${i}`);
                            if (( i < guessedEquation.length && guessedEquation[i] && guessedEquation[i].trim() !== '') || (tile && tile.textContent.trim() !== '')) {
                                actualLengthOfThisGuessedRow = i + 1;
                                break;
                            }
                        }
                    }


                    for (let c = 0; c < finalColsToCapture; c++) {
                        const tileElement = document.getElementById(`tile-${r}-${c}`);
                        if (gameWasUnknownLength && c >= actualLengthOfThisGuessedRow) {
                            rowRender.push({
                                text: '',
                                classList: ['tile', 'unknown-length']
                            });
                        } else if (tileElement) {
                            let tileClassList = Array.from(tileElement.classList);
                            tileClassList = tileClassList.filter(cls =>
                                cls !== 'tile-new-game-appear' &&
                                cls !== 'pop' &&
                                cls !== 'flip-reveal' &&
                                cls !== 'win-dance' &&
                                cls !== 'tile-cleared-animation' &&
                                cls !== 'hinted-briefly'
                            );
                            if (tileElement.classList.contains('unknown-length') && tileElement.textContent.trim() === '' && !tileClassList.some(cls => ['correct','present','absent','filled'].includes(cls))) {
                                if (!tileClassList.includes('unknown-length')) tileClassList.push('unknown-length');
                            } else {
                                 tileClassList = tileClassList.filter(cls => cls !== 'unknown-length');
                            }

                            rowRender.push({
                                text: tileElement.textContent,
                                classList: tileClassList
                            });
                        } else {
                            rowRender.push({
                                text: '',
                                classList: ['tile', gameWasUnknownLength ? 'unknown-length' : '']
                            });
                        }
                    }
                    render.push(rowRender);
                }
                return render;
            }
            function captureKeyboardState() {
                const keyboardState = {};
                document.querySelectorAll('.key[data-char]').forEach(key=>{
                    const char = key.dataset.char;
                    if (key.classList.contains('correct'))
                        keyboardState[char] = 'correct';
                    else if (key.classList.contains('present'))
                        keyboardState[char] = 'present';
                    else if (key.classList.contains('absent'))
                        keyboardState[char] = 'absent';
                    else if (key.classList.contains('disabled-permanently'))
                        keyboardState[char] = 'disabled-permanently';
                }
                );
                return keyboardState;
            }
            function recordGameInHistory(isWin, finalStatus) {
                const finalBoardRender = captureFinalBoardRender();
                const keyboardState = captureKeyboardState();

                let recordedAttempts;
                if (finalStatus === 'LOST' || finalStatus === 'LOST_SUDDEN_DEATH') {
                    recordedAttempts = ROWS;
                } else if (isWin) {
                    recordedAttempts = currentRow + 1;
                } else if (finalStatus === 'SURRENDERED') {
                    recordedAttempts = currentRow;
                } else if (finalStatus === ABANDONED_STATUS) {
                    recordedAttempts = currentRow;
                } else {
                    recordedAttempts = currentRow;
                }

                const historyEntry = {
                    id: Date.now().toString(36) + Math.random().toString(36).substring(2),
                    timestamp: Date.now(),
                    targetEquation: targetEquation,
                    difficulty: currentDifficulty,
                    status: finalStatus,
                    attemptsMade: recordedAttempts,
                    timeTaken: elapsedSeconds > 0 ? elapsedSeconds : null,
                    finalBoardRender: finalBoardRender,
                    keyboardState: keyboardState,
                    guessedRows: [...guessedEquationsHistory],
                    stars: currentEquationStars,
                    hintsUsed: hintsUsedThisGame,
                    countedInStats: gameCountsForStats,
                    unknownLengthMode: debugSettings.unknownLengthMode
                };
                let gameHistory = JSON.parse(localStorage.getItem('sumzleGameHistory')) || [];
                gameHistory.unshift(historyEntry);
                if (gameHistory.length > 50)
                    gameHistory.length = 50;
                localStorage.setItem('sumzleGameHistory', JSON.stringify(gameHistory));
            }
            function disableKeyboardForView() {
                document.querySelectorAll('.key').forEach(key=>{
                    if (key.dataset.char || key.textContent === '提交' || key.textContent === 'AC' || key.textContent === '删除')
                        key.classList.add('disabled-view-mode');
                }
                );
                document.getElementById('keyboard').classList.add('disabled-input');
            }
            function enableKeyboardForPlay() {
                document.querySelectorAll('.key.disabled-view-mode').forEach(key=>key.classList.remove('disabled-view-mode'));
                document.getElementById('keyboard').classList.remove('disabled-input');
            }
            function applyHistoricalBoardState(item) {
                const historyItemWasUnknownLength = item.unknownLengthMode || false;
                const displayCols = (historyItemWasUnknownLength && item.finalBoardRender && item.finalBoardRender[0]) ?
                                    item.finalBoardRender[0].length :
                                    item.targetEquation.length;

                item.finalBoardRender.forEach((rowRenderData,r)=>{
                    if (r >= ROWS) return;

                    (rowRenderData || []).forEach((tileRenderData,c)=>{
                         if (c >= displayCols) return;

                        const tileElement = document.getElementById(`tile-${r}-${c}`);
                        if (tileElement && tileRenderData) {
                            tileElement.textContent = tileRenderData.text;
                            tileElement.className = 'tile';
                            tileRenderData.classList.forEach(cls=>{
                                if (cls !== 'tile-new-game-appear' && cls !== 'pop' && cls !== 'hint-locked') {
                                     tileElement.classList.add(cls);
                                }
                            });
                             if (!tileElement.classList.contains('filled') && !tileElement.classList.contains('correct') && !tileElement.classList.contains('present') && !tileElement.classList.contains('absent') && historyItemWasUnknownLength) {
                                if (!tileElement.classList.contains('unknown-length')) {
                                     tileElement.classList.add('unknown-length');
                                }
                            } else {
                                tileElement.classList.remove('unknown-length');
                            }
                        }
                    });
                });
                resetKeyboardColors();
                Object.entries(item.keyboardState).forEach(([char,state])=>{
                    document.querySelectorAll(`.key[data-char="${char}"]`).forEach(key=>{
                        if (state) {
                            key.classList.remove('correct', 'present', 'absent', 'disabled-permanently');
                            key.classList.add(state);
                        }
                    });
                });
            }
            function exitHistoryView() {
                isViewingHistoryState = false;
                viewingHistoryItem = null;
                restartBtn.title = "重新开始/投降";
                restartBtn.innerHTML = '🔄';
                enableKeyboardForPlay();
                document.getElementById('exportImageBtn').style.display = 'none';
                document.getElementById('shareLevelBtn').style.display = 'none';
                currentEquationStars = "";
                resetGame();
            }
            function loadHistoryItemState(item) {
                isViewingHistoryState = true;
                viewingHistoryItem = item;
                gameActive = false;
                currentEquationStars = item.stars || calculateEquationDifficultyStars(item.targetEquation);
                stopLiveStatusUpdates();

                currentDifficulty = item.difficulty;
                targetEquation = item.targetEquation;
                ROWS = difficultySetting[currentDifficulty].attempts;

                const historyItemWasUnknownLength = item.unknownLengthMode || false;
                if (historyItemWasUnknownLength && item.finalBoardRender && item.finalBoardRender[0]) {
                    COLS = item.finalBoardRender[0].length;
                } else {
                    COLS = targetEquation.length;
                }
                COLS = Math.max(1, COLS);

                const originalDebugULM = debugSettings.unknownLengthMode;
                debugSettings.unknownLengthMode = historyItemWasUnknownLength;
                initBoard();
                debugSettings.unknownLengthMode = originalDebugULM;

                initKeyboard();
                applyHistoricalBoardState(item);

                currentRow = item.attemptsMade - 1;
                if(item.status === ABANDONED_STATUS) {
                    currentRow = item.attemptsMade;
                } else if (item.status === 'WON' || item.status === 'LOST' || item.status === 'LOST_SUDDEN_DEATH' || item.status === 'SURRENDERED') {
                     currentRow = item.attemptsMade > 0 ? item.attemptsMade -1 : 0;
                }

                updateStatusIndicatorText(`${item.status === 'WON' ? '查看胜利' : item.status === 'LOST' ? '查看失败' : item.status === 'LOST_SUDDEN_DEATH' ? '查看猝死' :  item.status === 'SURRENDERED' ? '查看放弃' : item.status === ABANDONED_STATUS ? '查看离开记录' : '查看记录'} (${difficultySetting[item.difficulty].name})${item.timeTaken !== null ? ' - 用时: ' + formatTime(item.timeTaken) : ''} ${currentEquationStars}`);
                disableKeyboardForView();
                if (item.status === 'WON')
                    setHeaderTitleState(quarkModeActive ? 'quark' : 'win');
                else if (item.status === 'LOST' || item.status === 'LOST_SUDDEN_DEATH' || item.status === 'SURRENDERED' || item.status === ABANDONED_STATUS)
                    setHeaderTitleState(quarkModeActive ? 'quark' : 'lose');
                else
                    setHeaderTitleState(quarkModeActive ? 'quark' : 'history');
                restartBtn.title = "关闭查看";
                restartBtn.innerHTML = '❌';
                document.getElementById('exportImageBtn').style.display = 'inline-block';
                document.getElementById('shareLevelBtn').style.display = 'inline-block';
                hideModal('historyModal');
                updateBackgroundStyle();
            }
            function displayHistory() {
                const historyListContainer = document.getElementById('historyListContainer')
                  , noHistoryMsg = document.getElementById('noHistoryMessage')
                  , clearHistoryBtn = document.getElementById('clearHistoryBtn');
                historyListContainer.innerHTML = '';
                const gameHistory = JSON.parse(localStorage.getItem('sumzleGameHistory')) || [];
                if (gameHistory.length === 0) {
                    noHistoryMsg.style.display = 'block';
                    clearHistoryBtn.style.display = 'none';
                    return;
                }
                noHistoryMsg.style.display = 'none';
                clearHistoryBtn.style.display = 'inline-block';
                gameHistory.forEach(item=>{
                    const itemDiv = document.createElement('div');
                    itemDiv.className = 'history-item';
                    itemDiv.dataset.historyId = item.id;
                    const statusClass = item.status ? item.status.toLowerCase() : 'unknown';
                    let statusText = '未知';
                    if (item.status === 'WON') statusText = '胜利';
                    else if (item.status === 'LOST') statusText = '失败';
                    else if (item.status === 'LOST_SUDDEN_DEATH') statusText = '猝死';
                    else if (item.status === 'SURRENDERED') statusText = '放弃';
                    else if (item.status === ABANDONED_STATUS) statusText = '已离开';
                    const itemStars = item.stars || calculateEquationDifficultyStars(item.targetEquation);
                    const hintsInfo = item.hintsUsed > 0 ? ` | 提示: ${item.hintsUsed}次` : '';
                    const statsInfo = item.countedInStats === false ? ` (未统计)` : '';


                    itemDiv.innerHTML = `<div class="history-item-preview"><span class="history-equation">${item.targetEquation.replace(/\*/g, '×').replace(/\//g, '÷')}</span><span class="history-status ${statusClass}">${statusText}${statsInfo}</span></div><div class="history-item-details"><span>${difficultySetting[item.difficulty].name}</span> | <span>${itemStars}</span> | <span>${new Date(item.timestamp).toLocaleDateString()} ${new Date(item.timestamp).toLocaleTimeString([], {
                        hour: '2-digit',
                        minute: '2-digit'
                    })}</span>${item.timeTaken !== null ? ` | <span>用时: ${formatTime(item.timeTaken)}</span>` : ''}<span>(${item.attemptsMade} / ${difficultySetting[item.difficulty].attempts} 次尝试)${hintsInfo}</span></div><div class="history-item-actions"><button class="history-replay-btn secondary-btn">重玩</button><button class="history-view-state-btn primary-btn">查看</button><button class="history-delete-btn danger-btn">删除</button></div>`;
                    itemDiv.querySelector('.history-replay-btn').addEventListener('click', ()=>{
                        isCustomLevel = true;
                        startGame(item.targetEquation, item.difficulty);
                        hideModal('historyModal');
                    }
                    );
                    itemDiv.querySelector('.history-view-state-btn').addEventListener('click', ()=>loadHistoryItemState(item));
                    itemDiv.querySelector('.history-delete-btn').addEventListener('click', ()=>{
                        let updatedHistory = gameHistory.filter(h=>h.id !== item.id);
                        localStorage.setItem('sumzleGameHistory', JSON.stringify(updatedHistory));
                        displayHistory();
                    }
                    );
                    historyListContainer.appendChild(itemDiv);
                }
                );
            }
            document.getElementById('historyBtn').addEventListener('click', ()=>{
                displayHistory();
                showModal('historyModal');
            }
            );
            document.getElementById('closeHistoryModalBtn').addEventListener('click', ()=>hideModal('historyModal'));
            document.getElementById('clearHistoryBtn').addEventListener('click', ()=>showModal('confirmClearHistoryModal'));
            document.getElementById('executeClearHistoryBtn').addEventListener('click', ()=>{
                localStorage.removeItem('sumzleGameHistory');
                displayHistory();
                hideModal('confirmClearHistoryModal');
                showMessage("游戏历史已清空");
            }
            );
            document.getElementById('cancelClearHistoryBtn').addEventListener('click', ()=>hideModal('confirmClearHistoryModal'));

        document.getElementById('exportImageBtn').addEventListener('click', exportGameImage);

        function exportGameImage() {
            function hexToRgb(hex) {
                let r = 0, g = 0, b = 0;
                if (!hex || typeof hex !== 'string') return { r, g, b }; 
                hex = hex.replace(/^#/, '');
                if (hex.length === 3) {
                    r = parseInt(hex[0] + hex[0], 16);
                    g = parseInt(hex[1] + hex[1], 16);
                    b = parseInt(hex[2] + hex[2], 16);
                } else if (hex.length === 6) {
                    r = parseInt(hex.substring(0, 2), 16);
                    g = parseInt(hex.substring(2, 4), 16);
                    b = parseInt(hex.substring(4, 6), 16);
                }
                return { r, g, b };
            }

            function getResolvedColorRgbString(variableName, isDarkThemeOverride) {
                const body = document.body;
                let originalThemeClassState = null; 

                if (isDarkThemeOverride === true && !body.classList.contains('dark-theme')) {
                    body.classList.add('dark-theme');
                    originalThemeClassState = 'added';
                } else if (isDarkThemeOverride === false && body.classList.contains('dark-theme')) {
                    body.classList.remove('dark-theme');
                    originalThemeClassState = 'removed';
                }

                const rootStyle = getComputedStyle(document.documentElement);
                const hexColor = rootStyle.getPropertyValue(variableName).trim();
                
                if (originalThemeClassState === 'added') {
                    body.classList.remove('dark-theme');
                } else if (originalThemeClassState === 'removed') {
                    body.classList.add('dark-theme');
                }
                
                const { r, g, b } = hexToRgb(hexColor);
                return `rgb(${r}, ${g}, ${b})`;
            }
            
            function calculateColorMixFallback(isDarkThemeForMix) {
                const body = document.body;
                let themeChanged = false;
                const currentBodyIsDark = body.classList.contains('dark-theme');

                if (isDarkThemeForMix && !currentBodyIsDark) {
                    body.classList.add('dark-theme');
                    themeChanged = true;
                } else if (!isDarkThemeForMix && currentBodyIsDark) {
                    body.classList.remove('dark-theme');
                    themeChanged = true;
                }
                
                const surfaceHex = getComputedStyle(document.documentElement).getPropertyValue('--color-surface').trim();
                const textSecondaryHex = getComputedStyle(document.documentElement).getPropertyValue('--color-text-secondary').trim();

                if (themeChanged) {
                    if (isDarkThemeForMix && !currentBodyIsDark) { 
                        body.classList.remove('dark-theme');
                    } else if (!isDarkThemeForMix && currentBodyIsDark) { 
                         body.classList.add('dark-theme');
                    }
                }

                const rgbSurface = hexToRgb(surfaceHex);
                const rgbTextSecondary = hexToRgb(textSecondaryHex);

                const mixedR = Math.round(0.8 * rgbSurface.r + 0.2 * rgbTextSecondary.r);
                const mixedG = Math.round(0.8 * rgbSurface.g + 0.2 * rgbTextSecondary.g);
                const mixedB = Math.round(0.8 * rgbSurface.b + 0.2 * rgbTextSecondary.b);
                return `rgb(${mixedR}, ${mixedG}, ${mixedB})`;
            }


            const gameBoardElement = document.getElementById('board');
            if (!gameBoardElement) {
                showMessage("错误：找不到游戏板元素", 2000);
                return;
            }
            
            const isOriginalDocDarkTheme = document.body.classList.contains('dark-theme');

            const resolvedColorSurface = getResolvedColorRgbString('--color-surface', isOriginalDocDarkTheme);
            const resolvedColorText = getResolvedColorRgbString('--color-text', isOriginalDocDarkTheme);
            const resolvedColorTextSecondary = getResolvedColorRgbString('--color-text-secondary', isOriginalDocDarkTheme);
            const resolvedColorCorrect = getResolvedColorRgbString('--color-correct', isOriginalDocDarkTheme);
            const resolvedColorPresent = getResolvedColorRgbString('--color-present', isOriginalDocDarkTheme);
            const resolvedColorAbsent = getResolvedColorRgbString('--color-absent', isOriginalDocDarkTheme);
            const resolvedColorBorderLight = getResolvedColorRgbString('--color-border-light', isOriginalDocDarkTheme);
            const resolvedColorKeyFeedbackText = getResolvedColorRgbString('--color-key-feedback-text', isOriginalDocDarkTheme);
            const resolvedFilledBorderColor = isOriginalDocDarkTheme ? getResolvedColorRgbString('--color-border', isOriginalDocDarkTheme) : 'rgb(158, 158, 158)'; 
            const calculatedUnknownLengthBg = calculateColorMixFallback(isOriginalDocDarkTheme);
            const unknownLengthDashedBorderColor = isOriginalDocDarkTheme ? 'rgb(100, 100, 100)' : 'rgb(180, 180, 180)';


            let numColsForExport;
            let rowsToExport;
            let gameDifficultyForExport = currentDifficulty;
            let starsForExport = currentEquationStars;
            let gameIsUnknownLengthForExport = debugSettings.unknownLengthMode;
            let exportGuessedRows = guessedEquationsHistory.map(r => r); 

            if (isViewingHistoryState && viewingHistoryItem) {
                gameIsUnknownLengthForExport = viewingHistoryItem.unknownLengthMode || false;
                gameDifficultyForExport = viewingHistoryItem.difficulty;
                starsForExport = viewingHistoryItem.stars || calculateEquationDifficultyStars(viewingHistoryItem.targetEquation);
                rowsToExport = viewingHistoryItem.finalBoardRender.length;
                exportGuessedRows = viewingHistoryItem.guessedRows.map(r => r);

                if (gameIsUnknownLengthForExport && viewingHistoryItem.finalBoardRender && viewingHistoryItem.finalBoardRender[0]) {
                    numColsForExport = viewingHistoryItem.finalBoardRender[0].length;
                } else {
                    numColsForExport = viewingHistoryItem.targetEquation.length;
                }
            } else { 
                rowsToExport = gameActive ? currentRow + 1 : ROWS;
                 if (!gameActive) {
                     rowsToExport = guessedEquationsHistory.length > 0 ? guessedEquationsHistory.length : ROWS;
                     if (currentRow === ROWS -1 && guessedEquationsHistory.length < ROWS && guessedEquationsHistory.length > 0) { 
                        if (!guessedEquationsHistory[ROWS-1] && document.getElementById(`tile-${ROWS-1}-0`)?.textContent.trim() === '') {
                             rowsToExport = guessedEquationsHistory.length;
                        } else {
                             rowsToExport = ROWS;
                        }
                     } else if (currentRow === ROWS -1 && guessedEquationsHistory.length === 0) {
                         rowsToExport = ROWS;
                     }
                }

                if (gameIsUnknownLengthForExport) {
                    let maxLen = 0;
                    guessedEquationsHistory.forEach(rowStr => {
                        if (rowStr) maxLen = Math.max(maxLen, rowStr.length);
                    });
                    let currentEffectiveLength = 0;
                    const currentProcessingRow = (!gameActive && guessedEquationsHistory.length === currentRow + 1 && currentRow < ROWS) ? currentRow 
                                             : (gameActive && currentRow < ROWS ? currentRow : -1);

                    if (currentProcessingRow !== -1) {
                         for (let i = (guessedEquation.length > 0 ? guessedEquation.length - 1 : DEFAULT_MAX_EQUATION_LENGTH - 1); i >= 0; i--) {
                            const tile = document.getElementById(`tile-${currentProcessingRow}-${i}`);
                            if ((i < guessedEquation.length && guessedEquation[i] && guessedEquation[i].trim() !== '') || (tile && tile.textContent.trim() !== '')) {
                                currentEffectiveLength = i + 1;
                                break;
                            }
                        }
                        maxLen = Math.max(maxLen, currentEffectiveLength);
                         if (gameActive && currentEffectiveLength > 0 && rowsToExport -1 === currentRow) {
                             exportGuessedRows[currentRow] = guessedEquation.slice(0, currentEffectiveLength).join('');
                         }
                    }

                    if (!gameActive && targetEquation) {
                        maxLen = Math.max(maxLen, targetEquation.length);
                    }
                    if (maxLen === 0) {
                        const firstBoardRowDOM = gameBoardElement.querySelector('.row');
                        maxLen = (firstBoardRowDOM && firstBoardRowDOM.children.length > 0) ? firstBoardRowDOM.children.length : DEFAULT_MAX_EQUATION_LENGTH;
                    }
                    numColsForExport = maxLen;
                } else {
                    numColsForExport = COLS > 0 ? COLS : targetEquation.length;
                     if (gameActive && currentRow < ROWS && rowsToExport -1 === currentRow) { 
                        exportGuessedRows[currentRow] = guessedEquation.slice(0, numColsForExport).join('');
                    }
                }
            }
            numColsForExport = Math.max(1, numColsForExport);


            const tempContainer = document.createElement('div');
            tempContainer.style.position = 'absolute';
            tempContainer.style.left = '-99999px';
            tempContainer.style.top = '-99999px';
            tempContainer.style.padding = '20px';
            tempContainer.style.backgroundColor = getResolvedColorRgbString('--color-background', isOriginalDocDarkTheme);
            tempContainer.style.width = 'max-content';

            const titleElement = document.getElementById('mainHeaderTitle');
            const titleClone = document.createElement('div');
            const computedOriginalTitleStyle = getComputedStyle(titleElement);
            titleClone.style.position = 'static';
            titleClone.style.transform = 'none';
            titleClone.style.display = 'block';
            titleClone.style.textAlign = 'center';
            titleClone.style.width = '100%';
            titleClone.style.marginBottom = '25px';
            titleClone.style.fontSize = computedOriginalTitleStyle.fontSize;
            titleClone.style.fontWeight = computedOriginalTitleStyle.fontWeight;
            titleClone.style.fontFamily = computedOriginalTitleStyle.fontFamily;
            titleClone.style.letterSpacing = computedOriginalTitleStyle.letterSpacing;
            let actualTextContent = "";
            Array.from(titleElement.querySelectorAll('.title-char')).forEach(span => {
                actualTextContent += span.textContent;
            });
            titleClone.textContent = actualTextContent || "SUMZLE";
            titleClone.style.color = document.body.classList.contains('dark-theme') ? '#FFA0C0' : '#FF69B4';
            titleClone.style.webkitBackgroundClip = 'unset';
            titleClone.style.backgroundClip = 'unset';
            titleClone.style.backgroundImage = 'none';
            titleClone.style.animation = 'none';

            const boardClone = gameBoardElement.cloneNode(false);
            boardClone.innerHTML = '';
            boardClone.id = 'boardCloneForExport';
            boardClone.style.display = 'grid';
            boardClone.style.width = 'max-content';
            boardClone.style.overflow = 'visible';
            boardClone.style.maxWidth = 'none';
            boardClone.style.gap = getComputedStyle(gameBoardElement).gap;
            boardClone.style.padding = getComputedStyle(gameBoardElement).padding;
            boardClone.style.gridTemplateRows = `repeat(${rowsToExport},1fr)`;


            for (let rIndex = 0; rIndex < rowsToExport; rIndex++) {
                if (rIndex >= ROWS && !(isViewingHistoryState && viewingHistoryItem && rIndex < viewingHistoryItem.finalBoardRender.length)) continue;

                const clonedRow = document.createElement('div');
                clonedRow.className = 'row';
                clonedRow.style.display = 'grid';
                clonedRow.style.gap = getComputedStyle(gameBoardElement.querySelector('.row') || document.createElement('div')).gap;
                clonedRow.style.gridTemplateColumns = `repeat(${numColsForExport}, 1fr)`;

                let actualSubmittedLengthOfThisRow = 0;
                 if (exportGuessedRows[rIndex]) {
                     actualSubmittedLengthOfThisRow = exportGuessedRows[rIndex].length;
                 }


                for (let cIndex = 0; cIndex < numColsForExport; cIndex++) {
                    const clonedTile = document.createElement('div');
                    clonedTile.className = 'tile'; 
                    const originalTile = document.getElementById(`tile-${rIndex}-${cIndex}`);

                    if (originalTile) {
                        const computedStyleOriginal = window.getComputedStyle(originalTile);
                        clonedTile.style.fontSize = computedStyleOriginal.fontSize;
                        clonedTile.style.fontWeight = computedStyleOriginal.fontWeight;
                        clonedTile.style.aspectRatio = computedStyleOriginal.aspectRatio;
                        clonedTile.style.minHeight = computedStyleOriginal.minHeight;
                        clonedTile.style.minWidth = computedStyleOriginal.minWidth;
                        clonedTile.style.display = 'flex';
                        clonedTile.style.justifyContent = 'center';
                        clonedTile.style.alignItems = 'center';
                        clonedTile.style.borderRadius = computedStyleOriginal.borderRadius;
                        clonedTile.style.borderWidth = computedStyleOriginal.borderWidth || '2px'; 
                        clonedTile.style.borderStyle = 'solid'; 
                        clonedTile.style.color = resolvedColorText; 

                        clonedTile.textContent = originalTile.textContent;

                        let tileStateBgColor = resolvedColorSurface;
                        let tileStateBorderColor = resolvedColorBorderLight;
                        let tileStateForeColor = resolvedColorText;
                        let tileStateBorderStyle = 'solid';

                        if (originalTile.classList.contains('correct')) {
                            tileStateBgColor = resolvedColorCorrect;
                            tileStateBorderColor = resolvedColorCorrect;
                            tileStateForeColor = resolvedColorKeyFeedbackText;
                        } else if (originalTile.classList.contains('present')) {
                            tileStateBgColor = resolvedColorPresent;
                            tileStateBorderColor = resolvedColorPresent;
                            tileStateForeColor = resolvedColorKeyFeedbackText;
                        } else if (originalTile.classList.contains('absent')) {
                            tileStateBgColor = resolvedColorAbsent;
                            tileStateBorderColor = resolvedColorAbsent;
                            tileStateForeColor = resolvedColorKeyFeedbackText;
                        } else if (originalTile.classList.contains('unknown-length')) {
                            tileStateBgColor = calculatedUnknownLengthBg;
                            if (gameIsUnknownLengthForExport && cIndex >= actualSubmittedLengthOfThisRow && originalTile.textContent.trim() === '') {
                                tileStateBorderStyle = 'dashed';
                                tileStateBorderColor = unknownLengthDashedBorderColor;
                                tileStateForeColor = resolvedColorTextSecondary;
                                clonedTile.textContent = ''; 
                            } else if (originalTile.classList.contains('filled')) {
                                tileStateBorderColor = resolvedFilledBorderColor; 
                            } else { 
                                tileStateBorderStyle = 'dashed';
                                tileStateBorderColor = unknownLengthDashedBorderColor;
                                tileStateForeColor = resolvedColorTextSecondary;
                                clonedTile.textContent = '';
                            }
                        } else if (originalTile.classList.contains('filled')) {
                            tileStateBorderColor = resolvedFilledBorderColor; 
                        }
                        

                        clonedTile.style.backgroundColor = tileStateBgColor;
                        clonedTile.style.borderColor = tileStateBorderColor;
                        clonedTile.style.color = tileStateForeColor;
                        clonedTile.style.borderStyle = tileStateBorderStyle;


                    } else { 
                        const firstTileStyle = getComputedStyle(gameBoardElement.querySelector('.tile') || document.createElement('div'));
                        clonedTile.style.fontSize = firstTileStyle.fontSize;
                        clonedTile.style.fontWeight = firstTileStyle.fontWeight;
                        clonedTile.style.aspectRatio = firstTileStyle.aspectRatio;
                        clonedTile.style.minHeight = firstTileStyle.minHeight;
                        clonedTile.style.minWidth = firstTileStyle.minWidth;
                        clonedTile.style.display = 'flex';
                        clonedTile.style.justifyContent = 'center';
                        clonedTile.style.alignItems = 'center';
                        clonedTile.style.borderRadius = firstTileStyle.borderRadius;
                        clonedTile.style.border = `2px solid ${resolvedColorBorderLight}`;
                        clonedTile.style.backgroundColor = resolvedColorSurface;
                        clonedTile.style.color = resolvedColorText;
                        clonedTile.textContent = '';
                        if (gameIsUnknownLengthForExport) {
                            clonedTile.style.backgroundColor = calculatedUnknownLengthBg;
                            clonedTile.style.borderStyle = 'dashed';
                            clonedTile.style.borderColor = unknownLengthDashedBorderColor;
                        }
                    }
                     clonedTile.style.transform = 'none'; 
                     clonedTile.style.animation = 'none'; 
                    clonedRow.appendChild(clonedTile);
                }
                boardClone.appendChild(clonedRow);
            }


            const exportMessage = document.createElement('p');
            let difficultyText, attemptsInfo;
            difficultyText = difficultySetting[gameDifficultyForExport].name;

            if (isViewingHistoryState && viewingHistoryItem) {
                const itemStatusText = viewingHistoryItem.status === 'WON' ? '胜利' :
                                       viewingHistoryItem.status === 'LOST' ? '失败' :
                                       viewingHistoryItem.status === 'LOST_SUDDEN_DEATH' ? '猝死' :
                                       viewingHistoryItem.status === 'SURRENDERED' ? '放弃' :
                                       viewingHistoryItem.status === ABANDONED_STATUS ? '离开' : '记录';
                attemptsInfo = `${viewingHistoryItem.attemptsMade}/${difficultySetting[viewingHistoryItem.difficulty].attempts} (${itemStatusText})`;
                if (viewingHistoryItem.timeTaken) {
                    attemptsInfo += ` - 用时: ${formatTime(viewingHistoryItem.timeTaken)}`;
                }
                 if (viewingHistoryItem.hintsUsed > 0) {
                    attemptsInfo += ` - 提示: ${viewingHistoryItem.hintsUsed}次`;
                }
            } else {
                let finalAttemptsCount;
                if (!gameActive) { 
                    finalAttemptsCount = guessedEquationsHistory.length;
                    if (finalAttemptsCount === 0 && currentRow === 0 && targetEquation && guessedEquation.join('').slice(0, targetEquation.length) === targetEquation) { 
                        finalAttemptsCount = 1;
                    } else if (finalAttemptsCount === 0 && currentRow === ROWS -1) { 
                         finalAttemptsCount = ROWS;
                    }
                } else { 
                    finalAttemptsCount = currentRow; 
                     let currentActualLength = 0;
                     if(currentRow < ROWS) { 
                        for (let k_idx = guessedEquation.length - 1; k_idx >= 0; k_idx--) {
                            const tileForCheck = document.getElementById(`tile-${currentRow}-${k_idx}`);
                            if ((guessedEquation[k_idx] && guessedEquation[k_idx].trim() !== '') || (tileForCheck && tileForCheck.textContent.trim() !== '')) {
                                currentActualLength = k_idx + 1;
                                break;
                            }
                        }
                     }
                    if (currentActualLength > 0 || (guessedEquation.slice(0, numColsForExport).join('').length > 0 && currentRow < ROWS) ) {
                        finalAttemptsCount = currentRow + 1;
                    }
                }
                attemptsInfo = `${finalAttemptsCount}/${difficultySetting[gameDifficultyForExport].attempts} 尝试`;
                if (elapsedSeconds > 0 && !gameActive) {
                    attemptsInfo += ` - 用时: ${formatTime(elapsedSeconds)}`;
                }
                if (hintsUsedThisGame > 0) {
                     attemptsInfo += ` - 提示: ${hintsUsedThisGame}次`;
                }
            }
            exportMessage.textContent = `Sumzle ${difficultyText} ${starsForExport} - ${attemptsInfo}`;
            exportMessage.style.textAlign = 'center';
            exportMessage.style.marginTop = '25px';
            exportMessage.style.fontWeight = 'bold';
            exportMessage.style.fontSize = '1rem';
            exportMessage.style.color = resolvedColorTextSecondary;

            tempContainer.appendChild(titleClone);
            tempContainer.appendChild(boardClone);
            tempContainer.appendChild(exportMessage);
            document.body.appendChild(tempContainer);

            const boardComputedStyle = getComputedStyle(boardClone);
            const boardGap = parseFloat(boardComputedStyle.gap) || 6;
            const firstClonedTile = boardClone.querySelector('.tile');
            let tileWidth = 50; 
            let tileHeight = 50;
            if (firstClonedTile) {
                const firstTileStyle = getComputedStyle(firstClonedTile);
                tileWidth = parseFloat(firstTileStyle.width) || 50;
                tileHeight = parseFloat(firstTileStyle.height) || 50;

                if (firstTileStyle.boxSizing === 'border-box') {
                    tileWidth = parseFloat(firstTileStyle.width);
                    tileHeight = parseFloat(firstTileStyle.height);
                } else {
                     tileWidth = parseFloat(firstTileStyle.width) +
                                (parseFloat(firstTileStyle.paddingLeft) || 0) + (parseFloat(firstTileStyle.paddingRight) || 0) +
                                (parseFloat(firstTileStyle.borderLeftWidth) || 0) + (parseFloat(firstTileStyle.borderRightWidth) || 0);
                     tileHeight = parseFloat(firstTileStyle.height) +
                                (parseFloat(firstTileStyle.paddingTop) || 0) + (parseFloat(firstTileStyle.paddingBottom) || 0) +
                                (parseFloat(firstTileStyle.borderTopWidth) || 0) + (parseFloat(firstTileStyle.borderBottomWidth) || 0);
                }
                tileWidth = Math.max(tileWidth, parseFloat(firstTileStyle.minWidth) || 0);
                tileHeight = Math.max(tileHeight, parseFloat(firstTileStyle.minHeight) || 0);

            }
            
            let calculatedBoardWidth = (numColsForExport * tileWidth) +
                                       Math.max(0, numColsForExport - 1) * boardGap +
                                       (parseFloat(boardComputedStyle.paddingLeft) || 0) +
                                       (parseFloat(boardComputedStyle.paddingRight) || 0);
            
            boardClone.style.width = calculatedBoardWidth + 'px';

            const tempContainerPaddingLeft = parseFloat(getComputedStyle(tempContainer).paddingLeft) || 0;
            const tempContainerPaddingRight = parseFloat(getComputedStyle(tempContainer).paddingRight) || 0;
            tempContainer.style.width = (boardClone.offsetWidth + tempContainerPaddingLeft + tempContainerPaddingRight) + 'px';


            setTimeout(() => {
                if (typeof html2canvas === 'undefined') {
                    showMessage("图片导出功能不可用 (库未加载)", 3000);
                    if (tempContainer.parentElement) document.body.removeChild(tempContainer);
                    return;
                }
                try {
                    const captureWidth = tempContainer.offsetWidth;
                    const captureHeight = tempContainer.offsetHeight;

                    html2canvas(tempContainer, {
                        backgroundColor: tempContainer.style.backgroundColor, 
                        useCORS: true,
                        scale: window.devicePixelRatio * 1.2,
                        width: captureWidth,
                        height: captureHeight,
                        windowWidth: captureWidth,
                        windowHeight: captureHeight,
                        logging: false,
                        onclone: (clonedDocument) => {
                            const clonedBoardInDoc = clonedDocument.getElementById('boardCloneForExport');
                            if (clonedBoardInDoc) {
                                clonedBoardInDoc.style.width = boardClone.style.width; 
                                Array.from(clonedBoardInDoc.querySelectorAll('.tile')).forEach(tileInClonedDoc => {
                                tileInClonedDoc.style.setProperty('animation', 'none', 'important');
                                tileInClonedDoc.style.setProperty('transform', 'none', 'important');
                                
                                if (tileInClonedDoc.style.borderStyle === 'dashed' && tileInClonedDoc.textContent.trim() === '') {
                                    const qMark = clonedDocument.createElement('span');
                                    qMark.textContent = '?';
                                    qMark.style.fontSize = '1.5em'; 
                                    qMark.style.opacity = '0.6';   
                                    qMark.style.position = 'absolute'; 
                                    qMark.style.color = tileInClonedDoc.style.color; 
                                    tileInClonedDoc.style.position = 'relative'; 
                                    tileInClonedDoc.appendChild(qMark);
                                }
                            });
                        }
                    }
                }).then(canvas => {
                    const image = canvas.toDataURL("image/png");
                    const link = document.createElement('a');
                    link.href = image;
                    link.download = `Sumzle_Game_${new Date().toISOString().slice(0, 10)}.png`;
                    link.click();
                    showMessage("图片已导出!", 2000);
                }).catch(err => {
                    showMessage("导出图片失败 查看控制台获取详情", 3000);
                    console.error("html2canvas error:", err);
                }).finally(() => {
                    if (tempContainer.parentElement) document.body.removeChild(tempContainer);
                });
            } catch (e) {
                showMessage("导出图片时出错 (库错误)", 3000);
                console.error("Export image general error:", e);
                if (tempContainer.parentElement) document.body.removeChild(tempContainer);
            }
        }, 250);
    }
        function handleSubmit() {
            if (!gameActive || isViewingHistoryState) return;
            stopLiveStatusUpdates();

            const currentBoardRowElement = document.querySelector(`.board .row:nth-child(${currentRow + 1})`);
            
            let isVisuallyFull = true;
            let effectiveColsForSubmission;

            if (debugSettings.unknownLengthMode) {
                let lastFilledIndex = -1;
                for (let i = guessedEquation.length - 1; i >= 0; i--) {
                    if (guessedEquation[i] && guessedEquation[i].trim() !== '') {
                        lastFilledIndex = i;
                        break;
                    }
                }
                effectiveColsForSubmission = lastFilledIndex + 1;
                
                if (effectiveColsForSubmission === 0) { 
                    isVisuallyFull = false;
                }
            } else {
                effectiveColsForSubmission = (COLS > 0 ? COLS : targetEquation.length);
                if (effectiveColsForSubmission === 0 && targetEquation.length > 0) { 
                    effectiveColsForSubmission = targetEquation.length;
                }
                for (let i = 0; i < effectiveColsForSubmission; i++) {
                    const tile = document.getElementById(`tile-${currentRow}-${i}`);
                    if (!tile || (tile.textContent === '' && !tile.classList.contains('hint-locked'))) {
                        isVisuallyFull = false;
                        break;
                    }
                }
            }

            if (!isVisuallyFull) {
                if (currentBoardRowElement) currentBoardRowElement.classList.add('invalid-shake');
                setTimeout(() => {
                    if (currentBoardRowElement) currentBoardRowElement.classList.remove('invalid-shake');
                }, 500);
                showMessage(debugSettings.unknownLengthMode && effectiveColsForSubmission === 0 ? "请输入表达式" : "请填满当前行");
                startLiveStatusUpdates();
                return;
            }
            
            const maxColsToCheckForHints = debugSettings.unknownLengthMode ? DEFAULT_MAX_EQUATION_LENGTH : effectiveColsForSubmission;
            for (let i = 0; i < maxColsToCheckForHints; i++) {
                if (i >= guessedEquation.length) break; 
                const tile = document.getElementById(`tile-${currentRow}-${i}`);
                if (tile && tile.classList.contains('hint-locked') && tile.classList.contains('correct')) {
                    if (i < targetEquation.length && guessedEquation[i] !== targetEquation[i]) {
                        guessedEquation[i] = targetEquation[i];
                    }
                }
            }
            
            if (debugSettings.unknownLengthMode) {
                let lastFilledIndex = -1;
                for (let i = guessedEquation.length - 1; i >= 0; i--) {
                     if (guessedEquation[i] && guessedEquation[i].trim() !== '') {
                        lastFilledIndex = i;
                        break;
                    }
                }
                effectiveColsForSubmission = lastFilledIndex + 1;
                 if (effectiveColsForSubmission === 0) { 
                    if (currentBoardRowElement) currentBoardRowElement.classList.add('invalid-shake');
                    setTimeout(() => { if (currentBoardRowElement) currentBoardRowElement.classList.remove('invalid-shake'); }, 500);
                    showMessage("请输入表达式");
                    startLiveStatusUpdates();
                    return;
                 }
            }

            const guessToValidate = guessedEquation.slice(0, effectiveColsForSubmission);

            if (!isValidEquation(guessToValidate)) {
                if (currentBoardRowElement) currentBoardRowElement.classList.add('invalid-shake');
                setTimeout(() => {
                    if (currentBoardRowElement) currentBoardRowElement.classList.remove('invalid-shake');
                }, 500);
                startLiveStatusUpdates();
                return;
            }

            let justStartedTimerAndDisplayedIt = false;
            if (!gameStartTime && (currentCol > 0 || isVisuallyFull)) {
                if (!debugSettings.suddenDeathTimer) {
                    gameStartTime = Date.now();
                    elapsedSeconds = 0;
                    gameTimerInterval = setInterval(updateGameTimerDisplay, 1000);
                }
                let timerText = `进行中: ${formatTime(elapsedSeconds)}`;
                if (currentEquationStars && !isCustomLevel && !isViewingHistoryState) {
                    timerText += ` ${currentEquationStars}`;
                }
                updateStatusIndicatorText(timerText, true);
                justStartedTimerAndDisplayedIt = true;
            }

            guessedEquationsHistory.push(guessToValidate.join(''));
            checkGuess(effectiveColsForSubmission); 
            
            const guessString = guessToValidate.join('');

            if (guessString === targetEquation) {
                const tilesToDance = currentBoardRowElement ? Array.from(currentBoardRowElement.children).slice(0, effectiveColsForSubmission) : [];
                tilesToDance.forEach((tile,i)=>{
                    setTimeout(()=>tile.classList.add('win-dance'), i * 100);
                }
                );
                handleEndGame(true, 'WON');
                return;
            }

            if (guessString !== targetEquation) {
               currentRow++;
               currentCol = 0;
            }

            const displayColsNextRow = debugSettings.unknownLengthMode ? DEFAULT_MAX_EQUATION_LENGTH : (COLS > 0 ? COLS : targetEquation.length);
            const nextRowInitialGuessedEquation = Array(displayColsNextRow).fill('');
            if (currentRow < ROWS) {
                for(let i=0; i < displayColsNextRow; i++) {
                    const tileForNextRow = document.getElementById(`tile-${currentRow}-${i}`);
                    if(tileForNextRow && tileForNextRow.classList.contains('hint-locked') && tileForNextRow.textContent) {
                       nextRowInitialGuessedEquation[i] = tileForNextRow.textContent === '×' ? '*' : tileForNextRow.textContent === '÷' ? '/' : tileForNextRow.textContent;
                    }
                }
            }
            guessedEquation = nextRowInitialGuessedEquation;


            let firstNonLockedIndex = 0;
            if (currentRow < ROWS) {
                for (let i = 0; i < displayColsNextRow; i++) {
                    const tile = document.getElementById(`tile-${currentRow}-${i}`);
                    if (tile && tile.classList.contains('hint-locked')) {
                        firstNonLockedIndex = i + 1;
                    } else {
                        break; 
                    }
                }
            }
            currentCol = firstNonLockedIndex;

            if (currentRow >= ROWS) {
                if (currentBoardRowElement) currentBoardRowElement.classList.add('invalid-shake');
                setTimeout(() => {
                    if (currentBoardRowElement) currentBoardRowElement.classList.remove('invalid-shake');
                }, 600);
                handleEndGame(false, 'LOST');
            } else {
                if (!justStartedTimerAndDisplayedIt) {
                     let statusTextToShow;
                    if (gameStartTime > 0) {
                        statusTextToShow = `进行中: ${formatTime(elapsedSeconds)}`;
                         if (currentEquationStars && !isCustomLevel && !isViewingHistoryState) statusTextToShow += ` ${currentEquationStars}`;
                        updateStatusIndicatorText(statusTextToShow, true);
                    } else {
                        statusTextToShow = `${difficultySetting[currentDifficulty].name}模式 - ${COLS > 0 ? COLS + '字符' : debugSettings.unknownLengthMode ? '?字符' : targetEquation.length + '字符'}`;
                        if (currentEquationStars && !isCustomLevel && !isViewingHistoryState) statusTextToShow += ` ${currentEquationStars}`;
                        updateStatusIndicatorText(statusTextToShow, false);
                    }
                }
                 startLiveStatusUpdates();
            }
        }
        function fallbackCopyTextToClipboard(text) {
            const textArea = document.createElement("textarea");
            textArea.value = text;
            textArea.style.position = "fixed";
            textArea.style.top = "0";
            textArea.style.left = "0";
            textArea.style.width = "2em";
            textArea.style.height = "2em";
            textArea.style.padding = "0";
            textArea.style.border = "none";
            textArea.style.outline = "none";
            textArea.style.boxShadow = "none";
            textArea.style.background = "transparent";
            document.body.appendChild(textArea);
            textArea.focus();
            textArea.select();
            try {
                const successful = document.execCommand('copy');
                if (successful)
                    showMessage("代码已复制!");
                else
                    showMessage("复制失败");
            } catch (err) {
                showMessage("复制失败: " + err);
            }
            document.body.removeChild(textArea);
        }
        document.getElementById('shareLevelBtn').addEventListener('click', ()=>{
            const encoded = encodeLevel(targetEquation, currentDifficulty);
            if (encoded) {
                if (navigator.clipboard && navigator.clipboard.writeText)
                    navigator.clipboard.writeText(encoded).then(()=>showMessage("关卡代码已复制!")).catch(err=>{
                        fallbackCopyTextToClipboard(encoded);
                    }
                    );
                else
                    fallbackCopyTextToClipboard(encoded);
            } else
                showMessage("生成分享代码失败!");
        }
        );
        document.getElementById('loadLevelBtn').addEventListener('click', ()=>{
            showModal('loadLevelModal');
        }
        );
        document.getElementById('closeLoadLevelModalBtn').addEventListener('click', ()=>{
            document.getElementById('levelCodeInput').value = '';
            hideModal('loadLevelModal');
        }
        );
        document.getElementById('submitLoadLevelBtn').addEventListener('click', ()=>{
            const code = document.getElementById('levelCodeInput').value;
            if (code) {
                const decodedData = decodeLevel(code.trim());
                if (decodedData && decodedData.equation.length >= MIN_EQUATION_LENGTH && decodedData.equation.length <= DEFAULT_MAX_EQUATION_LENGTH && isValidEquation(decodedData.equation.split(''), true)) {
                    isCustomLevel = true;
                    startGame(decodedData.equation, decodedData.difficulty);
                    saveDifficulty();
                    hideModal('loadLevelModal');
                    document.getElementById('levelCodeInput').value = '';
                    showMessage(`已载入 ${difficultySetting[decodedData.difficulty].name} 难度分享关卡!`);
                } else
                    showMessage("无效或已损坏的关卡代码");
            }
        }
        );
        document.getElementById('copyGameStateBtn').addEventListener('click', () => {
            const gameState = {
                length: debugSettings.unknownLengthMode ? (COLS > 0 ? COLS : (targetEquation ? targetEquation.length : DEFAULT_MAX_EQUATION_LENGTH)) : (COLS > 0 ? COLS : targetEquation.length),
                rows: [],
                absentChars: Array.from(document.querySelectorAll('.key.absent, .key.disabled-permanently'))
                                .map(k => k.dataset.char).filter(c => c && c !== '>' && c !== '=') 
            };

            const numRowsToCapture = Math.min(currentRow + 1, ROWS);
            for (let r = 0; r < numRowsToCapture; r++) {
                const rowData = [];
                let actualEffectiveCols = 0;
                if (debugSettings.unknownLengthMode) {
                    let lastFilled = -1;
                    for(let c_idx = (r === currentRow ? guessedEquation.length -1 : (guessedEquationsHistory[r] ? guessedEquationsHistory[r].length -1 : DEFAULT_MAX_EQUATION_LENGTH -1)); c_idx >=0; c_idx--) {
                        const charInGuess = (r === currentRow) ? guessedEquation[c_idx] : (guessedEquationsHistory[r] ? guessedEquationsHistory[r][c_idx] : null);
                         const tileEl = document.getElementById(`tile-${r}-${c_idx}`);
                        if ((charInGuess && charInGuess.trim() !== '') || (tileEl && tileEl.textContent.trim() !== '' && !tileEl.classList.contains('unknown-length'))) {
                            lastFilled = c_idx;
                            break;
                        }
                    }
                    actualEffectiveCols = lastFilled + 1;
                } else {
                     actualEffectiveCols = gameState.length;
                }
                 if (actualEffectiveCols === 0 && r === currentRow && guessedEquation.join('').trim() === '') {
                     continue;
                 }


                for (let c = 0; c < actualEffectiveCols; c++) {
                    const tile = document.getElementById(`tile-${r}-${c}`);
                    let char = '';
                    let state = 'empty';
                    if (tile) {
                        const tileText = tile.textContent.trim();
                        char = tileText === '×' ? '*' : (tileText === '÷' ? '/' : tileText);
                        if (tile.classList.contains('correct')) state = 'correct';
                        else if (tile.classList.contains('present')) state = 'present';
                        else if (tile.classList.contains('absent') || (tile.classList.contains('filled') && char !== '')) state = 'empty';
                    }
                     if (char === '' && state !== 'empty') state = 'empty'; 
                     if (char !== '' && (state === 'empty' || state === '')) { 
                         if(document.getElementById(`tile-${r}-${c}`).classList.contains('filled')) state = 'empty'; 
                     }
                    rowData.push({ char, state });
                }
                if(rowData.some(cell => cell.char !== '')) {
                    gameState.rows.push(rowData);
                }
            }
             if (gameState.rows.length === 0 && currentRow === 0 && currentCol === 0) {
                 gameState.rows.push(Array(gameState.length).fill({char:'', state:'empty'}));
             }


            const gameStateString = JSON.stringify(gameState);
            if (navigator.clipboard && navigator.clipboard.writeText) {
                navigator.clipboard.writeText(gameStateString)
                    .then(() => showMessage("当前局面码已复制到剪贴板!"))
                    .catch(err => fallbackCopyTextToClipboard(gameStateString));
            } else {
                fallbackCopyTextToClipboard(gameStateString);
            }
        });


        function animateTitleFall() {
            if (!titleFallAnimation.active) return;
            const el = titleFallAnimation.element;
            titleFallAnimation.vy += titleFallAnimation.gravity;
            titleFallAnimation.y += titleFallAnimation.vy;
            el.style.top = `${titleFallAnimation.y}px`;
            el.style.transform = 'translateX(-50%)';

            if (titleFallAnimation.type === 'sumzle-fall' && titleFallAnimation.y > window.innerHeight + el.offsetHeight) {
                titleFallAnimation.active = false;
                el.style.opacity = '0';
                if (titleFallAnimation.onComplete) titleFallAnimation.onComplete();
            } else if (titleFallAnimation.type === 'quark-fall' && titleFallAnimation.y >= titleFallAnimation.targetY) {
                titleFallAnimation.active = false;
                el.style.top = `${titleFallAnimation.targetY}px`;
                el.style.opacity = '1';
                 if (titleFallAnimation.originalComputedTransition) {
                     el.style.transition = titleFallAnimation.originalComputedTransition;
                 } else {
                    el.style.transition = 'top .8s cubic-bezier(0.6, -0.28, 0.735, 0.045), opacity .5s ease-out';
                 }
                if (titleFallAnimation.onComplete) titleFallAnimation.onComplete();
            }
            if (titleFallAnimation.active) {
                requestAnimationFrame(animateTitleFall);
            }
        }

        function startTitleFallAnimation(element, type, onCompleteCallback) {
            if (!titleFallAnimation.originalComputedTransition) {


titleFallAnimation.originalComputedTransition = getComputedStyle(element).transition;
titleFallAnimation.originalComputedTop = getComputedStyle(element).top;
}
element.style.transition = 'none';

titleFallAnimation.active = true;
titleFallAnimation.element = element;
titleFallAnimation.type = type;
titleFallAnimation.onComplete = onCompleteCallback;

const rect = element.getBoundingClientRect();
        const computedStyle = getComputedStyle(element);

        if (type === 'sumzle-fall') {
            titleFallAnimation.y = parseFloat(computedStyle.top) || (rect.top + window.scrollY);
            titleFallAnimation.vy = 0;
            element.style.opacity = '1';
        } else if (type === 'quark-fall') {
            titleFallAnimation.y = -(rect.height + 50);
            titleFallAnimation.vy = titleFallAnimation.initialVyForQuark;
            titleFallAnimation.targetY = parseFloat(titleFallAnimation.originalComputedTop);
            element.style.opacity = '0';
        }
        element.style.left = '50%';
        element.style.transform = 'translateX(-50%)';
        animateTitleFall();
    }

    function handleCombinedTitleClick() {
        if (titleFallAnimation.active) return;

        if (quarkModeActive) {
            const currentText = Array.from(headerTitleElement.querySelectorAll('.title-char')).map(s => s.textContent).join('');
            if (currentText === QUARK_TITLE_TEXT) {
                quarkDebugClickCount++;
                if (quarkDebugClickCount >= QUARK_DEBUG_CLICK_THRESHOLD) {
                    quarkDebugClickCount = 0;
                    prepareAndShowDebugModal();
                }
            }
        } else if (!sumzleEasterEggActivated) {
            sumzleTitleClickCount++;
            if (sumzleTitleClickCount >= SUMZLE_CLICK_THRESHOLD) {
                sumzleEasterEggActivated = true;
                 if (!titleFallAnimation.originalComputedTop) {
                     titleFallAnimation.originalComputedTop = getComputedStyle(headerTitleElement).top;
                 }
                headerTitleElement.style.pointerEvents = 'none';
                startTitleFallAnimation(headerTitleElement, 'sumzle-fall', ()=>{
                    triggerQuarkModeAfterFall();
                });
            }
        }
    }
    headerTitleElement.addEventListener('click', handleCombinedTitleClick);


    function triggerQuarkModeAfterFall() {
        if (!quarkModeActive) {
            quarkModeActive = true;
            setupTitleSpans(QUARK_TITLE_TEXT);
            headerTitleElement.style.opacity = '0';
            headerTitleElement.style.top = `-${headerTitleElement.offsetHeight + 50}px`;
            headerTitleElement.style.transition = 'none';

            requestAnimationFrame(()=>{
                startTitleFallAnimation(headerTitleElement, 'quark-fall', ()=>{
                    headerTitleElement.style.pointerEvents = 'auto';
                    setHeaderTitleState('quark');
                });
            });
        }
    }

    function prepareAndShowDebugModal() {
        document.getElementById('debugCustomExpr').value = debugSettings.customExpression;
        document.getElementById('debugLockLength').value = debugSettings.lockedLength;
        document.getElementById('debugMaxGenAttempts').value = debugSettings.maxGenAttempts;
        document.getElementById('debugDisableMax').checked = debugSettings.disableMaxLength;
        document.getElementById('debugGeneratedExprDisplay').value = "";
        document.getElementById('debugBgParticles').value = debugSettings.customBgParticleCount;
        document.getElementById('debugPsychedelicBgToggle').checked = debugSettings.psychedelicBgActive;

        document.getElementById('debugUnknownLengthToggle').checked = debugSettings.unknownLengthMode;
        document.getElementById('debugOneTryModeToggle').checked = debugSettings.oneTryMode;
        document.getElementById('debugMirrorInputToggle').checked = debugSettings.mirrorInputMode;
        document.getElementById('debugRandomKeyboardLayoutToggle').checked = debugSettings.randomKeyboardLayout;
        document.getElementById('debugMisleadingFeedbackRate').value = debugSettings.misleadingFeedbackRate;
        document.getElementById('debugSuddenDeathTimerToggle').checked = debugSettings.suddenDeathTimer;
        document.getElementById('debugVanishingInkToggle').checked = debugSettings.vanishingInkMode;
        document.getElementById('debugGrayKeysUnclickableToggle').checked = debugSettings.grayKeysUnclickable;
        document.getElementById('debugCurrentTargetDisplay').value = targetEquation;


        showModal('debugModal');
    }

    document.getElementById('debugLogTargetBtn').addEventListener('click', () => {
         console.log("Current Target Equation:", targetEquation);
         showMessage("目标已记录到控制台", 1500);
    });

    document.getElementById('applyDebugSettingsBtn').addEventListener('click', () => {
        debugSettings.customExpression = document.getElementById('debugCustomExpr').value.trim();
        const lockLengthVal = parseInt(document.getElementById('debugLockLength').value);
        debugSettings.lockedLength = isNaN(lockLengthVal) || lockLengthVal < MIN_EQUATION_LENGTH ? 0 : lockLengthVal;
        if (lockLengthVal > 0 && lockLengthVal < MIN_EQUATION_LENGTH) {
             showMessage(`调试: 锁定长度必须至少为 ${MIN_EQUATION_LENGTH} 已重置为0`, 2000);
             document.getElementById('debugLockLength').value = 0;
        }

        const maxGenAttemptsVal = parseInt(document.getElementById('debugMaxGenAttempts').value);
        debugSettings.maxGenAttempts = isNaN(maxGenAttemptsVal) || maxGenAttemptsVal <= 0 ? 0 : maxGenAttemptsVal;
        if (maxGenAttemptsVal > 0 && maxGenAttemptsVal < 10) {
            showMessage("调试: 生成尝试上限过低 (至少10) 将使用默认值", 2000);
            document.getElementById('debugMaxGenAttempts').value = 0;
            debugSettings.maxGenAttempts = 0;
        }

        debugSettings.disableMaxLength = document.getElementById('debugDisableMax').checked;

        if (debugSettings.customExpression) {
            debugSettings.useCustomExpressionForNextGame = true;
        } else {
            debugSettings.useCustomExpressionForNextGame = false;
        }

        debugSettings.unknownLengthMode = document.getElementById('debugUnknownLengthToggle').checked;
        debugSettings.oneTryMode = document.getElementById('debugOneTryModeToggle').checked;


debugSettings.mirrorInputMode = document.getElementById('debugMirrorInputToggle').checked;
const oldRandomLayout = debugSettings.randomKeyboardLayout;
debugSettings.randomKeyboardLayout = document.getElementById('debugRandomKeyboardLayoutToggle').checked;
if(oldRandomLayout !== debugSettings.randomKeyboardLayout) initKeyboard();

debugSettings.misleadingFeedbackRate = parseInt(document.getElementById('debugMisleadingFeedbackRate').value) || 0;
if(debugSettings.misleadingFeedbackRate < 0 || debugSettings.misleadingFeedbackRate > 100) debugSettings.misleadingFeedbackRate = 0;
document.getElementById('debugMisleadingFeedbackRate').value = debugSettings.misleadingFeedbackRate;

debugSettings.suddenDeathTimer = document.getElementById('debugSuddenDeathTimerToggle').checked;
debugSettings.vanishingInkMode = document.getElementById('debugVanishingInkToggle').checked;
debugSettings.grayKeysUnclickable = document.getElementById('debugGrayKeysUnclickableToggle').checked;

showMessage("调试设置已应用!", 1500);
    hideModal('debugModal');
});

document.getElementById('closeDebugModalBtn').addEventListener('click', () => {
    hideModal('debugModal');
});

document.getElementById('debugGenerateExprBtn').addEventListener('click', () => {
    const tempExpr = generateRandomEquation();
    document.getElementById('debugGeneratedExprDisplay').value = tempExpr;
});

document.getElementById('debugSoundKeypress').addEventListener('click', () => playSound('keyPress'));
document.getElementById('debugSoundWin').addEventListener('click', () => playSound('success'));
document.getElementById('debugSoundFail').addEventListener('click', () => playSound('failure'));
document.getElementById('debugConfettiBtn').addEventListener('click', () => triggerConfetti());

document.getElementById('debugThemeCycleBtn').addEventListener('click', () => {
    let count = 0;
    const interval = setInterval(() => {
        toggleTheme();
        count++;
        if (count >= 6) clearInterval(interval);
    }, 300);
});

document.getElementById('debugApplyBgParticlesBtn').addEventListener('click', () => {
    const count = parseInt(document.getElementById('debugBgParticles').value);
    debugSettings.customBgParticleCount = isNaN(count) || count < 0 ? 0 : count;
    updateBackgroundStyle();
    showMessage(`背景粒子数已${debugSettings.customBgParticleCount > 0 ? '设为 ' + debugSettings.customBgParticleCount : '重置为默认'}`, 1500);
});

document.getElementById('debugPsychedelicBgToggle').addEventListener('change', (event) => {
    debugSettings.psychedelicBgActive = event.target.checked;
    updateBackgroundStyle();
});

document.getElementById('debugForceWinBtn').addEventListener('click', () => {
    handleEndGame(true, 'WON');
    hideModal('debugModal');
});
document.getElementById('debugForceLoseBtn').addEventListener('click', () => {
    handleEndGame(false, 'LOST');
    hideModal('debugModal');
});
document.getElementById('debugTriggerShakeBtn').addEventListener('click', () => {
    const currentRowEl = document.querySelector(`.board .row:nth-child(${currentRow + 1})`);
    if (currentRowEl) {
        currentRowEl.classList.add('invalid-shake');
        setTimeout(() => currentRowEl.classList.remove('invalid-shake'), 500);
    }
});
document.getElementById('debugClearInputRowBtn').addEventListener('click', () => {
     handleClearAllCurrentRow();
});


document.getElementById('debugRunStressTestBtn').addEventListener('click', async () => {
    const runs = parseInt(document.getElementById('debugStressTestRuns').value) || 100;
    const resultsArea = document.getElementById('debugStressTestResults');
    resultsArea.value = `开始 ${runs} 次压力测试...\n`;
    let successes = 0;
    let totalLength = 0;
    const startTime = performance.now();

    const originalDebugSettings = JSON.parse(JSON.stringify(debugSettings));
    const tempLockedLength = debugSettings.lockedLength;
    const tempDisableMax = debugSettings.disableMaxLength;
    const tempMaxGen = debugSettings.maxGenAttempts;

    for (let i = 0; i < runs; i++) {
        try {
            debugSettings.lockedLength = tempLockedLength;
            debugSettings.disableMaxLength = tempDisableMax;
            debugSettings.maxGenAttempts = tempMaxGen;

            
            const eq = generateRandomEquation();
            if (eq && eq !== generateFallbackEquation()) {
                 if (debugSettings.lockedLength > 0 && eq.length !== debugSettings.lockedLength){
                 } else if (!debugSettings.lockedLength && (eq.length < MIN_EQUATION_LENGTH || (!debugSettings.disableMaxLength && eq.length > DEFAULT_MAX_EQUATION_LENGTH) )) {
                 } else {
                    successes++;
                    totalLength += eq.length;
                 }
            }
             if (i % Math.floor(runs/10) === 0 || i === runs - 1) {
                 resultsArea.value += `完成 ${i+1}/${runs}...\n`;
                 await new Promise(resolve => setTimeout(resolve, 0));
             }
        } catch (e) { }
    }

    debugSettings.lockedLength = originalDebugSettings.lockedLength;
    debugSettings.disableMaxLength = originalDebugSettings.disableMaxLength;
    debugSettings.maxGenAttempts = originalDebugSettings.maxGenAttempts;

    const endTime = performance.now();
    const duration = (endTime - startTime) / 1000;
    const successRate = (successes / runs) * 100;
    const avgLength = successes > 0 ? (totalLength / successes) : 0;

    resultsArea.value += `测试完成!\n成功率: ${successRate.toFixed(2)}% (${successes}/${runs})\n平均长度: ${avgLength.toFixed(2)}\n用时: ${duration.toFixed(3)}s`;
});

document.getElementById('debugNukeStorageBtn').addEventListener('click', () => {
    const nukeModal = document.getElementById('confirmNukeModal');
    const nukeTitle = document.getElementById('confirmNukeTitle');
    const nukeMsg = document.getElementById('confirmNukeMessage');
    const nukeBtn = document.getElementById('executeNukeBtn');

    if (quarkModeActive) {
        nukeTitle.textContent = "确认清除数据";
        nukeTitle.style.color = "var(--color-hard)";
        nukeMsg.textContent = "确定要清除所有本地存储数据吗？包括统计、历史、设置等。此操作将重置游戏到初始状态且无法撤销";
        nukeMsg.style.fontWeight = "normal";
        nukeBtn.textContent = "确认清除本地数据";
        nukeBtn.style.backgroundColor = "var(--color-hard)";
        nukeBtn.style.borderColor = "var(--color-hard)";
    } else {
        nukeTitle.innerHTML = "清除所有数据";
         nukeTitle.style.color = "var(--color-hard)";
        nukeMsg.innerHTML = "确定要清除所有本地存储数据吗？包括统计、历史、设置等。此操作将重置游戏到初始状态且无法撤销！";
        nukeMsg.style.fontWeight = "bold";
        nukeBtn.innerHTML = "确认清除本地数据";
        nukeBtn.style.backgroundColor = "#FF0000";
        nukeBtn.style.borderColor = "#B20000";
    }
     showModal('confirmNukeModal');
});
document.getElementById('executeNukeBtn').addEventListener('click', () => {
    localStorage.clear();
    sessionStorage.clear();
    showMessage("所有本地数据已清除! 正在重载...", 2000);
    setTimeout(() => location.reload(), 2100);
});
document.getElementById('cancelNukeBtn').addEventListener('click', () => hideModal('confirmNukeModal'));

function confirmAndProvideHint() {
    if (!gameActive || isViewingHistoryState || currentRow >= ROWS) {
        showMessage("无法在此时使用提示", 2000);
        return;
    }
    if (gameCountsForStats && hintsUsedThisGame === 0 && !isCustomLevel && !isViewingHistoryState) {
        showModal('hintConfirmationModal');
    } else {
        actuallyProvideHint();
    }
}

document.getElementById('confirmUseHintBtn').addEventListener('click', () => {
    hideModal('hintConfirmationModal');
    gameCountsForStats = false;
    actuallyProvideHint();
});
document.getElementById('cancelUseHintBtn').addEventListener('click', () => {
    hideModal('hintConfirmationModal');
});

function isCompletingHint(hintIdx) {
    const displayCols = debugSettings.unknownLengthMode ? DEFAULT_MAX_EQUATION_LENGTH : (COLS > 0 ? COLS : targetEquation.length);
    let otherDifferences = 0;
    for (let i = 0; i < Math.min(displayCols, targetEquation.length); i++) {
        if (i === hintIdx) continue;
        const tile = document.getElementById(`tile-${currentRow}-${i}`);
        if (guessedEquation[i] !== targetEquation[i] && !(tile && tile.classList.contains('hint-locked') && tile.classList.contains('correct'))) {
            otherDifferences++;
        }
    }
    return otherDifferences === 0;
}

function actuallyProvideHint() {
    hintsUsedThisGame++;
    playSound('hint');

    const displayCols = debugSettings.unknownLengthMode ? DEFAULT_MAX_EQUATION_LENGTH : (COLS > 0 ? COLS : targetEquation.length);
    let potentialGreenHints = [];
    let potentialYellowHints = [];

    for (let i = 0; i < Math.min(displayCols, targetEquation.length); i++) {
        const tile = document.getElementById(`tile-${currentRow}-${i}`);
        if (tile && !tile.classList.contains('hint-locked') && guessedEquation[i] !== targetEquation[i]) {
             if (!isCompletingHint(i)) {
                potentialGreenHints.push(i);
            }
        }
    }

    const targetCharCounts = {};
    for (const char of targetEquation) {
        targetCharCounts[char] = (targetCharCounts[char] || 0) + 1;
    }

    const currentGuessCharCounts = {};
     for(let i = 0; i < currentCol; i++){
        if(guessedEquation[i]){
            const tile = document.getElementById(`tile-${currentRow}-${i}`);
            if(tile && (tile.classList.contains('correct') || tile.classList.contains('present'))) {
                 currentGuessCharCounts[guessedEquation[i]] = (currentGuessCharCounts[guessedEquation[i]] || 0) + 1;
            }
        }
    }


    for (const char of Object.keys(targetCharCounts)) {
        const key = document.querySelector(`.key[data-char="${char}"]`);
        if (key && !key.classList.contains('correct')) {
            if (!key.classList.contains('present')) {
               potentialYellowHints.push(char);
            }
        }
    }

    const hintTypeDecision = Math.random();
    let hintGiven = false;

    if (hintTypeDecision < 0.65 && potentialGreenHints.length > 0) {
        const hintIndex = potentialGreenHints[Math.floor(Math.random() * potentialGreenHints.length)];
        const correctChar = targetEquation[hintIndex];
        const tile = document.getElementById(`tile-${currentRow}-${hintIndex}`);

        if (tile) {
            guessedEquation[hintIndex] = correctChar;
            tile.textContent = displayChar(correctChar);
            tile.classList.remove('absent', 'present', 'unknown-length');
            tile.classList.add('filled', 'correct', 'hint-locked', 'hinted-briefly');
            setTimeout(() => tile.classList.remove('hinted-briefly'), 800);
            updateKeyboardColors([correctChar], ['correct']);
            hintGiven = true;
            currentCol = 0; 
            for (let k=0; k<displayCols; k++) {
                if (document.getElementById(`tile-${currentRow}-${k}`).textContent !== '') currentCol = k+1;
                else break;
            }
        }
    } else if (potentialYellowHints.length > 0) {
        const charToHint = potentialYellowHints[Math.floor(Math.random() * potentialYellowHints.length)];
        updateKeyboardColors([charToHint], ['present']);
        hintGiven = true;
    } else if (potentialGreenHints.length > 0) {
         const hintIndex = potentialGreenHints[Math.floor(Math.random() * potentialGreenHints.length)];
        const correctChar = targetEquation[hintIndex];
        const tile = document.getElementById(`tile-${currentRow}-${hintIndex}`);
        if (tile) {
            guessedEquation[hintIndex] = correctChar;
            tile.textContent = displayChar(correctChar);
            tile.classList.remove('absent', 'present', 'unknown-length');
            tile.classList.add('filled', 'correct', 'hint-locked', 'hinted-briefly');
            setTimeout(() => tile.classList.remove('hinted-briefly'), 800);
            updateKeyboardColors([correctChar], ['correct']);
            hintGiven = true;
            currentCol = 0; 
            for (let k=0; k<displayCols; k++) {
                if (document.getElementById(`tile-${currentRow}-${k}`).textContent !== '') currentCol = k+1;
                else break;
            }
        }
    }


    if (!hintGiven) {
        showMessage("当前没有提示可提供", 2000);
        hintsUsedThisGame--;
    }
    performLiveStatusUpdate();
}


document.getElementById('hintBtn').addEventListener('click', confirmAndProvideHint);


window.addEventListener('beforeunload', (event) => {
if (gameActive && targetEquation && (currentCol > 0 || (COLS > 0 && currentRow > 0) || (isCustomLevel && gameStartTime === 0))) {

const confirmationMessage = '您有未完成的游戏进度，确定要放弃吗？';
event.preventDefault();
event.returnValue = confirmationMessage;
recordGameInHistory(false, ABANDONED_STATUS);
return confirmationMessage;
}
});

setupTitleSpans(ORIGINAL_TITLE_TEXT);
titleFallAnimation.originalComputedTop = getComputedStyle(headerTitleElement).top;
titleFallAnimation.originalComputedTransition = getComputedStyle(headerTitleElement).transition;
headerTitleElement.style.transform = 'translateX(-50%)';

updateStatsDisplay(true, false);
resetGame();
applyTheme(currentTheme);


}
);
</script>

</body>
</html>
