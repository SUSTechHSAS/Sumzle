<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Sumzle Solver</title>
    <style>
        :root {
            --font-family: "Segoe UI", -apple-system, BlinkMacSystemFont, Roboto, "Helvetica Neue", Arial, "Noto Sans", sans-serif;
            --color-background: #f8f9fa;
            --color-surface: #ffffff;
            --color-text: #212529;
            --color-text-secondary: #6c757d;
            --color-border: #dee2e6;
            --color-border-light: #f1f3f5;
            --color-divider: #e9ecef;
            --color-correct: #28a745;
            --color-present: #ffc107;
            --color-absent: #7a7a7a;
            --color-key-feedback-text: #ffffff;
            --fluent-blue: #007bff;
            --fluent-blue-hover: #0069d9;
            --fluent-blue-active: #0056b3;
            --color-danger: #dc3545;
            --tile-border-radius: 6px;
            --button-border-radius: 5px;
            --modal-border-radius: 8px;
            --shadow-xs: 0 1px 2px rgba(0,0,0,0.05);
            --shadow-s: 0 2px 4px rgba(0,0,0,0.07);
            --shadow-m: 0 4px 8px rgba(0,0,0,0.08), 0 0 1px rgba(0,0,0,0.06);
            --shadow-l: 0 8px 16px rgba(0,0,0,0.1), 0 0 2px rgba(0,0,0,0.07);
        }

        body.dark-theme {
            --color-background: #1a1a1d;
            --color-surface: #2c2f33;
            --color-text: #f0f0f0;
            --color-text-secondary: #a0a0a0;
            --color-border: #424549;
            --color-border-light: #36393f;
            --color-divider: #36393f;
        }

        body {
            font-family: var(--font-family);
            margin: 0;
            padding: 0;
            background-color: var(--color-background);
            color: var(--color-text);
            min-height: 100vh;
            transition: background-color .3s ease-in-out, color .3s ease-in-out;
        }

        header {
            width: 100%;
            padding: 15px 0;
            border-bottom: 1px solid var(--color-divider);
            text-align: center;
            background-color: var(--color-surface);
            box-shadow: var(--shadow-s);
            position: sticky;
            top: 0;
            z-index: 100;
        }

        .header-title {
            font-weight: 800;
            font-size: 2rem;
            background: linear-gradient(45deg, #ff6b6b, #4ecdc4, #45b7d1);
            background-size: 300% 300%;
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
            animation: titleShimmer 3s ease-in-out infinite;
        }

        @keyframes titleShimmer {
            0%, 100% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            display: flex;
            gap: 30px;
        }

        .left-panel, .right-panel {
            flex: 1;
            background-color: var(--color-surface);
            border-radius: var(--modal-border-radius);
            padding: 25px;
            box-shadow: var(--shadow-m);
            height: fit-content;
        }

        .section-title {
            font-size: 1.4rem;
            font-weight: 600;
            margin-bottom: 20px;
            color: var(--color-text);
            border-bottom: 2px solid var(--color-divider);
            padding-bottom: 10px;
        }

        .input-group {
            margin-bottom: 25px;
        }

        .input-label {
            display: block;
            margin-bottom: 8px;
            font-weight: 500;
            color: var(--color-text);
        }

        .length-input {
            width: 100px;
            padding: 10px;
            border: 2px solid var(--color-border);
            border-radius: var(--button-border-radius);
            font-size: 1rem;
            background-color: var(--color-background);
            color: var(--color-text);
            transition: border-color 0.3s ease;
        }

        .length-input:focus {
            outline: none;
            border-color: var(--fluent-blue);
        }
        
        .constraint-board-wrapper {
            width: 100%;
            overflow-x: auto;
            padding-bottom: 10px; 
        }

        .constraint-board {
            display: flex;
            flex-direction: column;
            gap: 10px;
            min-width: min-content;
        }

        .constraint-row {
            display: grid;
            gap: 8px;
        }

        .constraint-tile {
            width: 50px;
            height: 50px;
            border: 2px solid var(--color-border-light);
            border-radius: var(--tile-border-radius);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.2rem;
            font-weight: 600;
            cursor: pointer;
            background-color: var(--color-surface);
            color: var(--color-text);
            transition: all 0.3s ease;
            user-select: none;
        }

        .constraint-tile:hover {
            transform: scale(1.05);
            box-shadow: var(--shadow-s);
        }

        .constraint-tile.correct {
            background-color: var(--color-correct);
            border-color: var(--color-correct);
            color: var(--color-key-feedback-text);
        }

        .constraint-tile.present {
            background-color: var(--color-present);
            border-color: var(--color-present);
            color: var(--color-key-feedback-text);
        }

        .constraint-tile.empty {
            opacity: 0.8; 
        }
        .constraint-tile.empty:not(:empty) { 
             background-color: var(--color-absent);
             color: var(--color-key-feedback-text);
             border-color: var(--color-absent);
             opacity: 0.7;
        }


        .keyboard {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(45px, 1fr));
            gap: 8px;
            margin-bottom: 20px;
        }

        .key {
            padding: 12px 0;
            border: 2px solid var(--color-border);
            border-radius: var(--button-border-radius);
            background-color: var(--color-background);
            color: var(--color-text);
            font-size: 1.1rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
            text-align: center;
            user-select: none;
        }

        .key:hover {
            background-color: var(--color-border);
            transform: translateY(-2px);
        }

        .key:active {
            transform: translateY(0);
        }
        
        .control-buttons {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-bottom: 20px;
        }

        .btn {
            padding: 12px 20px;
            border: none;
            border-radius: var(--button-border-radius);
            font-size: 1rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
            flex-grow: 1;
            min-width: 120px;
        }

        .btn-primary {
            background-color: var(--fluent-blue);
            color: white;
        }
        .btn-primary:hover { background-color: var(--fluent-blue-hover); }
        .btn-secondary { background-color: var(--color-border); color: var(--color-text); }
        .btn-secondary:hover { background-color: var(--color-divider); }
        .btn-danger { background-color: var(--color-danger); color: white; }
        .btn-danger:hover { background-color: #c82333; }

        .progress-container { margin: 20px 0; display: none; }
        .progress-bar { width: 100%; height: 20px; background-color: var(--color-border-light); border-radius: 10px; overflow: hidden; position: relative; }
        .progress-fill { height: 100%; background: linear-gradient(90deg, var(--fluent-blue), var(--color-correct)); width: 0%; transition: width 0.3s ease; }
        .progress-text { text-align: center; margin-top: 8px; font-size: 0.9rem; color: var(--color-text-secondary); }

        .results-container { max-height: 300px; overflow-y: auto; border: 2px solid var(--color-border); border-radius: var(--button-border-radius); padding: 15px; background-color: var(--color-background); }
        .result-item { padding: 10px; margin: 5px 0; background-color: var(--color-surface); border-radius: var(--button-border-radius); border-left: 4px solid var(--color-correct); font-family: monospace; font-size: 1.1rem; box-shadow: var(--shadow-xs); transition: transform 0.2s ease; }
        .result-item:hover { transform: translateX(5px); }
        .result-item.recommended {
            border-left-color: var(--fluent-blue);
            background-color: color-mix(in srgb, var(--fluent-blue) 5%, var(--color-surface));
        }
         .recommended-result-item {
            padding: 12px 15px;
            margin: 0; 
            background-color: color-mix(in srgb, var(--fluent-blue) 10%, var(--color-surface));
            border-radius: var(--button-border-radius);
            border-left: 5px solid var(--fluent-blue);
            font-family: monospace;
            font-size: 1.2rem;
            font-weight: bold;
            box-shadow: var(--shadow-s);
        }


        .stats { display: grid; grid-template-columns: repeat(2, 1fr); gap: 15px; margin-top: 20px; }
        .stat-card { background-color: var(--color-background); padding: 15px; border-radius: var(--button-border-radius); text-align: center; box-shadow: var(--shadow-xs); }
        .stat-number { font-size: 1.8rem; font-weight: 700; color: var(--fluent-blue); }
        .stat-label { font-size: 0.9rem; color: var(--color-text-secondary); margin-top: 5px; }

        .theme-toggle { position: fixed; top: 20px; right: 20px; width: 50px; height: 50px; border-radius: 50%; border: none; background-color: var(--color-surface); color: var(--color-text); font-size: 1.5rem; cursor: pointer; box-shadow: var(--shadow-m); transition: all 0.3s ease; z-index: 101; }
        .theme-toggle:hover { transform: scale(1.1); }

        .error-message { background-color: var(--color-danger); color: white; padding: 10px; border-radius: var(--button-border-radius); margin: 10px 0; display: none; }

        .help-section { background-color: var(--color-background); padding: 15px; border-radius: var(--button-border-radius); margin-bottom: 20px; border-left: 4px solid var(--fluent-blue); }
        .help-title { font-weight: 600; margin-bottom: 8px; color: var(--fluent-blue); }
        .help-text { font-size: 0.9rem; color: var(--color-text-secondary); line-height: 1.4; }
        
        .constraint-explanation { font-size: 0.8rem; color: var(--color-text-secondary); margin-top: 5px; text-align: center; }
        .keyboard-explanation { font-size: 0.8rem; color: var(--color-text-secondary); margin-top: -10px; margin-bottom: 15px; text-align: center; }

        .result-count { font-weight: 600; color: var(--color-correct); margin-bottom: 15px; font-size: 1.1rem; }
        .prob-item { display: flex; justify-content: space-between; align-items: center; padding: 8px 10px; margin-bottom: 4px; background-color: var(--color-surface); border-radius: var(--button-border-radius); border-left: 3px solid var(--fluent-blue); font-size: 0.9rem; }
        .prob-char-display { font-weight: bold; font-family: monospace; font-size: 1.1em; min-width: 30px; text-align: center; padding: 2px 6px; border: 1px solid var(--color-border); border-radius: var(--tile-border-radius); background-color: var(--color-background); }
        .prob-bar-container { flex-grow: 1; height: 12px; background-color: var(--color-border-light); border-radius: 6px; margin: 0 10px; overflow: hidden; }
        .prob-bar { height: 100%; background-color: var(--fluent-blue); width: 0%; transition: width 0.5s ease-out; }
        .prob-value { color: var(--color-text-secondary); min-width: 45px; text-align: right; font-size: 0.9em; }

        .optimization-info { background-color: var(--color-background); padding: 12px; border-radius: var(--button-border-radius); margin-bottom: 15px; border-left: 3px solid var(--color-correct); font-size: 0.85rem; color: var(--color-text-secondary); }
        .loading { opacity: 0.6; pointer-events: none; }

        .tile-context-menu {
            background-color: var(--color-surface);
            border: 1px solid var(--color-border);
            border-radius: var(--button-border-radius);
            box-shadow: var(--shadow-m);
            padding: 8px;
            display: flex;
            gap: 6px;
            z-index: 1000;
            position: absolute;
            transform: scale(0.8) translateY(-10px);
            opacity: 0;
            pointer-events: none;
            transition: transform 0.2s cubic-bezier(0.175, 0.885, 0.32, 1.275), opacity 0.2s ease-out;
        }
        .tile-context-menu.visible {
            transform: scale(1) translateY(0);
            opacity: 1;
            pointer-events: auto;
        }


        .context-menu-btn {
            width: 38px;
            height: 38px;
            border-radius: 50%;
            border: 2px solid transparent;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.2rem;
            font-weight: bold;
            transition: all 0.2s ease;
            color: var(--color-key-feedback-text);
        }

        .context-menu-btn:hover:not(:disabled) {
            transform: scale(1.1);
            border-color: var(--fluent-blue);
        }

        .context-menu-btn.correct-btn { background-color: var(--color-correct); }
        .context-menu-btn.present-btn { background-color: var(--color-present); }
        .context-menu-btn.empty-btn { background-color: var(--color-absent); }
        .context-menu-btn.delete-btn { 
            background-color: var(--color-border-light); 
            color: var(--color-text-secondary); 
            font-size: 1.3rem;
        }
        .context-menu-btn.delete-btn:hover:not(:disabled) { 
            background-color: var(--color-danger); 
            color: white; 
            border-color: transparent;
        }
        
        .context-menu-btn:disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }
        .context-menu-btn.delete-btn:disabled {
             background-color: var(--color-border-light);
             color: var(--color-text-secondary);
             opacity: 0.5;
        }


        @media (max-width: 768px) {
            .container { flex-direction: column; padding: 10px; gap: 20px; }
            .constraint-tile { width: 40px; height: 40px; font-size: 1rem; }
            .keyboard { grid-template-columns: repeat(auto-fill, minmax(40px, 1fr)); }
            .theme-toggle { top: 10px; right: 10px; width: 40px; height: 40px; font-size: 1.2rem; }
             .tile-context-menu { gap: 4px; padding: 6px;}
            .context-menu-btn { width: 34px; height: 34px; font-size: 1rem; }
        }
         .input-group.import-group { margin-top: 20px; }
        .import-input {
            width: calc(100% - 24px);
            padding: 10px;
            border: 2px solid var(--color-border);
            border-radius: var(--button-border-radius);
            font-size: 0.9rem;
            background-color: var(--color-background);
            color: var(--color-text);
            transition: border-color 0.3s ease;
            margin-bottom: 10px;
        }
        .import-input:focus {
            outline: none;
            border-color: var(--fluent-blue);
        }
        .import-btn {
            width: 100%;
        }
    </style>
</head>
<body>
    <button class="theme-toggle" id="themeToggle">â˜€ï¸</button>
    
    <header>
        <h1 class="header-title">Sumzle Solver</h1>
    </header>

    <div class="container">
        <div class="left-panel">
            <div class="section-title">ğŸ¯ æ±‚è§£é…ç½®</div>
            
            <div class="help-section">
                <div class="help-title">ä½¿ç”¨è¯´æ˜</div>
                <div class="help-text">
                    1. è®¾ç½®è¡¨è¾¾å¼é•¿åº¦ã€‚<br>
                    2. ç‚¹å‡»æ ¼å­é€‰æ‹©ä½ç½®ï¼Œå†ç‚¹å‡»ä¸‹æ–¹å­—ç¬¦è¾“å…¥ã€‚å†æ¬¡ç‚¹å‡»å·²é€‰ä¸­çš„æ ¼å­ï¼Œä¼šå¼¹å‡ºèœå•ï¼Œå¯æ›´æ”¹æ ¼å­é¢œè‰²æ ‡è®°æˆ–åˆ é™¤å­—ç¬¦ã€‚<br>
                       Â Â Â â€¢ <span style="color:var(--color-correct); font-weight:bold;">ç»¿è‰²</span>: å­—ç¬¦å’Œä½ç½®å‡æ­£ç¡®ã€‚<br>
                       Â Â Â â€¢ <span style="color:var(--color-present); font-weight:bold;">é»„è‰²</span>: å­—ç¬¦å­˜åœ¨ï¼Œä½†ä½ç½®é”™è¯¯ã€‚<br>
                       Â Â Â â€¢ <span style="color:var(--color-absent); font-weight:bold;">ç°è‰²</span>: (è‹¥æ ¼å­æœ‰å­—ç¬¦) æ­¤å­—ç¬¦ä¸åœ¨æ­¤æ ¼ã€‚è¿™æœ‰åŠ©äºç¡®å®šå­—ç¬¦åœ¨è§£ä¸­çš„ç²¾ç¡®æ•°é‡ã€‚è‹¥æŸå­—ç¬¦æ‰€æœ‰å®ä¾‹å‡ä¸ºç°è‰²ï¼ˆä¸”æ— ç»¿è‰²/é»„è‰²ï¼‰ï¼Œåˆ™è¯¥å­—ç¬¦ä¸åº”åœ¨ç­”æ¡ˆä¸­ã€‚<br>
                    3. å¯æ·»åŠ å¤šè¡ŒçŒœæµ‹ä½œä¸ºçº¦æŸã€‚ <br>
                    4. ç‚¹å‡»å¼€å§‹æ±‚è§£ã€‚<br>
                </div>
            </div>

             <div class="input-group import-group">
                <label class="input-label" for="importGameStateInput">å¯¼å…¥æ¸¸æˆå±€é¢ç  (Sumzle -> Solver):</label>
                <textarea id="importGameStateInput" class="import-input" rows="2" placeholder="ç²˜è´´ä» Sumzle æ¸¸æˆå¤åˆ¶çš„å±€é¢ç ..."></textarea>
                <button class="btn btn-secondary import-btn" id="importGameStateBtn">ğŸ“¥ å¯¼å…¥å±€é¢</button>
            </div>
            <div class="input-group import-group">
                <label class="input-label" for="importSearchStateBtn">å¯¼å…¥/å¯¼å‡ºæœç´¢çŠ¶æ€</label>
                <p class="help-text" style="font-size: 0.8rem; margin-top: -5px; margin-bottom: 10px;">ç”¨äºåˆ†å¤šæ¬¡åœ°è¿›è¡Œå¤§å‹æœç´¢ã€‚</p>
                <input type="file" id="searchStateFileInput" accept=".json,application/json" style="display: none;">
                <button class="btn btn-secondary import-btn" id="importSearchStateBtn">ğŸ“¥ å¯¼å…¥çŠ¶æ€æ–‡ä»¶</button>
            </div>
            <div class="optimization-info">
                <strong>ğŸš€ ä¼˜åŒ–ç‰¹æ€§:</strong> æ™ºèƒ½å‰ªæ â€¢ ç­‰å·å·¦è¾¹æ“ä½œæ•°â‰¤30 â€¢ æ”¯æŒé˜¶ä¹˜ â€¢ ä¼˜å…ˆçº§æœç´¢ â€¢ ä¿®å¤ç­‰å·å³è¾¹é™åˆ¶ â€¢ å¤šè¡Œçº¦æŸ â€¢ çº¦æŸé¢„å¤„ç† â€¢ `[]`å†…ä»…`a/b`
            </div>

            <div class="input-group">
                <label class="input-label" for="lengthInput">è¡¨è¾¾å¼é•¿åº¦ï¼š</label>
                <input type="number" id="lengthInput" class="length-input" min="3" max="15" value="6" />
            </div>

            <div class="input-group">
                <label class="input-label">çº¦æŸæ¡ä»¶ï¼ˆæ ¼å­ï¼‰ï¼š</label>
                <div class="constraint-board-wrapper">
                    <div class="constraint-board" id="constraintBoard"></div>
                </div>
                <div class="constraint-explanation">
                    å•å‡»æ ¼å­é€‰ä¸­ã€‚å†æ¬¡å•å‡»é€‰ä¸­æ ¼å­ï¼Œå¼¹å‡ºèœå•ä¿®æ”¹é¢œè‰²æˆ–åˆ é™¤ã€‚
                </div>
            </div>

            <div class="input-group">
                <label class="input-label">å­—ç¬¦è¾“å…¥ï¼ˆé”®ç›˜ï¼‰ï¼š</label>
                <div class="keyboard" id="keyboard"></div>
                 <div class="keyboard-explanation">
                    ç‚¹å‡»å­—ç¬¦è¾“å…¥è‡³ä¸Šæ–¹é€‰ä¸­æ ¼å­ã€‚
                </div>
            </div>

            <div class="control-buttons">
                <button class="btn btn-primary" id="solveBtn">ğŸš€ å¼€å§‹æ±‚è§£</button>
                <button class="btn btn-secondary" id="clearBtn">ğŸ§¹ æ¸…ç©º</button>
                <button class="btn btn-secondary" id="addGuessRowBtn">â• æ·»åŠ çŒœæµ‹è¡Œ</button>
                <button class="btn btn-danger" id="stopBtn" style="display: none;">â¹ï¸ åœæ­¢</button>
                <button class="btn btn-secondary" id="exportSearchStateBtn" style="display: none;">ğŸ“¤ å¯¼å‡ºçŠ¶æ€</button>
            </div>

            <div class="progress-container" id="progressContainer">
                <div class="progress-bar">
                    <div class="progress-fill" id="progressFill"></div>
                </div>
                <div class="progress-text" id="progressText">å‡†å¤‡ä¸­...</div>
            </div>

            <div class="error-message" id="errorMessage"></div>
        </div>

        <div class="right-panel">
            <div class="section-title">ğŸ“Š æ±‚è§£ç»“æœ</div>
            
            <div class="stats" id="stats">
                <div class="stat-card">
                    <div class="stat-number" id="foundCount">0</div>
                    <div class="stat-label">æ‰¾åˆ°è§£</div>
                </div>
                <div class="stat-card">
                    <div class="stat-number" id="searchedCount">0</div>
                    <div class="stat-label">å·²æœç´¢</div>
                </div>
                <div class="stat-card">
                    <div class="stat-number" id="timeElapsed">0.0s</div>
                    <div class="stat-label">ç”¨æ—¶</div>
                </div>
                <div class="stat-card">
                    <div class="stat-number" id="searchSpeed">0</div>
                    <div class="stat-label">æœç´¢é€Ÿåº¦/ç§’</div>
                </div>
            </div>

            <div class="section-title" style="margin-top: 30px;">ğŸ—ï¸ å­—ç¬¦æ¦‚ç‡</div>
            <div class="results-container" id="charProbContainer" style="max-height: 250px; margin-top: 10px;">
                <div style="text-align: center; color: var(--color-text-secondary); padding: 20px;">
                    æ±‚è§£åæ˜¾ç¤ºæ¦‚ç‡
                </div>
            </div>
            
            <div class="section-title" style="margin-top: 30px;">â­ æ¨èè§£</div>
            <div class="results-container" id="recommendedResultContainer" style="max-height: 100px; margin-bottom:20px; padding: 10px;">
                <div style="text-align: center; color: var(--color-text-secondary); padding: 20px;">
                    æ±‚è§£åæ˜¾ç¤ºæ¨è
                </div>
            </div>

            <div class="section-title" style="margin-top: 30px;">ğŸ“œ ç»“æœåˆ—è¡¨</div>
            <div class="results-container" id="resultsContainer">
                <div style="text-align: center; color: var(--color-text-secondary); padding: 40px;">
                    ç­‰å¾…æ±‚è§£å¼€å§‹...
                </div>
            </div>
        </div>
    </div>

    <div id="tileContextMenu" class="tile-context-menu" style="display: none;">
        <button data-state="correct" class="context-menu-btn correct-btn" title="Correct (Green)">âœ“</button>
        <button data-state="present" class="context-menu-btn present-btn" title="Present (Yellow)">â—</button>
        <button data-state="empty" class="context-menu-btn empty-btn" title="Absent in this spot (Grey)">âœ•</button>
        <button data-action="delete" class="context-menu-btn delete-btn" title="Delete Character">ğŸ—‘ï¸</button>
    </div>

    <script>
        class OptimizedSumzleSolver {
            constructor() {
                this.length = 6;
                this.guessRowsData = [];
                this.isRunning = false;
                this.shouldStop = false;
                this.results = [];
                this.searchedCount = 0;
                this.startTime = 0;
                this.selectedTile = null; 
                this.globalKnowledge = {};
                this.charProbabilitiesData = [];
                this.lastUIUpdate = 0;
                
                this.validChars = "0123456789+-*/%^=()![]>A";
                this.displayCharsMap = { '*': 'Ã—', '/': 'Ã·' };
                this.actualCharsMap = { 'Ã—': '*', 'Ã·': '/' };
                this.resumeState = null; // ç”¨äºæ¢å¤æœç´¢
                this.exportableState = null;
                
                this.maxOperandValue = 30; 
                this.searchPruningEnabled = true; 

                this.tileContextMenu = document.getElementById('tileContextMenu');
                this.activeContextMenuTile = null;
                
                this.initializeUI();
                this.updateConstraintBoard();
                this.autoAdvanceFocus = true;
            }

            initializeUI() {
                const themeToggle = document.getElementById('themeToggle');
                themeToggle.addEventListener('click', () => this.toggleTheme());

                const lengthInput = document.getElementById('lengthInput');
                lengthInput.addEventListener('change', (e) => {
                    this.hideContextMenu();
                    const newLength = Math.max(3, Math.min(15, parseInt(e.target.value) || this.length));
                    e.target.value = newLength;
                    
                    if (this.selectedTile) { 
                        if (this.selectedTile.colIndex >= newLength) {
                             if (this.selectedTile.element) this.selectedTile.element.style.outline = '';
                             this.selectedTile = null;
                        }
                    }
                    
                    if (newLength === this.length) return;
                    this.length = newLength;

                    this.guessRowsData.forEach((row, rowIndex) => {
                        const newRowArray = Array(this.length).fill(null).map((_, colIndex) => {
                            if (colIndex < row.length && row[colIndex]) {
                                return { ...row[colIndex] };
                            }
                            return { char: '', state: 'empty' };
                        });
                        this.guessRowsData[rowIndex] = newRowArray;
                    });
                    
                    this.updateConstraintBoard(); 
                });

                document.getElementById('solveBtn').addEventListener('click', () => this.solve());
                document.getElementById('clearBtn').addEventListener('click', () => this.clear());
                document.getElementById('stopBtn').addEventListener('click', () => this.stop());
                document.getElementById('addGuessRowBtn').addEventListener('click', () => {
                    this.hideContextMenu();
                    this.addGuessRow();
                });
                 document.getElementById('importGameStateBtn').addEventListener('click', () => this.importGameState());
                document.getElementById('exportSearchStateBtn').addEventListener('click', () => this.exportSearchState());
                // This button now triggers the hidden file input
                document.getElementById('importSearchStateBtn').addEventListener('click', () => {
                    document.getElementById('searchStateFileInput').click();
                });
                // The file input itself handles the import logic when a file is selected
                document.getElementById('searchStateFileInput').addEventListener('change', (event) => this.handleFileImport(event));

                this.createKeyboard();

                this.tileContextMenu.querySelectorAll('.context-menu-btn').forEach(btn => {
                    btn.addEventListener('click', (event) => {
                        event.stopPropagation();
                        const action = btn.dataset.action;
                        const state = btn.dataset.state;
                        this.handleContextMenuAction(action, state);
                    });
                });

                document.addEventListener('click', (event) => {
                    if (this.tileContextMenu.style.display === 'none' && !this.tileContextMenu.classList.contains('visible')) return;

                    const clickedOnSelectedTile = this.selectedTile && event.target.closest('.constraint-tile') === this.selectedTile.element;
                    const clickedOnMenu = event.target.closest('.tile-context-menu');

                    if (!clickedOnSelectedTile && !clickedOnMenu) {
                        this.hideContextMenu();
                    }
                }, true);

                document.addEventListener('keydown', (event) => {
                    if (event.key === 'Escape' && (this.tileContextMenu.style.display !== 'none' || this.tileContextMenu.classList.contains('visible'))) {
                        this.hideContextMenu();
                    }
                });
            }

            showContextMenu(tileElement, rowIndex, colIndex) {
                const tileData = this.guessRowsData[rowIndex][colIndex];
                const hasChar = !!tileData.char;

                this.tileContextMenu.querySelector('[data-state="correct"]').disabled = !hasChar;
                this.tileContextMenu.querySelector('[data-state="present"]').disabled = !hasChar;
                this.tileContextMenu.querySelector('[data-state="empty"]').disabled = !hasChar;
                this.tileContextMenu.querySelector('[data-action="delete"]').disabled = !hasChar;

                const tileRect = tileElement.getBoundingClientRect();
                const menuHeight = this.tileContextMenu.offsetHeight || 50; 
                const menuWidth = this.tileContextMenu.offsetWidth || 180; 

                let top = tileRect.bottom + window.scrollY + 8;
                let left = tileRect.left + window.scrollX + (tileRect.width / 2) - (menuWidth / 2);

                if (top + menuHeight > window.innerHeight + window.scrollY - 10) {
                    top = tileRect.top + window.scrollY - menuHeight - 8;
                }
                if (top < window.scrollY + 5) {
                    top = window.scrollY + 5;
                }
                if (left + menuWidth > window.innerWidth + window.scrollX - 5) {
                    left = window.innerWidth + window.scrollX - menuWidth - 5;
                }
                if (left < window.scrollX + 5) {
                    left = window.scrollX + 5;
                }
                
                this.tileContextMenu.style.top = `${top}px`;
                this.tileContextMenu.style.left = `${left}px`;
                this.tileContextMenu.style.display = 'flex'; 
                requestAnimationFrame(() => {
                    this.tileContextMenu.classList.add('visible');
                });
                this.activeContextMenuTile = { element: tileElement, rowIndex, colIndex };
            }

            hideContextMenu() {
                 this.tileContextMenu.classList.remove('visible');
                 setTimeout(() => {
                    if (!this.tileContextMenu.classList.contains('visible')) {
                         this.tileContextMenu.style.display = 'none';
                    }
                 }, 200); 
                this.activeContextMenuTile = null;
            }

            handleContextMenuAction(action, stateValue) {
                if (!this.activeContextMenuTile) return;

                const { element, rowIndex, colIndex } = this.activeContextMenuTile;
                const tileData = this.guessRowsData[rowIndex][colIndex];

                if (action === 'delete') {
                    tileData.char = '';
                    tileData.state = 'empty';
                } else if (stateValue) {
                    tileData.state = stateValue;
                }

                this.updateTileAppearance(element, tileData);
                this.hideContextMenu();
            }


            addGuessRow() {
                this.hideContextMenu();
                if (this.guessRowsData.length >= 10) { 
                    this.showError("æœ€å¤šåªèƒ½æ·»åŠ 10è¡ŒçŒœæµ‹ã€‚");
                    return;
                }
                this.guessRowsData.push(this.createEmptyRow());
                this.updateConstraintBoard();
            }
            
            createEmptyRow() {
                return Array(this.length).fill().map(() => ({ char: '', state: 'empty' }));
            }

            createKeyboard() {
                const keyboard = document.getElementById('keyboard');
                keyboard.innerHTML = '';
                const chars = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '-', 'Ã—', 'Ã·', '%', '^', '=', '>', '!', 'A', '(', ')', '[', ']', 'âŒ«'];
                
                chars.forEach(char => {
                    const key = document.createElement('div');
                    key.className = 'key';
                    key.textContent = char;
                    const actualChar = this.actualCharsMap[char] || char;
                    key.dataset.char = actualChar;
                    key.addEventListener('click', () => this.handleKeyPress(char, actualChar));
                    keyboard.appendChild(key);
                });
            }

            handleKeyPress(displayChar, actualChar) {
                if (!this.selectedTile || !this.selectedTile.element) return;
                this.hideContextMenu();
                const { rowIndex, colIndex } = this.selectedTile;
                const tileData = this.guessRowsData[rowIndex][colIndex];
                const originalTileElement = this.selectedTile.element;

                if (displayChar === 'âŒ«') {
                    const charExisted = !!tileData.char;
                    tileData.char = '';
                    if (charExisted) {
                        tileData.state = 'empty';
                    }
                } else {
                    tileData.char = actualChar;
                     if (this.autoAdvanceFocus && colIndex < this.length - 1) {
                        this.selectNextTile(rowIndex, colIndex);
                    }
                }
                this.updateTileAppearance(originalTileElement, tileData);
            }

            selectNextTile(currentRowIndex, currentColIndex) {
                const nextColIndex = currentColIndex + 1;
                if (nextColIndex < this.length) {
                    const boardElement = document.getElementById('constraintBoard');
                    const nextTileElement = boardElement.querySelector(`.constraint-tile[data-row-index="${currentRowIndex}"][data-col-index="${nextColIndex}"]`);
                    if (nextTileElement) {
                        if (this.selectedTile && this.selectedTile.element) {
                            this.selectedTile.element.style.outline = '';
                        }
                        this.selectedTile = { element: nextTileElement, rowIndex: currentRowIndex, colIndex: nextColIndex };
                        nextTileElement.style.outline = '3px solid var(--fluent-blue)';
                         if (this.tileContextMenu.style.display !== 'none' || this.tileContextMenu.classList.contains('visible')) {
                            this.hideContextMenu();
                        }
                    }
                }
            }
            
            updateTileAppearance(tileElement, tileData) {
                tileElement.textContent = tileData.char ? (this.displayCharsMap[tileData.char] || tileData.char) : '';
                tileElement.className = 'constraint-tile'; 
                if (tileData.state !== 'empty' && tileData.char) {
                    tileElement.classList.add(tileData.state);
                } else if (tileData.state === 'empty' && tileData.char) {
                     tileElement.classList.add('empty'); 
                } else { 
                    tileElement.classList.add('empty');
                }
            }


            updateConstraintBoard() {
                const boardElement = document.getElementById('constraintBoard');
                boardElement.innerHTML = '';

                if (this.guessRowsData.length === 0) {
                    this.guessRowsData.push(this.createEmptyRow());
                }
                
                this.guessRowsData.forEach((rowData, rIndex) => {
                    const rowDiv = document.createElement('div');
                    rowDiv.className = 'constraint-row';
                    rowDiv.style.gridTemplateColumns = `repeat(${this.length}, 1fr)`;

                    rowData.forEach((tileData, cIndex) => {
                        const tileElement = document.createElement('div');
                        tileElement.dataset.rowIndex = rIndex;
                        tileElement.dataset.colIndex = cIndex;
                        this.updateTileAppearance(tileElement, tileData);
                        
                        tileElement.addEventListener('click', (event) => {
                            event.stopPropagation();
                            const clickedRIndex = parseInt(tileElement.dataset.rowIndex);
                            const clickedCIndex = parseInt(tileElement.dataset.colIndex);

                            if (this.selectedTile && 
                                this.selectedTile.rowIndex === clickedRIndex && 
                                this.selectedTile.colIndex === clickedCIndex) {
                                if ((this.tileContextMenu.style.display !== 'none' || this.tileContextMenu.classList.contains('visible')) && 
                                    this.activeContextMenuTile && 
                                    this.activeContextMenuTile.element === tileElement) {
                                    this.hideContextMenu();
                                } else {
                                    this.showContextMenu(tileElement, clickedRIndex, clickedCIndex);
                                }
                            } else {
                                this.hideContextMenu();
                                if (this.selectedTile && this.selectedTile.element) {
                                    this.selectedTile.element.style.outline = '';
                                }
                                this.selectedTile = { element: tileElement, rowIndex: clickedRIndex, colIndex: clickedCIndex };
                                tileElement.style.outline = '3px solid var(--fluent-blue)';
                            }
                        });
                        
                        rowDiv.appendChild(tileElement);
                    });
                    boardElement.appendChild(rowDiv);
                });

                if (this.selectedTile && this.selectedTile.element) {
                    const {rowIndex, colIndex} = this.selectedTile;
                    if(rowIndex < this.guessRowsData.length && colIndex < this.length) {
                         const currentSelectedElem = boardElement.children[rowIndex]?.children[colIndex];
                         if(currentSelectedElem) {
                            currentSelectedElem.style.outline = '3px solid var(--fluent-blue)';
                            this.selectedTile.element = currentSelectedElem; 
                         } else {
                            this.selectedTile = null;
                         }
                    } else {
                        this.selectedTile = null;
                    }
                }
            }

            preprocessConstraints() {
                this.globalKnowledge = {
                    fixedChars: Array(this.length).fill(null),
                    cannotBeAt: Array(this.length).fill(null).map(() => new Set()),
                    mustAppearMinCount: new Map(),
                    mustAppearExactCount: new Map(),
                    globallyForbidden: new Set()
                };
                const gk = this.globalKnowledge;

                for (let r = 0; r < this.guessRowsData.length; r++) {
                    const row = this.guessRowsData[r];
                    for (let c = 0; c < this.length; c++) {
                        if (c >= row.length) continue;
                        const tile = row[c];
                        if (!tile.char) continue;

                        if (tile.state === 'correct') {
                            if (gk.fixedChars[c] && gk.fixedChars[c] !== tile.char) {
                                this.showError(`å†²çª: ä½ç½® ${c + 1} åŒæ—¶å›ºå®šä¸º ${gk.fixedChars[c]} å’Œ ${tile.char}.`); return false;
                            }
                            gk.fixedChars[c] = tile.char;
                            this.validChars.split('').forEach(vc => {
                                if (vc !== tile.char) gk.cannotBeAt[c].add(vc);
                            });
                        } else if (tile.state === 'present') {
                            gk.cannotBeAt[c].add(tile.char);
                        } else if (tile.state === 'empty' && tile.char) {
                            gk.cannotBeAt[c].add(tile.char);
                        }
                    }
                }

                const allCharsInGuesses = new Set();
                this.guessRowsData.forEach(row => row.forEach(tile => { if(tile.char) allCharsInGuesses.add(tile.char)}));

                for (const char of allCharsInGuesses) {
                    let minRequiredOverall = 0;
                    let derivedExactCount = undefined;

                    for (const row of this.guessRowsData) {
                        if (!row.some(tile => tile.char === char)) continue;

                        let greenInRow = 0;
                        let yellowInRow = 0;
                        row.forEach((tile) => {
                            if (tile.char === char) {
                                if (tile.state === 'correct') greenInRow++;
                                else if (tile.state === 'present') yellowInRow++;
                            }
                        });
                        
                        const minRequiredThisRow = greenInRow + yellowInRow;
                        minRequiredOverall = Math.max(minRequiredOverall, minRequiredThisRow);

                        if (row.some(tile => tile.char === char && tile.state === 'empty')) {
                            const exactCountThisRow = greenInRow + yellowInRow;
                            if (derivedExactCount === undefined) {
                                derivedExactCount = exactCountThisRow;
                            } else if (derivedExactCount !== exactCountThisRow) {
                                this.showError(`å†²çª: å­—ç¬¦ '${char}' åœ¨ä¸åŒçŒœæµ‹è¡Œä¸­æ¨æ–­å‡ºä¸åŒçš„ç²¾ç¡®æ•°é‡ (${derivedExactCount} vs ${exactCountThisRow}).`);
                                return false;
                            }
                        }
                    }

                    gk.mustAppearMinCount.set(char, minRequiredOverall);

                    if (derivedExactCount !== undefined) {
                        if (derivedExactCount < minRequiredOverall) {
                            this.showError(`å†²çª: å­—ç¬¦ '${char}' çš„ç²¾ç¡®æ•°é‡ (${derivedExactCount}) å°äºå…¶æœ€å°éœ€æ±‚æ•°é‡ (${minRequiredOverall}).`);
                            return false;
                        }
                        gk.mustAppearExactCount.set(char, derivedExactCount);
                        if (derivedExactCount === 0 && minRequiredOverall === 0) {
                            gk.globallyForbidden.add(char);
                        }
                    }
                }

                for (let i = 0; i < this.length; i++) {
                    const fixed = gk.fixedChars[i];
                    if (fixed) {
                        if (gk.globallyForbidden.has(fixed)) {
                            this.showError(`å†²çª: å­—ç¬¦ '${fixed}' åœ¨ä½ç½® ${i + 1} å›ºå®šä½†åŒæ—¶è¢«å…¨å±€ç¦ç”¨.`); return false;
                        }
                        if (gk.cannotBeAt[i].has(fixed)) {
                           this.showError(`å†²çª: å­—ç¬¦ '${fixed}' åœ¨ä½ç½® ${i + 1} å›ºå®šä½†åˆæ ‡è®°ä¸ºä¸èƒ½åœ¨è¯¥ä½ç½®.`); return false;
                        }
                        gk.mustAppearMinCount.set(fixed, Math.max(gk.mustAppearMinCount.get(fixed) || 0, 1));
                        if (gk.mustAppearExactCount.has(fixed)) {
                             if (gk.mustAppearExactCount.get(fixed) < (gk.mustAppearMinCount.get(fixed) || 0) ) {
                                 this.showError(`å†²çª: å­—ç¬¦ '${fixed}' çš„ç²¾ç¡®æ•°é‡ ${gk.mustAppearExactCount.get(fixed)} å°äºå…¶æœ€å°å›ºå®šè¦æ±‚.`); return false;
                             }
                        }
                    }
                }
                for(const [char, exact] of gk.mustAppearExactCount) {
                    const min = gk.mustAppearMinCount.get(char) || 0;
                    if (exact < min) {
                         this.showError(`å†²çª: å­—ç¬¦ '${char}' çš„ç²¾ç¡®æ•°é‡ (${exact}) å°äºå…¶æœ€å°éœ€æ±‚ (${min}).`); return false;
                    }
                }
                for (const char of gk.globallyForbidden) {
                    if ((gk.mustAppearMinCount.get(char) || 0) > 0) {
                         this.showError(`å†²çª: å­—ç¬¦ '${char}' è¢«å…¨å±€ç¦ç”¨ä½†åˆè¦æ±‚è‡³å°‘å‡ºç°.`); return false;
                    }
                    if (gk.mustAppearExactCount.has(char) && gk.mustAppearExactCount.get(char) > 0) {
                         this.showError(`å†²çª: å­—ç¬¦ '${char}' è¢«å…¨å±€ç¦ç”¨ä½†åˆè¦æ±‚ç²¾ç¡®å‡ºç°.`); return false;
                    }
                }
                return true;
            }


            async solve() {
                this.hideContextMenu();
                if (this.isRunning) return;
                
                    if (!this.preprocessConstraints()) {
                        return;
                    }
                

                this.isRunning = true;
                this.shouldStop = false;
                this.exportableState = null; // æ¸…é™¤ä»»ä½•å…ˆå‰çš„å¯å¯¼å‡ºçŠ¶æ€

                // å¦‚æœä¸æ˜¯æ¢å¤ï¼Œåˆ™é‡ç½®ç»Ÿè®¡ä¿¡æ¯ã€‚å¦‚æœæ¢å¤ï¼Œåˆ™ç»Ÿè®¡ä¿¡æ¯å·²åŠ è½½ã€‚
                if (!this.resumeState) {
                    this.results = [];
                    this.searchedCount = 0;
                    this.startTime = Date.now();
                    this.charProbabilitiesData = [];
                } else {
                    // æ¢å¤æ—¶ï¼Œè¿˜åŸå¼€å§‹æ—¶é—´ä»¥æ­£ç¡®è®¡ç®—æ€»è€—æ—¶ã€‚
                    this.startTime = Date.now() - (this.resumeState.stats.elapsedTime * 1000);
                }
                
                this.lastUIUpdate = Date.now();
                
                document.getElementById('solveBtn').classList.add('loading');
                document.getElementById('solveBtn').disabled = true;
                document.getElementById('clearBtn').classList.add('loading');
                document.getElementById('clearBtn').disabled = true;
                document.getElementById('addGuessRowBtn').classList.add('loading');
                document.getElementById('addGuessRowBtn').disabled = true;
                document.getElementById('exportSearchStateBtn').style.display = 'none';


                document.getElementById('solveBtn').style.display = 'none';
                document.getElementById('stopBtn').style.display = 'block';
                document.getElementById('progressContainer').style.display = 'block';
                document.getElementById('errorMessage').style.display = 'none';
                
                this.updateResults(); 
                this.updateCharProbabilitiesDisplay(); 
                 document.getElementById('recommendedResultContainer').innerHTML = 
                    '<div style="text-align: center; color: var(--color-text-secondary); padding: 20px;">æ±‚è§£ä¸­...</div>';

                
                try {
                    // ä¼ å…¥æ¢å¤çŠ¶æ€ï¼Œç„¶åæ¸…é™¤å®ƒï¼Œä»¥å…è¢«æ„å¤–å†æ¬¡ä½¿ç”¨
                    const stateToResume = this.resumeState;
                    this.resumeState = null;
                    await this.optimizedBruteForceSearch(stateToResume);
                } catch (error) {
                    this.showError('æ±‚è§£è¿‡ç¨‹ä¸­å‡ºç°é”™è¯¯: ' + error.message);
                } finally {
                    this.isRunning = false;
                    document.getElementById('solveBtn').classList.remove('loading');
                    document.getElementById('solveBtn').disabled = false;
                    document.getElementById('clearBtn').classList.remove('loading');
                    document.getElementById('clearBtn').disabled = false;
                    document.getElementById('addGuessRowBtn').classList.remove('loading');
                    document.getElementById('addGuessRowBtn').disabled = false;


                    document.getElementById('stopBtn').style.display = 'none';
                    
                    // å¦‚æœæ˜¯ç”¨æˆ·åœæ­¢äº†è¿›ç¨‹ï¼Œåˆ™æ˜¾ç¤ºå¯¼å‡ºæŒ‰é’®
                    if (this.shouldStop && this.exportableState) {
                        document.getElementById('exportSearchStateBtn').style.display = 'block';
                    } else {
                        document.getElementById('solveBtn').style.display = 'block';
                    }
                    
                    this.updateStats();
                    this.calculateAndDisplayProbabilities(); 
                    this.updateResultsWithRecommendation(); 
                    if (this.shouldStop) {
                         document.getElementById('progressText').textContent = `å·²åœæ­¢ - æœç´¢: ${this.searchedCount.toLocaleString()} - æ‰¾åˆ°: ${this.results.length}`;
                    } else {
                         document.getElementById('progressText').textContent = `å®Œæˆ - æœç´¢: ${this.searchedCount.toLocaleString()} - æ‰¾åˆ°: ${this.results.length}`;
                         document.getElementById('progressFill').style.width = '100%';
                    }
                     if (this.results.length === 0 && !this.shouldStop) {
                        document.getElementById('progressContainer').style.display = 'none';
                    }
                }
            }

            stop() {
                this.shouldStop = true;
            }
            
            isDigit(c) { return c && c >= '0' && c <= '9'; }
            isBinaryOperator(c) { return c && ['+', '-', '*', '/', '%', '^', 'A'].includes(c); }
            isUnaryPostOperator(c) { return c === '!'; }
            isOperator(c) { return this.isBinaryOperator(c) || this.isUnaryPostOperator(c); }
            isOpenBracket(c) { return c && (c === '(' || c === '['); }
            isCloseBracket(c) { return c && (c === ')' || c === ']'); }
            isMainOperator(c) { return c && (c === '=' || c === '>'); }
            getMatchingBracket(openBracket) { return openBracket === '(' ? ')' : (openBracket === '[' ? ']' : null); }

            canPlaceChar(char, index, currentExpressionArray, mainOpSoFar, currentExpressionCounts, floorContext) {
                const gk = this.globalKnowledge;

                if (gk.globallyForbidden.has(char)) return false;
                if (gk.fixedChars[index] && gk.fixedChars[index] !== char) return false;
                if (gk.cannotBeAt[index].has(char)) return false;

                const currentCountOfChar = currentExpressionCounts.get(char) || 0;
                const exactCountForChar = gk.mustAppearExactCount.get(char);
                if (exactCountForChar !== undefined && currentCountOfChar >= exactCountForChar) {
                    return false; 
                }

                if (floorContext.inFloor) {
                    if (char === '[') return false;
                    if (this.isOperator(char) && char !== '/') return false;
                    if (this.isMainOperator(char)) return false;
                    if (char === '(') return false;
                    if (char === 'A' || char === '!') return false;

                    if (char === '/') {
                        if (floorContext.hasSlashInCurrentFloor) return false;
                        const prevActualChar = index > 0 ? currentExpressionArray[index-1] : null;
                        if (!this.isDigit(prevActualChar) || index === 0) return false;
                    } else if (char === ']') {
                        const prevActualChar = index > 0 ? currentExpressionArray[index-1] : null;
                        if (!this.isDigit(prevActualChar)) return false;
                        if (!floorContext.hasSlashInCurrentFloor) return false; 
                    } else if (!this.isDigit(char)) {
                        return false;
                    }
                }

                if (char === '[' && floorContext.inFloor) return false; 
                if (char === ']' && !floorContext.inFloor) return false; 
                if (char === '[') {
                     if (index >= this.length - 3) return false;
                }


                if (this.isDigit(char) && mainOpSoFar !== '=') { 
                    let tempNumStr = char;
                    let k = index - 1;
                    while (k >= 0 && this.isDigit(currentExpressionArray[k])) {
                        tempNumStr = currentExpressionArray[k] + tempNumStr;
                        k--;
                    }

                    if (tempNumStr.length > 1 && tempNumStr.startsWith('0')) {
                        return false; 
                    }
                    
                    const charBeforeNumberSequence = (k >= 0) ? currentExpressionArray[k] : null;
                    if (charBeforeNumberSequence === null || 
                        this.isOperator(charBeforeNumberSequence) || 
                        this.isOpenBracket(charBeforeNumberSequence) ||
                        this.isMainOperator(charBeforeNumberSequence)) {
                            if (parseInt(tempNumStr, 10) > this.maxOperandValue) {
                                return false; 
                            }
                    }
                }

                const prevChar = index > 0 ? currentExpressionArray[index - 1] : null;

                if (index === 0) { 
                    if (this.isBinaryOperator(char) || this.isCloseBracket(char) || this.isMainOperator(char) || this.isUnaryPostOperator(char)) return false;
                }

                if (prevChar) {
                    if (this.isDigit(prevChar)) {
                        if (this.isOpenBracket(char) && char !== '[') return false; 
                        if (char === '[' && floorContext.inFloor) return false;
                    } else if (this.isOperator(prevChar)) { 
                        if (this.isBinaryOperator(char) && !(prevChar === 'A' && (this.isOpenBracket(char) || this.isDigit(char))) && !this.isUnaryPostOperator(prevChar)) return false; 
                        if (this.isCloseBracket(char)) return false; 
                        if (this.isMainOperator(char) && !this.isUnaryPostOperator(prevChar)) return false; 
                        if (this.isUnaryPostOperator(prevChar) && (this.isDigit(char) || this.isOpenBracket(char))) return false; 
                    } else if (this.isOpenBracket(prevChar)) {
                        if (prevChar === '[' && char === '(') return false; 
                        if (this.isBinaryOperator(char)) return false; 
                        if (this.isCloseBracket(char) && char !== this.getMatchingBracket(prevChar)) return false; 
                        if (this.isMainOperator(char)) return false; 
                        if (this.isUnaryPostOperator(char)) return false; 
                    } else if (this.isCloseBracket(prevChar)) {
                        if (this.isDigit(char)) return false; 
                        if (this.isOpenBracket(char)) return false; 
                    } else if (this.isMainOperator(prevChar)) { 
                         if (prevChar === '=') { 
                             if (!this.isDigit(char) && char !== '-') return false; 
                         } else { 
                             if (this.isMainOperator(char)) return false; 
                             if (this.isCloseBracket(char)) return false; 
                         }
                    }
                }

                if (mainOpSoFar === '=') { 
                    if (!this.isDigit(char) && char !== '-') return false;
                    if (char === '-' && (prevChar !== '=' || index >= this.length -1 || !this.isDigit(currentExpressionArray[index+1]))) {
                        // Allow '-' only right after '=', and if not at the very end, and followed by a digit
                        // This is a simplification. True parsing of negative numbers is complex.
                        // For this check, if char is '-', it implies potential negative number.
                        // If prevChar is not '=', then '-' is an operator, not a sign.
                        if (prevChar !== '=') { /* do nothing, standard operator rules apply */ }
                        else if (index >= this.length -1) return false; // - at the very end like ...=-
                        // The char after '-' must be a digit for a negative number. This needs lookahead or different parsing.
                        // For now, this rule is a bit loose.
                    }
                }


                if (index === this.length - 1) { 
                    if (this.isBinaryOperator(char) || this.isOpenBracket(char) || this.isMainOperator(char)) return false;
                }
                
                let tempExpressionForBracketCheck = currentExpressionArray.slice(0, index);
                tempExpressionForBracketCheck.push(char);
                let openParenDepth = 0;
                let openSquareDepth = 0;
                const openBracketsStack = [];

                for (let i = 0; i < tempExpressionForBracketCheck.length; i++) {
                    const c = tempExpressionForBracketCheck[i];
                    if (!c) continue;
                    if (c === '(') { openParenDepth++; openBracketsStack.push(c); }
                    else if (c === '[') { openSquareDepth++; openBracketsStack.push(c); }
                    else if (c === ')') {
                        openParenDepth--;
                        if (openParenDepth < 0 || openBracketsStack.pop() !== '(') return false;
                    } else if (c === ']') {
                        openSquareDepth--;
                         if (openSquareDepth < 0 || openBracketsStack.pop() !== '[') return false;
                    }
                }
                if (index === this.length - 1 && (openParenDepth !== 0 || openSquareDepth !== 0)) return false;

                if (this.isMainOperator(char)) {
                    if (mainOpSoFar && mainOpSoFar !== char && !(mainOpSoFar === '>' && char === '=')) return false; 
                    if (mainOpSoFar === char && char === '=') return false; 
                    if (index === 0 || index >= this.length - 1) return false; 
                }
                
                if (char === 'A') {
                    if (!prevChar || (!this.isDigit(prevChar) && !this.isCloseBracket(prevChar))) return false; 
                }
                if (prevChar === 'A') {
                    if (!this.isDigit(char) && !this.isOpenBracket(char)) return false; 
                }

                if (char === '!') {
                    if (!prevChar) return false; 
                    if (this.isDigit(prevChar)) {
                        if (prevChar === '0' && this.evaluateExpression("0!") === null) return false; 
                    } else if (this.isCloseBracket(prevChar)) {
                        if (prevChar === ']') return false; 
                    } else {
                        return false; 
                    }
                }
                
                return true;
            }

            async _optimizedRecursiveSearch(index, currentExpression, mainOpSoFar, currentExpressionCounts, floorContext) {
                if (this.shouldStop) return;
                const gk = this.globalKnowledge;

                if (index === this.length) {
                    this.searchedCount++;
                    if (!mainOpSoFar) return; 
                    if (!this.checkBrackets(currentExpression.join(''))) return;

                    for (const [char, exactCount] of gk.mustAppearExactCount) {
                        if ((currentExpressionCounts.get(char) || 0) !== exactCount) return;
                    }
                    for (const [char, minCount] of gk.mustAppearMinCount) {
                         if (!gk.mustAppearExactCount.has(char)) {
                            if ((currentExpressionCounts.get(char) || 0) < minCount) return;
                        }
                    }
                    
                    if (this.isValidSolution(currentExpression.join(''))) {
                        this.results.push(currentExpression.join(''));
                        if (this.results.length <= 500) {
                             this.updateResultsWithRecommendation();
                        }
                    }
                    if (this.searchedCount % 20000 === 0 || (Date.now() - this.lastUIUpdate > 100)) {
                        this.updateStats();
                        this.updateProgressWithSearchedCount();
                        if (this.results.length > 500 && this.results.length % 100 === 0) {
                            this.updateResultsWithRecommendation();
                        }
                        this.lastUIUpdate = Date.now();
                        await new Promise(resolve => setTimeout(resolve, 0));
                    }
                    return;
                }
                
                const fixedCharForThisPosition = gk.fixedChars[index];

                if (fixedCharForThisPosition) {
                    let nextFloorContext = { ...floorContext };
                    if (fixedCharForThisPosition === '[') nextFloorContext = { inFloor: true, hasSlashInCurrentFloor: false };
                    else if (fixedCharForThisPosition === ']' && floorContext.inFloor) nextFloorContext = { inFloor: false, hasSlashInCurrentFloor: false };
                    else if (fixedCharForThisPosition === '/' && floorContext.inFloor) nextFloorContext = { ...floorContext, hasSlashInCurrentFloor: true };
                    
                    if (this.canPlaceChar(fixedCharForThisPosition, index, currentExpression, mainOpSoFar, currentExpressionCounts, floorContext)) {
                        currentExpression[index] = fixedCharForThisPosition;
                        currentExpressionCounts.set(fixedCharForThisPosition, (currentExpressionCounts.get(fixedCharForThisPosition) || 0) + 1);
                        const newMainOp = this.isMainOperator(fixedCharForThisPosition) ? fixedCharForThisPosition : mainOpSoFar;
                        
                        await this._optimizedRecursiveSearch(index + 1, currentExpression, newMainOp, currentExpressionCounts, nextFloorContext);
                        
                        currentExpressionCounts.set(fixedCharForThisPosition, currentExpressionCounts.get(fixedCharForThisPosition) - 1);
                        if(currentExpressionCounts.get(fixedCharForThisPosition) === 0) currentExpressionCounts.delete(fixedCharForThisPosition);

                    }
                } else {
                    const optimizedCharOrder = this.getOptimizedCharOrder(index, currentExpression, mainOpSoFar, floorContext);
                    for (const charToTry of optimizedCharOrder) {
                        if (this.shouldStop) return;
                        
                        let nextFloorContext = { ...floorContext };
                        if (charToTry === '[') nextFloorContext = { inFloor: true, hasSlashInCurrentFloor: false };
                        else if (charToTry === ']' && floorContext.inFloor) nextFloorContext = { inFloor: false, hasSlashInCurrentFloor: false };
                        else if (charToTry === '/' && floorContext.inFloor) nextFloorContext = { ...floorContext, hasSlashInCurrentFloor: true };

                        if (this.canPlaceChar(charToTry, index, currentExpression, mainOpSoFar, currentExpressionCounts, floorContext)) {
                            currentExpression[index] = charToTry;
                            currentExpressionCounts.set(charToTry, (currentExpressionCounts.get(charToTry) || 0) + 1);
                            const newMainOp = this.isMainOperator(charToTry) ? charToTry : mainOpSoFar;

                            await this._optimizedRecursiveSearch(index + 1, currentExpression, newMainOp, currentExpressionCounts, nextFloorContext);
                            
                            currentExpressionCounts.set(charToTry, currentExpressionCounts.get(charToTry) - 1);
                            if(currentExpressionCounts.get(charToTry) === 0) currentExpressionCounts.delete(charToTry);
                        }
                    }
                }
                currentExpression[index] = ''; 
            }

            getOptimizedCharOrder(index, currentExpression, mainOpSoFar, floorContext) {
                const gk = this.globalKnowledge;
                if (gk.fixedChars[index]) {
                    return [gk.fixedChars[index]];
                }

                let orderedChars = [];
                const prevChar = index > 0 ? currentExpression[index - 1] : null;

                if (floorContext.inFloor) {
                    if (floorContext.hasSlashInCurrentFloor) {
                        orderedChars = ['0','1','2','3','4','5','6','7','8','9', ']'];
                    } else {
                        orderedChars = ['0','1','2','3','4','5','6','7','8','9', '/'];
                    }
                } else if (mainOpSoFar === '=') {
                     if (prevChar === '=') {
                        orderedChars = ['-', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9'];
                    } else {
                        orderedChars = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9'];
                    }
                } else if (index === 0) {
                    orderedChars = ['1', '2', '3', '4', '5', '6', '7', '8', '9', '(', '[']; 
                } else if (this.isDigit(prevChar)) {
                    orderedChars = ['0','1','2','3','4','5','6','7','8','9', 
                                    '+', '-', '*', '/', '%', '^', 'A', '!', 
                                    ')', ']', '[', 
                                    '=', '>'];
                } else if (this.isBinaryOperator(prevChar) || prevChar === 'A' || (this.isMainOperator(prevChar) && prevChar !== '=')) {
                    orderedChars = ['1','2','3','4','5','6','7','8','9','0', '(', '['];
                } else if (this.isOpenBracket(prevChar)) {
                    orderedChars = ['1','2','3','4','5','6','7','8','9','0', '(', '['];
                } else if (this.isCloseBracket(prevChar) || this.isUnaryPostOperator(prevChar)) {
                    orderedChars = ['+', '-', '*', '/', '%', '^', 'A', '!', 
                                    ')', ']', '[',
                                    '=', '>'];
                } else { 
                    orderedChars = ['1','2','3','4','5','6','7','8','9','0',
                                    '+','-','*','/', '=', 
                                    '(','[', ')',']',
                                    '%','^','!','A','>'];
                }

                if (index === this.length - 1 && !floorContext.inFloor) {
                    const endChars = ['0','1','2','3','4','5','6','7','8','9', ')', ']', '!'];
                    orderedChars = orderedChars.filter(c => endChars.includes(c));
                     if (orderedChars.length === 0 && prevChar) { 
                         orderedChars = endChars;
                     } else if (orderedChars.length === 0 && index === 0 && this.length === 1) { 
                         orderedChars = ['0','1','2','3','4','5','6','7','8','9'];
                     }
                }
                
                return [...new Set(orderedChars)].filter(c => 
                    !gk.globallyForbidden.has(c) && 
                    !gk.cannotBeAt[index].has(c)
                );
            }
            prepareExportState(topLevelChars, currentIndex) {
                const elapsedTime = (Date.now() - this.startTime) / 1000;
                this.exportableState = {
                    version: "1.0",
                    length: this.length,
                    rows: this.guessRowsData,
                    results: this.results,
                    stats: {
                        searchedCount: this.searchedCount,
                        elapsedTime: elapsedTime
                    },
                    progress: {
                        topLevelChars: topLevelChars,
                        resumeIndex: currentIndex // ä»è¿™ä¸ªç´¢å¼•æ¢å¤
                    }
                };
            }

            exportSearchState() {
                if (!this.exportableState) {
                    this.showError("æ²¡æœ‰å¯å¯¼å‡ºçš„æš‚åœçŠ¶æ€ã€‚è¯·å…ˆè¿è¡Œå¹¶åœæ­¢ä¸€ä¸ªæœç´¢ã€‚");
                    return;
                }
                
                try {
                    this.showError("æ­£åœ¨ç”ŸæˆçŠ¶æ€æ–‡ä»¶...");
                    const stateString = JSON.stringify(this.exportableState);
                    const blob = new Blob([stateString], { type: 'application/json' });
                    
                    const a = document.createElement('a');
                    const url = URL.createObjectURL(blob);
                    a.href = url;
                    
                    const timestamp = new Date().toISOString().slice(0, 19).replace(/[-:T]/g, '');
                    a.download = `sumzle_solver_state_${timestamp}.json`;
                    
                    document.body.appendChild(a);
                    a.click();
                    
                    setTimeout(() => {
                        document.body.removeChild(a);
                        URL.revokeObjectURL(url);
                        this.showError("çŠ¶æ€æ–‡ä»¶å·²å¯¼å‡ºã€‚");
                    }, 0);

                } catch (err) {
                    this.showError("å¯¼å‡ºå¤±è´¥: " + err.message);
                }
            }
handleFileImport(event) {
                const fileInput = event.target;
                const file = fileInput.files[0];
                if (!file) {
                    return; // No file selected
                }

                this.showError("æ­£åœ¨è¯»å–çŠ¶æ€æ–‡ä»¶...");
                const reader = new FileReader();

                reader.onload = (e) => {
                    try {
                        const stateString = e.target.result;
                        const state = JSON.parse(stateString);
                        
                        if (state.version !== "1.0" || !state.progress || !state.rows) {
                            throw new Error("çŠ¶æ€æ–‡ä»¶æ— æ•ˆæˆ–ç‰ˆæœ¬ä¸å…¼å®¹ã€‚");
                        }
                        
                        this.clear();

                        setTimeout(() => {
                            // Restore state from file
                            this.length = state.length;
                            this.guessRowsData = state.rows;
                            this.results = state.results;
                            this.searchedCount = state.stats.searchedCount;
                            this.resumeState = state; // Store full state for the solve method

                            // Update UI
                            document.getElementById('lengthInput').value = this.length;
                            this.updateConstraintBoard();
                            this.updateResultsWithRecommendation();
                            
                            const elapsed = state.stats.elapsedTime;
                            const speed = elapsed > 0 ? Math.round(this.searchedCount / elapsed) : 0;
                            document.getElementById('foundCount').textContent = this.results.length.toLocaleString();
                            document.getElementById('searchedCount').textContent = this.searchedCount.toLocaleString();
                            document.getElementById('timeElapsed').textContent = elapsed.toFixed(1) + 's';
                            document.getElementById('searchSpeed').textContent = speed.toLocaleString();
                            this.calculateAndDisplayProbabilities();

                            this.showError("çŠ¶æ€å¯¼å…¥æˆåŠŸï¼ç‚¹å‡» 'å¼€å§‹æ±‚è§£' ä»¥ç»§ç»­ã€‚");
                            document.getElementById('exportSearchStateBtn').style.display = 'none';
                        }, 100);

                    } catch (err) {
                        this.showError("å¯¼å…¥å¤±è´¥: " + err.message);
                        this.resumeState = null;
                    } finally {
                        // Reset file input to allow importing the same file again
                        fileInput.value = null;
                    }
                };

                reader.onerror = () => {
                    this.showError("è¯»å–æ–‡ä»¶æ—¶å‡ºé”™ã€‚");
                    fileInput.value = null;
                };

                reader.readAsText(file);
            }

            importSearchState() {
                const textarea = document.getElementById('searchStateInput');
                const stateString = textarea.value.trim();
                if (!stateString) {
                    this.showError("è¯·ç²˜è´´è¦å¯¼å…¥çš„æœç´¢çŠ¶æ€ã€‚");
                    return;
                }
                try {
                    const state = JSON.parse(stateString);
                    if (state.version !== "1.0" || !state.progress || !state.rows) {
                        throw new Error("çŠ¶æ€ç æ— æ•ˆæˆ–ç‰ˆæœ¬ä¸å…¼å®¹ã€‚");
                    }
                    
                    this.clear();

                    setTimeout(() => {
                        // æ¢å¤çŠ¶æ€
                        this.length = state.length;
                        this.guessRowsData = state.rows;
                        this.results = state.results;
                        this.searchedCount = state.stats.searchedCount;
                        this.resumeState = state; // ä¸º solve æ–¹æ³•å­˜å‚¨å®Œæ•´çŠ¶æ€

                        // æ›´æ–°UI
                        document.getElementById('lengthInput').value = this.length;
                        this.updateConstraintBoard();
                        this.updateResultsWithRecommendation();
                        
                        const elapsed = state.stats.elapsedTime;
                        const speed = elapsed > 0 ? Math.round(this.searchedCount / elapsed) : 0;
                        document.getElementById('foundCount').textContent = this.results.length.toLocaleString();
                        document.getElementById('searchedCount').textContent = this.searchedCount.toLocaleString();
                        document.getElementById('timeElapsed').textContent = elapsed.toFixed(1) + 's';
                        document.getElementById('searchSpeed').textContent = speed.toLocaleString();
                        this.calculateAndDisplayProbabilities();

                        this.showError("çŠ¶æ€å¯¼å…¥æˆåŠŸï¼ç‚¹å‡» 'å¼€å§‹æ±‚è§£' ä»¥ç»§ç»­ã€‚");
                        document.getElementById('exportSearchStateBtn').style.display = 'none';
                    }, 100);

                } catch (e) {
                    this.showError("å¯¼å…¥å¤±è´¥: " + e.message);
                    this.resumeState = null;
                }
            }

            async optimizedBruteForceSearch(resumeState = null) {
                this.lastUIUpdate = Date.now();
                const initialExpression = Array(this.length).fill('');
                const initialCounts = new Map();
                const initialFloorContext = { inFloor: false, hasSlashInCurrentFloor: false };
                
                // ç¡®å®šç¬¬ä¸€ä¸ªä½ç½®ï¼ˆç´¢å¼•0ï¼‰çš„å­—ç¬¦é›†
                const topLevelChars = resumeState ? resumeState.progress.topLevelChars : this.getOptimizedCharOrder(0, initialExpression, null, initialFloorContext);
                const totalTopLevelBranches = topLevelChars.length;
                
                // ç¡®å®šèµ·ç‚¹
                let startBranchIndex = resumeState ? resumeState.progress.resumeIndex : 0;

                for (let i = startBranchIndex; i < totalTopLevelBranches; i++) {
                    const charToTry = topLevelChars[i];
                    
                    // æ£€æŸ¥æ˜¯å¦éœ€è¦åœæ­¢
                    if (this.shouldStop) {
                        this.prepareExportState(topLevelChars, i);
                        return; // é€€å‡ºæœç´¢
                    }
                    
                    // æ ¹æ®é¡¶å±‚å¾ªç¯æ›´æ–°è¿›åº¦
                    const progressPercentage = ((i + 1) / totalTopLevelBranches) * 100;
                    this.updateProgress(progressPercentage);
                    
                    let nextFloorContext = { ...initialFloorContext };
                    if (charToTry === '[') nextFloorContext = { inFloor: true, hasSlashInCurrentFloor: false };
                    else if (charToTry === ']' && initialFloorContext.inFloor) nextFloorContext = { inFloor: false, hasSlashInCurrentFloor: false };
                    else if (charToTry === '/' && initialFloorContext.inFloor) nextFloorContext = { ...initialFloorContext, hasSlashInCurrentFloor: true };

                    if (this.canPlaceChar(charToTry, 0, initialExpression, null, initialCounts, initialFloorContext)) {
                        initialExpression[0] = charToTry;
                        initialCounts.set(charToTry, (initialCounts.get(charToTry) || 0) + 1);
                        const newMainOp = this.isMainOperator(charToTry) ? charToTry : null;

                        // ä»ç¬¬äºŒä¸ªä½ç½®ï¼ˆç´¢å¼•1ï¼‰å¼€å§‹é€’å½’
                        await this._optimizedRecursiveSearch(1, initialExpression, newMainOp, initialCounts, nextFloorContext);
                        
                        // ä¸ºä¸‹ä¸€ä¸ªé¡¶å±‚å­—ç¬¦è¿›è¡Œå›æº¯
                        initialCounts.set(charToTry, initialCounts.get(charToTry) - 1);
                        if(initialCounts.get(charToTry) === 0) initialCounts.delete(charToTry);
                    }
                }
                // å¯¹è¡¨è¾¾å¼æ•°ç»„çš„æœ€ç»ˆå›æº¯
                initialExpression[0] = '';
            }
            
            updateProgress(percentage) {
                const fill = document.getElementById('progressFill');
                const text = document.getElementById('progressText');
                
                const cappedPercentage = Math.min(100, percentage);
                fill.style.width = `${cappedPercentage}%`;
                text.textContent = `è¿›åº¦: ${cappedPercentage.toFixed(1)}% - å·²æœç´¢: ${this.searchedCount.toLocaleString()} - æ‰¾åˆ°: ${this.results.length}`;
            }

            isValidSolution(expression) {
                return this.isValidEquation(expression);
            }
        isInteger(value) {
            return typeof value === 'number' && !isNaN(value) && isFinite(value) && Number.isInteger(value);
        }

        isValidEquation(expression) {
            try {
                if (!this.checkBrackets(expression)) return false;
                
                let mainOp = null;
                let mainOpIndex = -1;
                let depth = 0;
                let hasMinusOnRHSStart = false;
                
                for (let i = 0; i < expression.length; i++) {
                    const char = expression[i];
                    if (this.isOpenBracket(char)) depth++;
                    else if (this.isCloseBracket(char)) depth--;
                    else if (depth === 0 && this.isMainOperator(char)) {
                        if (mainOp !== null && mainOp !== char) { 
                            if (!(mainOp === '>' && char === '=')) return false; 
                        }
                        if (mainOp === null) {
                            mainOp = char;
                            mainOpIndex = i;
                        } else if (char === '=' && mainOp === '>') { 
                             mainOp = '>='; 
                        } else if (mainOp === '=' && char === '=') { 
                            return false; 
                        }
                    }
                }
                
                if (!mainOp || mainOpIndex === 0 || mainOpIndex === expression.length - 1) return false;
                
                let leftSideString = expression.substring(0, mainOpIndex - (mainOp === '>=' ? 1:0) );
                let rightSideString = expression.substring(mainOpIndex + 1);

                if (mainOp === '=' && rightSideString.startsWith('-')) {
                    hasMinusOnRHSStart = true;
                }


                 if (leftSideString.length === 0 || rightSideString.length === 0) return false;
                 if (hasMinusOnRHSStart && rightSideString.length === 1) return false; // Just "=" or "=-"
                
                const leftValue = this.evaluateExpression(leftSideString);
                const rightValue = this.evaluateExpression(rightSideString);
                
                if (leftValue === null || rightValue === null) return false;
                
                if (!this.isInteger(leftValue) || !this.isInteger(rightValue)) {
                    return false;
                }
                
                if (mainOp === '=' && !this.isSimpleNumberOrNegativeNumber(rightSideString)) {
                    return false;
                }
                
                if (mainOp === '=') return leftValue === rightValue; 
                if (mainOp === '>' || mainOp === '>=') return leftValue > rightValue; 
                
            } catch (error) { return false; }
            return false;
        }

            isSimpleNumberOrNegativeNumber(expr) {
                return /^-?\d+$/.test(expr.trim());
            }
           
            checkBrackets(expression) {
                const stack = [];
                for (const char of expression) {
                    if (this.isOpenBracket(char)) stack.push(char);
                    else if (this.isCloseBracket(char)) {
                        if (stack.length === 0) return false;
                        const lastOpen = stack.pop();
                        if (char !== this.getMatchingBracket(lastOpen)) return false;
                    }
                }
                return stack.length === 0;
            }

            evaluateExpression(expr) {
                try {
                    if (expr.length === 0) return null;
                    let processedExpr = expr;

                    let bracketIterations = 0;
                    const maxBracketIterations = 10; 
                    while (/\[[^\[\]]+\]/.test(processedExpr) && bracketIterations < maxBracketIterations) {
                        processedExpr = processedExpr.replace(/\[([^\[\]]+)\]/g, (match, innerExpr) => {
                            if (!/^\d+\/\d+$/.test(innerExpr) && !/^\d+$/.test(innerExpr) ) { 
                                if( /^\d+$/.test(innerExpr) ) {
                                   const val = this.evaluateExpression(innerExpr);
                                   return (val !== null && typeof val === 'number' && !isNaN(val)) ? Math.floor(val).toString() : 'NaN';
                                }
                                return 'NaN'; 
                            }
                            if (innerExpr.trim() === '') return 'NaN'; 
                            const val = this.evaluateExpression(innerExpr);
                            return (val !== null && typeof val === 'number' && !isNaN(val)) ? Math.floor(val).toString() : 'NaN';
                        });
                        bracketIterations++;
                    }
                    if (bracketIterations >= maxBracketIterations && /\[[^\[\]]+\]/.test(processedExpr)) return null;

                    if (processedExpr.includes('NaN')) return null;

                    processedExpr = processedExpr.replace(/(\d+)!/g, (match, numStr) => {
                        const n = parseInt(numStr);
                        if (n === 0) return '1'; 
                        if (n > 12 || n < 0) return 'NaN'; 
                        let factorial = 1;
                        for (let i = 2; i <= n; i++) factorial *= i;
                        return factorial.toString();
                    });
                    if (processedExpr.includes('NaN')) return null;

                    processedExpr = processedExpr.replace(/(\d+)A(\d+)/g, (match, mStr, nStr) => {
                        const mVal = parseInt(mStr);
                        const nVal = parseInt(nStr);
                        if (mVal > 10 || nVal > 10 || nVal > mVal || mVal < 0 || nVal < 0) return 'NaN'; 
                        let result = 1;
                        for (let i = 0; i < nVal; i++) result *= (mVal - i);
                        return result.toString();
                    });
                    if (processedExpr.includes('NaN')) return null;

                    processedExpr = processedExpr.replace(/\^/g, '**'); 
                    
                    return this.evaluateSimpleExpression(processedExpr);
                } catch (error) { 
                    return null; 
                }
            }

            evaluateSimpleExpression(expr) {
                try {
                    if (expr.includes('NaN')) return null;
                    if (/\b0[0-9]+\b/.test(expr) && !expr.startsWith("0.")) return null;

                    const invalidPatterns = [
                        /[\+\-\*\/%]{2,}(?!\*)/, 
                        /(^[\*\/%])|([\+\-\*\/%]$)(?<!\d-)/, 
                        /\(\)/, /\[\]/, 
                        /\(\s*\)/, /\[\s*\]/, 
                        /\d+\s+\d+/, 
                        /\)\(/,       
                        /\d\(/,       
                        /\)\d/,       
                    ];
                    for (const pattern of invalidPatterns) {
                         if (pattern.test(expr.replace(/\*\*/g,"").replace(/(\d)-/g, '$1_minus_'))) return null; 
                    }

                    const allowedCharsPattern = /^[0-9.+\-*/%()\s]+$/; 
                    if (!allowedCharsPattern.test(expr.replace(/\*\*/g, ""))) return null;
                    
                    const result = Function('"use strict"; return (' + expr + ')')();
                    if (typeof result === 'number' && !isNaN(result) && isFinite(result)) {
                        return result;
                    }
                    return null;
                } catch (error) { return null; }
            }

        

        updateProgressWithSearchedCount() {
            const text = document.getElementById('progressText');
            text.textContent = `å·²æœç´¢: ${this.searchedCount.toLocaleString()} - æ‰¾åˆ°: ${this.results.length}`;
            const fill = document.getElementById('progressFill');
            if(this.results.length > 0 && fill.style.width === "0%") { 
                fill.style.width = "5%"; 
            }
        }

        updateStats() {
            const elapsed = (Date.now() - this.startTime) / 1000;
            const speed = elapsed > 0 ? Math.round(this.searchedCount / elapsed) : 0;
            
            document.getElementById('foundCount').textContent = this.results.length.toLocaleString();
            document.getElementById('searchedCount').textContent = this.searchedCount.toLocaleString();
            document.getElementById('timeElapsed').textContent = elapsed.toFixed(1) + 's';
            document.getElementById('searchSpeed').textContent = speed.toLocaleString();
        }

        updateResults(highlightedRecommendedSolution = null) {
            const container = document.getElementById('resultsContainer');
            
            if (this.results.length === 0 && !this.isRunning) {
                container.innerHTML = '<div style="text-align: center; color: var(--color-text-secondary); padding: 40px;">æš‚æ— æ‰¾åˆ°ç¬¦åˆæ¡ä»¶çš„è§£</div>';
                return;
            }
             if (this.results.length === 0 && this.isRunning) {
                container.innerHTML = '<div style="text-align: center; color: var(--color-text-secondary); padding: 40px;">æ­£åœ¨æœç´¢...</div>';
                return;
            }
            
            let html = `<div class="result-count">æ‰¾åˆ° ${this.results.length} ä¸ªè§£${this.results.length > 500 ? " (ä»…æ˜¾ç¤ºå‰500)" : ""}:</div>`;
            this.results.slice(0, 500).forEach((result, index) => {
                let displayResult = result;
                let tempResult = result;
                for (const [actual, display] of Object.entries(this.displayCharsMap)) {
                    const regex = new RegExp(actual.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'g');
                    tempResult = tempResult.replace(regex, display);
                }
                displayResult = tempResult;

                const isRecommended = result === highlightedRecommendedSolution;
                const itemClass = isRecommended ? "result-item recommended" : "result-item";
                html += `<div class="${itemClass}">${index + 1}. ${displayResult} ${isRecommended ? " (â­æ¨è)" : ""}</div>`;
            });
            
            container.innerHTML = html;
        }

        updateResultsWithRecommendation() {
            const recommendedContainer = document.getElementById('recommendedResultContainer');

            if (this.results.length === 0) {
                this.updateResults();
                recommendedContainer.innerHTML = '<div style="text-align: center; color: var(--color-text-secondary); padding: 20px;">æ— è§£åˆ™æ— æ¨è</div>';
                return;
            }
            if (this.charProbabilitiesData.length === 0 && this.results.length > 0) {
                 this.calculateAndDisplayProbabilities();
            }


            let bestSolution = null;
            let bestScore = -1;

            const topChars = this.charProbabilitiesData.slice(0, Math.min(5, this.charProbabilitiesData.length)).map(p => p.char);

            this.results.forEach(solution => {
                let score = 0;
                const uniqueCharsInSolution = new Set(solution.split(''));
                
                uniqueCharsInSolution.forEach(char => {
                    const probItem = this.charProbabilitiesData.find(p => p.char === char);
                    if (probItem) {
                        score += probItem.probability; 
                    }
                });
                
                let bonusForTopChars = 0;
                topChars.forEach(topChar => {
                    if(uniqueCharsInSolution.has(topChar)) bonusForTopChars += 50; 
                });
                score += bonusForTopChars;

                if (score > bestScore) {
                    bestScore = score;
                    bestSolution = solution;
                }
            });
            
            if (bestSolution) {
                let displayRecResult = bestSolution;
                 let tempRecResult = bestSolution;
                for (const [actual, display] of Object.entries(this.displayCharsMap)) {
                    const regex = new RegExp(actual.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'g');
                    tempRecResult = tempRecResult.replace(regex, display);
                }
                displayRecResult = tempRecResult;
                recommendedContainer.innerHTML = `<div class="recommended-result-item">${displayRecResult}</div>`;
            } else {
                recommendedContainer.innerHTML = '<div style="text-align: center; color: var(--color-text-secondary); padding: 20px;">æ— å¯ç”¨æ¨è</div>';
            }
            
            this.updateResults(bestSolution);
        }
        
        calculateAndDisplayProbabilities() {
            const charCounts = {};
            if (this.results.length === 0) {
                this.charProbabilitiesData = []; 
                this.updateCharProbabilitiesDisplay();
                return;
            }

            this.results.forEach(solution => {
                const uniqueCharsInSolution = new Set(solution.split(''));
                uniqueCharsInSolution.forEach(char => {
                    charCounts[char] = (charCounts[char] || 0) + 1;
                });
            });

            this.charProbabilitiesData = Object.entries(charCounts).map(([char, count]) => ({
                char,
                probability: (count / this.results.length) * 100
            })).sort((a, b) => b.probability - a.probability || a.char.localeCompare(b.char));
            
            this.updateCharProbabilitiesDisplay();
        }

        updateCharProbabilitiesDisplay() {
            const container = document.getElementById('charProbContainer');
            if (this.charProbabilitiesData.length === 0) {
                container.innerHTML = '<div style="text-align: center; color: var(--color-text-secondary); padding: 20px;">æ— æ•°æ®æˆ–æœªæ‰¾åˆ°è§£</div>';
                return;
            }

            let html = '';
            const maxProb = Math.max(...this.charProbabilitiesData.map(p => p.probability), 0);

            this.charProbabilitiesData.forEach(item => {
                const displayChar = this.displayCharsMap[item.char] || item.char;
                const barWidth = maxProb > 0 ? (item.probability / maxProb) * 100 : 0;
                html += `
                    <div class="prob-item">
                        <div class="prob-char-display">${displayChar}</div>
                        <div class="prob-bar-container">
                            <div class="prob-bar" style="width: ${barWidth}%;"></div>
                        </div>
                        <div class="prob-value">${item.probability.toFixed(1)}%</div>
                    </div>
                `;
            });
            container.innerHTML = html;
        }

        clear() {
            this.hideContextMenu();
            this.isRunning = false;
            this.shouldStop = true; 
            
            setTimeout(() => { 
                this.results = [];
                this.searchedCount = 0;
                this.globalKnowledge = {}; 
                this.charProbabilitiesData = [];
                
                this.guessRowsData = []; 
                document.getElementById('lengthInput').value = 6;
                this.length = 6;
                this.updateConstraintBoard(); 

                this.updateResults();
                this.updateStats();
                this.updateCharProbabilitiesDisplay();
                 document.getElementById('recommendedResultContainer').innerHTML = 
                    '<div style="text-align: center; color: var(--color-text-secondary); padding: 20px;">ç­‰å¾…æ±‚è§£å¼€å§‹...</div>';


                document.getElementById('errorMessage').style.display = 'none';
                document.getElementById('progressContainer').style.display = 'none';
                document.getElementById('progressFill').style.width = '0%';
                document.getElementById('progressText').textContent = 'å‡†å¤‡ä¸­...';
                
                const solveBtn = document.getElementById('solveBtn');
                const clearBtn = document.getElementById('clearBtn');
                const addGuessRowBtn = document.getElementById('addGuessRowBtn');

                solveBtn.style.display = 'block';
                solveBtn.classList.remove('loading');
                solveBtn.disabled = false;
                clearBtn.classList.remove('loading');
                clearBtn.disabled = false;
                addGuessRowBtn.classList.remove('loading');
                addGuessRowBtn.disabled = false;
                document.getElementById('stopBtn').style.display = 'none';

                if (this.selectedTile && this.selectedTile.element) {
                    this.selectedTile.element.style.outline = '';
                }
                this.selectedTile = null;
                 document.getElementById('importGameStateInput').value = '';
            }, 50); 
        }

        showError(message) {
            const errorDiv = document.getElementById('errorMessage');
            errorDiv.textContent = message;
            errorDiv.style.display = 'block';
        }

        toggleTheme() {
            document.body.classList.toggle('dark-theme');
            const toggle = document.getElementById('themeToggle');
            toggle.textContent = document.body.classList.contains('dark-theme') ? 'ğŸŒ™' : 'â˜€ï¸';
        }

         importGameState() {
            const importInput = document.getElementById('importGameStateInput');
            const gameStateString = importInput.value.trim();
            if (!gameStateString) {
                this.showError("è¯·è¾“å…¥è¦å¯¼å…¥çš„å±€é¢ç ã€‚");
                return;
            }
            try {
                const gameState = JSON.parse(gameStateString);
                if (!gameState || typeof gameState.length !== 'number' || !Array.isArray(gameState.rows) ) {
                    throw new Error("å±€é¢ç æ ¼å¼æ— æ•ˆæˆ–ç‰ˆæœ¬ä¸å…¼å®¹ã€‚");
                }

                this.clear(); 

                setTimeout(() => { 
                    this.length = gameState.length;
                    document.getElementById('lengthInput').value = this.length;
                   
                    this.guessRowsData = gameState.rows.map(row => 
                        row.map(tile => ({
                            char: tile.char || '',
                            state: tile.state || 'empty'
                        }))
                    );

                    this.updateConstraintBoard();
                    importInput.value = ''; 
                    
                    this.showError("å±€é¢å¯¼å…¥æˆåŠŸï¼"); 
                    setTimeout(()=> {
                        const errorDiv = document.getElementById('errorMessage');
                        if (errorDiv.textContent === "å±€é¢å¯¼å…¥æˆåŠŸï¼") {
                           errorDiv.style.display = 'none';
                        }
                    }, 2000);
                }, 100); 
            } catch (error) {
                this.showError("å¯¼å…¥å±€é¢å¤±è´¥ï¼š" + error.message);
            }
        }
    }

    document.addEventListener('DOMContentLoaded', () => {
        new OptimizedSumzleSolver();
        if (!document.getElementById('foundCount').textContent || document.getElementById('foundCount').textContent === '0') {
            const stats = {foundCount: '0', searchedCount: '0', timeElapsed: '0.0s', searchSpeed: '0'};
            for(const id in stats) document.getElementById(id).textContent = stats[id];
            document.getElementById('charProbContainer').innerHTML = '<div style="text-align: center; color: var(--color-text-secondary); padding: 20px;">æ±‚è§£åæ˜¾ç¤ºæ¦‚ç‡</div>';
             document.getElementById('recommendedResultContainer').innerHTML = 
                    '<div style="text-align: center; color: var(--color-text-secondary); padding: 20px;">æ±‚è§£åæ˜¾ç¤ºæ¨è</div>';
            document.getElementById('resultsContainer').innerHTML = '<div style="text-align: center; color: var(--color-text-secondary); padding: 40px;">ç­‰å¾…æ±‚è§£å¼€å§‹...</div>';
        }
    });
</script>
</body>
</html>